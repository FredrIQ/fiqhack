#!/usr/bin/env perl
use utf8;     # this source file is UTF-8
use warnings;
use strict;

# aimake: automated build system for C programs
# Copyright Â© 2013, 2014, 2015 Alex Smith.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# A copy of version 3 of the GNU General Public License is embedded in
# the documentation later in this file, and can most conveniently be
# viewed via running this file with the --license option.
# Alternatively, it can be viewed in this file's source, or online at
# <http://www.gnu.org/licenses/>.

# Note: to skip the documentation in an editor and start at the start
# of the main program, search for 'use 5'

####### Documentation

=encoding utf8

=head1 NAME

aimake - build and/or install C programs with minimal configuration

=head1 SYNOPSIS

The most common way to build and install a program using aimake is:

B<mkdir> F<build>; B<cd> F<build>; F<../aimake> B<-i> F<installdir>

or to install for all users, rather than just yourself:

B<mkdir> F<build>; B<cd> F<build>; F<../aimake> B<-i> F</usr/local>
B<-S> B<sudo>

Commonly used options:

=over 4

=item B<-v>

Produce more verbose output (can be given multiple times).

=item B<-i> F<directory>

Install the program into the specified directory, as well as building it.

=item B<-S> F<program>

When installing, use the specified program (normally F<su> or F<sudo>) to
gain administrator permissions.

=item B<--with=>I<feature>

Turn on the specified feature of the program you are building.

=back

For full documentation on B<aimake>, use the B<--documentation> argument.

=head1 DESCRIPTION

B<aimake> is a build system for C programs that attempts to deduce as much as
possible itself, rather than requiring a separate file along the lines of
C<Makefile>, C<config.ac>, or C<CMakeLists.txt>.  In the most common cases, no
configuration file is required at all, although a rudimentary configuration
file can be used to specify more complicated things that cannot be
automatically deduced (such as which files contain the entry points to
libraries, or what commands to use to generate generated source files).

To compile a project with aimake for the first time, create an empty
directory, then call aimake from that directory.  By default, it will compile
the source files in the same directory tree as aimake itself.  You can use a
version of aimake other than the version shipped with the project by running
your version of aimake (from the build directory), and giving the path to the
root of the project's distribution as an argument.  To rebuild the project,
call aimake with no arguments in your build directory.  To install it, call
aimake with the B<-i> switch, and specify where you want to install it (you
can use just B<-i> by itself to install in the same place as last time).

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose=>I<number>

Set how verbose the build should be.  The default level is 0; higher values
produce more verbose output.  (You can get higher values via specifying a
number, or via specifying the B<-v> option multiple times.)  The messages you
get at each verbosity level are:

=over 4

=item -v-2

No messages at all.  Even important ones.

=item -v-1

Messages about warnings, errors, and failures to compile.  No messages will be
printed if everything works correctly.

=item -v0

Level -1 messages, plus messages about operations that aimake is performing
that actually contribute to compiling the code (e.g. running compilers,
linkers, and so on).  At level 0 and above, aimake also displays the details
of what it is thinking temporarily, using one line that repeatedly changes.

=item -v1

Level 0 messages, plus messages about other operations that aimake performs
(such as determining dependencies).

=item -v2

Level 1 messages, plus a record of all the actual commands that are run.
Additionally, the temporary messages about what aimake is doing are left on
the screen, rather than removed.

=item -v3

Level 2 messages, plus descriptions of which rules aimake is considering to
run and why.  This is mostly useful for debugging aimake, but may also help
to debug performance issues with rules.

=item -v4

Level 3 messages, plus information useful mostly for debugging aimake itself.

=item -v5

Level 4 messages, plus particularly verbose information useful mostly for
debugging aimake itself.

=back

=item B<-i> F<directory>, B<--install=>F<directory>

Specifies the install directory for the project being built.  If this option
is not given, aimake will use the same directory as last time, or a default
directory on the first build.  It is also possible to give B<-i> with no
directory; this is equivalent to explicitly specifying the same directory as
last time.

If the directory in question does not exist, it must be given with an absolute
path.  (Relative paths are OK if the directory already exists.)

The specific directories to install in are deduced from the directory given.
For instance, if on a UNIX/Linux system you gave F</usr/local> as the
directory to install into, aimake would put the application's read-write data
files under F</var/local>, whereas installing into F</usr> would put them
under F</var/lib>, and installing into F</home/user/package> would put them
inside the install directory.  You can control the details of the install with
the B<--directory-layout> option or "directory_layout" configuration option.

This option, together with B<-S>, control whether aimake will attempt to
install the project, or just build it:

=over 4

=item *

If B<-i> is not given, the project will not be installed by this run of
aimake.

=item *

If B<-i> and B<-S> are both given, the project will always be installed by
this run of aimake.

=item *

If B<-i> is given but B<-S> is not given, the project will be installed if and
only if the specified directory is writable by the user running aimake.

=back

=item B<-S> I<command>, B<--elevate-permissions=>I<command>

Specifies an appropriate command to use to elevate permissions (on UNIX-like
systems, normally B<su>, B<sudo> or B<gksu>, but depending on what you're
trying to do you might want to use B<fakeroot> or even B<sudo checkinstall>).
If this option is not given, aimake will not be able to install into a
location that isn't writable by normal users.  (You should not run aimake
directly as root; doing that means that the files in the build directory are
written as root, which normally causes problems.)

=item B<--gen-installer=>I<format>

The "traditional" method of installing a program for an entire system
is to use the B<-i> and B<-S> options to get aimake to do the installation
itself.  However, this has a few drawbacks: it doesn't integrate with your
computer's package management framework, there's no easy/obvious way to
uninstall, and you can't easily transfer the binaries to another system.

An alternative method is to generate an installer package, which can then be
installed on your computer, or (if the architectures and operating systems are
sufficiently similar) on someone else's computer.  That's performed using the
B<--gen-installer> option.  This option will set most other options
accordingly for the platform, and so the other options typically won't be
needed.  One that might be is B<--with>/B<--without>; if you disable a
feature, it won't be built and the installer won't install it, but if you
enable a feature, some installers will still be able to give the option to not
install the feature (even though it has been built).

Generating an installer needs more dependencies than merely building.  Here
are the various installer formats, and the dependencies they need:

=over 4

=item msi

Generates a Windows Installer package, for use on Microsoft Windows.  (This
should theoretically work on Windows 2000 SP3 and up, but full functionality
will not be available in versions before Vista, and this has only been tested
on Windows 8.1.)  This requires you to install L<WiX|http://wixtoolset.org/>,
an installer generator toolkit for Windows (and to place its binaries on your
PATH).

This option is implemented via setting B<-i>, B<--directory-layout>,
B<--destdir>, and B<--filelist>, then feeding the resulting file list to WiX
(together with appropriate command-line options).

The architecture of the generated package will match that of the system you're
building on: 64-bit if you build on a 64-bit system, 32-bit if you build on a
32-bit system.  (Perhaps some day, there'll be an option to cross-compile.)

It is highly unlikely that this option will work unless you're running on a
Windows system yourself.

=back

=item B<--var> I<key>=I<value>

The B<--var> option makes it possible to easily override some commonly
overriden options.  If this option is not given, the default is taken from the
environment variable of the same name, (failing that) defaults specified by
the project you are compiling, and (failing that) a default value provided by
aimake:

=over 4

=item CC

The C compiler toolchain to use (normally C<gcc> or C<clang>).  This must be
the name of a command that exists on your system, and compiles C with the
B<-c> option, preprocesses it with the B<-E> option, etc..  The default is
F<gcc>.

=item CXX

Like B<CC>, but for C++.  The default is F<g++>.

=item CPP

Overrides the C and C++ preprocessor to use.  The default is whatever program
is indicated by B<CC>, with the B<-E> option.

=item CFLAGS

Command-line arguments to use when building C programs.  The default is B<-g
-O2 -Wall>.  (aimake will also add a few extra options of its own, depending
on your platform, in order to ensure that the build works correctly.)

=item CXXFLAGS

Command-line arguments to use when building C++ programs.  The default is B<-g
-O2 -Wall>.

=item CPPFLAGS

Command-line arguments to use when preprocessing C or C++.  The default is to
give no options besides those required for aimake to function correctly.

=item LFLAGS

Command-line arguments to use when linking.  The default is to use no special
options.  (Note that you don't need to, and shouldn't, include the B<-l>
options that specify dependencies on libraries; aimake should figure those out
by itself.)

=item YFLAGS

Command-line arguments to pass to C<yacc>.  The default is to pass no options
beyond the C<--defines=> that aimake always provides because it needs special
handling (to place the files in the right place).

=item LEXFLAGS

Command-line arguments to pass to C<lex>.  The default is an empty set of
options.

=back

Note that this option is I<not> "sticky"; the value has to be given anew with
every compilation, or it will revert to its default.  (In particular, it's not
useful to give it alongside B<--config-only>.)

Leading and trailing spaces in the option to C<--var> (or an environment
variable) will be removed, and consecutive spaces will be collapsed to one
space, because such extra whitespace is not typically intended to add the null
string as an option.  aimake currently does not perform any other sort of
shell unescaping on the values of these variables.

=item B<-W> I<regexp>, B<--show-warnings>=I<regexp>

Instead of compiling, output all error and warning messages that were obtained
during the last compile, for files matching the given regexp.  (Don't include
the // around the regexp.)

This option is currently unimplemented.

=item B<-B> I<object>, B<--rebuild=>I<object>

Attempt to regenerate the given I<object> and rebuild everything that directly
depends on it, even if aimake has no reason to think that anything would be
different this time.  (This will typically also cause things that indirectly
depend on the given I<object> to be rebuilt.)  This option can be given
multiple times.

=item B<--directory-layout>=I<layout>

Change how the specific install directories are chosen.  The possible values
with the default configuration are:

=over 4

=item fhs

Install into the appropriate system directories that are intended to be
managed by the package manager on a UNIX/Linux system; the install directory
should be F</usr> or F</>.  This is automatically chosen as the layout when
installing into F</usr> or F</>.  This option would mostly be used by package
managers; B<--destdir> would also be used for package managers that operated
using binary packages (as oppose to directly from source).  ("FHS" stands for
"File Hierarchy Standard", the standard that specifies which files should be
placed in which directories on a UNIX or Linux system.)

=item fhs_unmanaged

Install into the appropriate system directories on a UNIX/Linux system,
avoiding directories that are normally maintained by package managers.  This
is automatically chosen as the layout when installing into F</usr/local>, the
only reasonable choice for directory, and so there should rarely be a need to
specify it explicitly.  (Most build systems have F</usr/local> as the default
install directory on UNIX/Linux; however, aimake will not install into system
directories unless the user explicitly requests it to.)

=item fhs_package

Install into system directories specific to the package being installed; every
file will be placed into the install directory (by default,
F</opt/packagename>), into F</etc/opt/packagename>, or into
F</var/opt/packagename>.  This install layout is often used to make it easy to
install and uninstall packages by hand.

=item single_user

Place all the installed files in appropriate subdirectories of the given
directory.  This works on any operating system but Windows, and is the default
when the install directory given is unrecognised, or recognised as a user's
home or documents directory.  (Note that this sort of install makes the
program available only to one user, rather than system-wide.)

=item single_user_windows

This is basically the same as single_user, except that it will place libraries
into the same directories as executables, which is required for Windows to be
able to find them.

=item windows

Place all the installed files under CSIDL_PROGRAM_FILES (typically
F<C:\Program Files\packagename>, for read-only files) or CSIDL_COMMON_APPDATA
(for read-write files) as appropriate, as is standard for system-wide installs
on Windows.  This option does not work on other operating sysems, which lack
the appropriate system calls for locating these known folders.

=item prefix

Attempt to emulate the directory layout behaviour of autoconf and similar
build systems.

=item single_directory

Place everything into the same directory, no subdirectories involved (unless
the configuration for the specific project requests that empty subdirectories
are created).  This is also special-cased to cause the program being installed
to look for its data in the current directory, rather than memorizing the path
it was installed to, even if it instructs aimake to tell it the install path.

=back

=item B<--override-directory> I<key>=F<location>

Change the directory for a specific value of the C<install_dir> option of an
install action.  For instance, C<--override-directory bindir=/bin> would
install binaries into F</bin> even if the default was, say, F</usr/bin> (which
is the default with C<-i /usr>).  See the documentation for C<install_dir> for
a full list of directories you can override.

On Windows, if the overriden directory is inside a known folder such as
Program Files, then it will be interpreted relative to that known folder
(i.e. if the known folder moves, the overriden directory will move to match).

=item B<--destdir=>F<directory>

When installing, treat the given directory as the root directory, rather than
using the actual root directory.  (For instance, giving B<-i> F</usr>
B<--destdir> F</home/user> would install into F</home/user/usr>, but the
installed program would look for paths as if it had been installed into
F</usr>.)  This is intended for use in packaging programs, and when installing
into a chroot from outside the chroot.  This option may only be given if the
install directory is outside the source directory and outside the build
directory (otherwise, it's not quite clear what it would mean).

=item B<--natural-permissions>

Do not attempt to change or set the permissions of any file.  By default,
aimake will try to change permissions if installing with administrator
rights.

=item B<--filelist=>I<format>

This option generates a list of files being installed in the specified format,
designed for use as input to an installer program.  If B<--destdir> is set,
the file list will be placed in the root of that directory.  Otherwise, it
will be placed in the root of the build directory.

=over 4

=item basic

Generates a list of filenames and directory names of the installed files and
directories.  This is as seen by the installed program (i.e. the B<--destdir>
will be omitted).  The filename will be F<filelist.txt>.

=item listing

Like C<basic>, but precedes each filename with its permissions, in a form
similar to that used by F<ls -l> on a UNIX system.

=item wix

Generates suitable input for WiX, an installer generator for Windows.  The
list will be placed in the directory given as an argument to B<--destdir>,
with basename equal to the C<packagename> option and extension F<.wxs>.
aimake will try to map its own concepts onto WiX concepts as far as possible,
e.g. aimake features will be controllable from the WiX UI, and have the same
default state (although obviously, features will not be available in WiX
unless they were turned on explicitly or implicitly in aimake, because they
won't have been built).

=back

=item B<--with=>I<feature>

=item B<--without=>I<feature>

=item B<--with-default=>I<feature>

Some programs installed by aimake may have multiple configurations (e.g. they
may be able to build both a command-line program and a GUI program); this
option lets you select which features you want (B<--with>) and/or don't want
(B<--without>).  These options are "sticky"; they are saved in
F<aimake.objects>, and so persist into future runs of aimake in the same
directory.  If you want to remove the persistence of such an option, causing
it to fall back to and respect changes to its default value, use
B<--with-default>.

The list of features that are supported by this option varies depending on
which program you are installing.  You can use B<--with=?> for a list (you
might need to escape the C<?> to hide it from your shell).

=item B<--documentation>

Show the full documentation for aimake.

=item B<--license>

Show the license/copyright information for aimake.

=item B<--absent-terminal>

Don't assume that whatever is connected to stdout supports any control codes
but newline (not even carriage return).  (This is mostly only useful if stdout
is not a terminal).

=item B<--nonempty-directory>

aimake normally refuses to build into a directory that has not previously been
used for an aimake build and that contains files, to prevent catastrophic
errors like overwriting your source directory with your build directory.
Sometimes, you want to do something like redirecting the output from aimake,
or using debug or profiling tools that produce output before aimake starts
running; in these cases, you can specify C<--nonempty-directory> to suppress
the sanity check.  Before using this option, make absolutely sure you are
running from the correct directory.

This option can also be used to permit installing to the source or build
directory, a combination that is typically disallowed because it makes no
sense and can lead to accidentally overwriting the source.

=item B<--no-sanity-checks>

Disables checks on permissions that are normally used to prevent yourself
accidentally creating a file that can't be deleted.  The most common reason to
use this is if you're building as root because you're using a system or jail
that has no regular users.

=item B<--install-only>

Don't run any rules but install rules, even if they're marked using
C<sys:always_rebuild>.  This is used by aimake internally when it elevates
permissions.  Note that if the build is not fully up to date, this may lead to
only a partial install.

Pretty much the only reason to use this manually is immediately after running
aimake with no B<-i> option, perhaps with elevated permissions, in cases where
you have a reason to separate the build and install steps.

=item B<--dump-status>

=item B<--dump-status=subset>

Instead of compiling, dump the internal statefile to stdout in a
human-readable format.  This is mostly only useful for debugging aimake.

It is possible to specify a subset of the statefile to dump as a
comma-separated sequence of keys (e.g. 'xuse_by_object,config_option:libdir').
On large projects, this is considerably faster than dumping the entire
statefile if you are only interested in a small portion of it.

=item B<--profile>

After building, output statistics on how much time was spent on each rule.
Does not work in combination with B<-S> (because elevating permissions
requires exiting and restarting the aimake process, and the profiling data is
lost upon exit).

=item B<--config-only>

Causes aimake to do nothing but record persistent options in the statefile. This
lets you incorporate aimake into build systems that expect a "configure, make,
sudo make install" workflow, e.g.:

    ../aimake --config-only -i /usr/local
    ../aimake
    sudo ../aimake --install-only -i

Note that the use of B<--install-only> allows aimake to be run
successfully as root; normally it refuses to be run with root permissions.

=item B<--local-config>=F<file>

In addition to the built-in configuration (unless C<--ignore-builtin-config> is
used), C<aimake.rules>, and C<aimake.local>, also read configuration from the
given file.  This option can be given any number of times.

=item B<--ignore-builtin-config>

Ignore all the built-in rules and options, reading configuration only from the
project-specific configuration file and B<--local-config> options.  aimake
has only minimal functionality with no rules (for instance, it will not even
check for changes to files in the source directory), and as such, this is
mostly only useful for testing aimake, or if you want to use aimake's engine
for something radically different from compiling C and have a complex
configuration file handy for that alternative use.  (The built-in directory
layouts are not ignored, but they will not be used for anything if
directory_layout is set to something other than a built-in directory layout.)

=item B<--specific-exit-status>

Normally, if something goes wrong compiling your code, aimake exits with exit
code 1.  aimake checks for certain specific common mistakes (such as forgetting
to anchor a regular expression in a dependency rule, or using the wrong
inclusion syntax); with this option, each of those mistakes will produce a
specific exit status (not 0 or 1).  The main purpose of this is for use in
aimake's testsuite, to test that those errors are being detected correctly.

=item B<--version>

Show aimake's version number (and a summary of the license).

=item B<--help>

Show a short usage message for aimake (that omits most of the options).

=back

=head1 WHY AIMAKE?

Build systems like B<make> work via an explicitly given directed graph of
dependencies.  The user specifies which files they want to rebuild (although
most Makefiles specify a default, this still needs to be given explicitly),
then B<make> recurses depth-first through the dependencies, rebuilding each
file that is older than any of its dependencies.

There are several problems with this approach.  The main problem is that it
costs a lot of programmer time; whenever any changes are made to the
dependency graph (most commonly due to adding a new source file or new
target), the programmer must alter the Makefile to specify the new
relationships between files.  This problem was enough to motivate the creation
of aimake by itself.  Dependency tracking is something that can be done by a
computer almost as easily (and much more quickly) than a human can, given the
existence of dependency-determining programs such as B<cpp -M> (for C header
files) or B<nm> (for object files and libraries).

There are some other, more minor, problems:

=over 4

=item *

Makefiles cannot handle dependencies on anything other than files (which
means, for instance, that you cannot write a Makefile that recompiles only the
affected files when a Makefile rule is changed, because a Makefile rule is not
a file, and splitting all the rules into separate files would be ridiculous).
Instead of using files as the basic unit of dependencies, aimake uses the more
general concept of an "object", which could be a file, but which could also be
something like a rule or option in a configuration file.  As such, changing
part of your project's configuration will only recompile the parts of your
project that were actually affected by that part of the configuration.

=item *

Makefiles are inherently somewhat platform-specific.  One reason is that
Makefile rules are written as lists of shell commands, and not all shells
behave in the same way.  (For instance, filename formats vary between
operating systems; so does the way filenames containing spaces are escaped.)
aimake works around this via mandating a standard filename format in its
configuration files (that it translates to an appropriate format for the
operating system), and emulating many commands itself (although it necessarily
has to use the C toolchain from the system; an entire C compiler and linker
would be outside the scope of a single Perl script a few hundred kilobytes
long).

=item *

B<make> itself might not always exist, or might use a nonstandard syntax on
some systems, making it hard to write a truly portable Makefile (especially if
you want to do things like out-of-tree build, which is the only sort of build
aimake supports; in-tree builds are hard to debug and hard to clean up, and
also prevent you performing multiple builds from the same source but with
different options).  aimake was intentionally written so that it could be a
single file that could be shipped with a distribution and run on all commonly
used operating systems.  This meant that it had to be written in a scripting
language (otherwise it would need to itself be compiled, thus require a build
system, leading to a chicken-and-egg problem), and ideally one that came
pre-installed on as many systems as possible.  There were only really two
languages that fit these criteria: Perl, and Python.  Perl was chosen mostly
because I was more familiar with it, but it also has the advantage that the
most commonly used Perl distribution on Windows (Strawberry Perl) ships with a
working C toolchain that works with aimake, meaning that only one extra
program needs to be installed to use aimake on Windows.

=item *

B<make> gets very confused when a file's timestamps are changed in a way it
doesn't expect.  (This happens most commonly when the computer doing the build
is a different computer from the computer where the files to build are stored,
and the clocks on the computers are not perfectly in sync.)  Likewise, it
rebuilds a file if any of its dependencies changed modification time, even if
the file itself did not change.  aimake works around these problems via using
the hash of a file in addition to its modification timestamp; if the timestamp
changes at all (forwards or backwards), or in cases where the file might
plausibly have changed multiple times within the resolution of its timestamp,
the file's hash is recomputed to see if its contents also changed.

=item *

Upon recompiling a large project, if there's an error, B<make> has two modes
of operation: stopping after the error (so that only errors from one file are
visible), or continuing anyway (meaning that although all the errors are
visible, all the files have to be recompiled on the next run even if only
errors in one file are fixed and nothing has changed in the others).
B<make>'s behaviour on warnings is even worse: it will display them once, but
on subsequent compiles, the warnings will no longer be visible because the
compiler will not be re-run, and the warnings were not saved anywhere.  aimake
remembers warning and error messages, meaning that warnings will not be lost
upon recompilation, and programs won't run unless their inputs have changed,
even if they errored out or produced no output.

=item *

Many programs need to be able to inspect information given to the build system
(for instance, to learn which directory their data files will eventually be
installed in, so that they can locate them at runtime).  This is quite
difficult to set up in many build systems (and B<make> has no native concept
of an install path, meaning that some external tool is needed to set a prefix
or the like).  In aimake, doing this (for C, at least) is as simple as writing
a function call C<aimake_get_option("installdir")>.  Likewise, aimake will
define a preprocessor symbol like C<AIMAKE_BUILDOS_linux>, so that you always
know which platform you're running on.

=item *

Errors in writing a Makefile can be hard to debug or even notice; a missing
dependency, for instance, may only cause a build failure under very specific
conditions.  Although aimake cannot entirely eliminate human error, it can
detect some common mistakes (e.g. it will complain if a command has an output
that's on the filesystem but outside the build directory), and the greatly
reduced amount of configuration also means that there's less of an opportunity
to make mistakes.  I initially wrote the first version of aimake because cmake
was unexpectedly rebuilding the entire project I was working on from scratch
every time I made even a small change; it eventually turned out that I'd
accidentally introduced a dependency loop in the project, with a program that
generated files being built from the files it generated.  aimake can warn
about this sort of problem if it's introduced into a project later than the
initial build.  (It's impossible in general to warn about it on the first
build because none of the files that depend on each other can be generated in
the first place, making it impossible to determine what files they'd
generate.)

=item *

Installing a program inherently requires doing system-specific things.  Most
build systems work at the level of commands to run; this normally works for
the build, but at install time, you need a separate set of commands for every
operating system on which you wish to run.  aimake's install system is capable
of abstracting away these differences, to a large extent; for instance,
associating an icon with an executable is done in a radically different manner
on windows and on Linux, but aimake can paper over the differences.

=back

Many other build tools are available that try to fix one or more of these
problems, but as far as I know, aimake is the only program which tries to fix
them all at once.

=head1 ADAPTING A SOURCE TREE FOR USE WITH AIMAKE

aimake is designed to be as easy as possible to use with new projects, and as
such it often works with unmodified source and no project-specific
configuration file.  However, there are some steps you can take to get the
best possible result.

=head2 SOURCE FILES

First, make sure that the directory layout of your source tree reflects the
dependencies between files; this helps to resolve ambiguities.  It mostly
doesn't matter if all your symbols have different names, but if you declare
the same function or variable in multiple files, aimake will need to know
which to link against.  It will favour linking against files that it has to
link to anyway, but when all else fails, it will fall back to linking to files
in the same directory (and with as many matching characters as possible at the
start of the filename, as a second tiebreak).  Also make sure that files have
appropriate extensions (F<.c> for C files, F<.cxx> for C++ files, F<.h> for
headers, etc.).

Next, you can use some aimake-specific macros in your C and C++ source and
header files.  One reason to do this would be if you have code specific to one
operating system; you can use C<AIMAKE_BUILDOS_> macros to conditionalize your
code to one operating system, for instance C<AIMAKE_BUILDOS_linux>,
C<AIMAKE_BUILDOS_MSWin32>, or C<AIMAKE_BUILDOS_darwin> (typically indicating
Mac OS X).  (The possibilities for the build OS are generally taken from
Perl's C<$^O> operating system identification variable, but C<msys> is folded
into C<MSWin32> in order to correctly indicate the operating system on which
the resulting programs will run.)  Another is to make your code depend on
aimake configuration options; aimake will provide a function
C<aimake_get_option> that lets you get the value of an option at runtime
(allowing for OS conventions, such as roaming profiles on Windows, which may
change filesystem location while remaining the same directory).

=head2 SHARED LIBRARIES

Although aimake will identify which executables it should produce as output
(via looking for functions called C<main>), it will not produce shared
libraries without an indication of which symbols form the API of the shared
library.  In order to create shared libraries correctly on all operating
systems, aimake will need to know which symbols are imported from shared
libraries (that you create; the system header files will contain this
information for system libraries), and which symbols are exported from shared
libraries, via wrapping their names in macros, e.g.:

    int AIMAKE_EXPORT(library_function)(void); /* exported function */
    int AIMAKE_IMPORT(library_function)(void); /* imported function */

The names only need to be wrapped this way in the declaration, not the
definition (which can be left unchanged).  C<AIMAKE_IMPORT> and
C<AIMAKE_EXPORT> only work correctly when the type of a variable, or return
type of a function, is a single identifier (not some complex chain of arrays
and pointers, etc.), so for complicated return types you will need to use a
typedef:

    char *function_returning_a_string(void) /* not imported or exported */

    typedef char *char_p;
    char_p AIMAKE_EXPORT(function_returning_a_string)(void) /* exported */

(The C<AIMAKE_IMPORT>/C<AIMAKE_EXPORT> API is potentially subject to change, in
case I find a notation that avoids this problem.)

In addition to C<AIMAKE_IMPORT> and C<AIMAKE_EXPORT>, there are also
C<AIMAKE_REVERSE_IMPORT> and C<AIMAKE_REVERSE_EXPORT>, which mark symbols that
exist in the file using the library, and are used by the library (rather than
the other way round, a much more common scenario).  Note that some platforms
may have restrictions on the dependency graphs of libraries; the currently
known restrictions are as follows:

=over 4

=item *

Linux is happy to allow arbitrary libraries to import symbols from arbitrary
other source files and libraries (although aimake still requires reverse
imports to be correctly marked so that it can ensure that each file has the
correct dependencies).

=item *

Windows will allow a reverse import from a library to another library.
However, the library doing the reverse importing (i.e. the library being used)
needs to know the name of the library doing the exporting (the library using
it), which means in practice that a library doing reverse importing can only
be used by one, specific other library.  (This restriction is not as crippling
as it sounds; one of the main reasons to do reverse imports is to construct
plugins designed to be dynamically loaded, and you can create a stub library
to load the plugins with.)

=back

If aimake sees any symbols tagged as C<AIMAKE_EXPORT>, it will place them in a
shared library (and, if appropriate, link executables it creates against that
shared library).  The name of the library will be based on the common prefix
of the source files that export symbols in the library (so, e.g., if they have
wildly varying filenames but are all in the same directory, it will be named
after the directory).  As an exception, directories called F<src> are ignored
for naming purposes, because that name is very commonly used when source files
and include files are separated into different directories.

Shared libraries often have an OS-specific versioning system.  When exporting
symbols, you can specify a version number for the shared library they create,
as follows:

    AIMAKE_ABI_VERSION(1.2.3)

The first component of the version number should be increased whenever a
change is made to the library's ABI or API that would invalidate existing
programs that used that library.  The other components of the version number
are arbitrary (and need not exist).

Finally, you can request that a file not be compiled in certain configurations
via making it conditionally error out:

    #ifdef AIMAKE_BUILDOS_MSWin32
    # error !AIMAKE_FAIL_SILENTLY! This file should not be built on Windows.
    #endif

The C<#error !AIMAKE_FAIL_SILENTLY!> will cause the compilation to error out
silently, without the user being informed of an error in the file.  (Note that
this can happen while aimake is locating header files necessary to be able to
use the file; as such, you should ensure that the error happens based only on
the individual file being compiled, and does not depend on anything that might
be included from a header file.)

=head2 DOCUMENTATION

Different platforms have different conventions for documentation; on Linux,
for instance, you would want your programs to be added to the manual called by
F<man>, and on Windows, it's more common to have separate HTML files.
aimake's documentation system is inspired by Linux's, but uses a friendlier
source format (Plain Old Documentation) rather than forcing you to write plain
*roff, and will convert the manual pages to an appropriate format on systems
which do not have manual page readers installed by default.  You can just save
the F<.pod> file anywhere in your source tree, and aimake will handle it
appropriately (in terms of install location, etc.).

See L<perlpod> for information about the Plain Old Documentation format.  For
use in aimake, you need to add two extra lines to your POD file (failing to
add these is an error):

=over 4

=item =for aimake manualsection I<section>

Specifies the purpose of this manual page.  The sections are as follows:

=over 4

=item 1

Commands and executables designed to be run by normal users.  You would use
this in almost every aimake project, to document the executables you install
(although some projects might use sections 6 or 8 instead).

=item 2

System calls (to an operating system kernel).  You will probably never need to
use this, because aimake is an inappropriate tool for adding new system calls
to an operating system.  But it's included for completeness.

=item 3

Library functions.  If you install any libraries, you can use this section to
document your libraries' APIs.  Note that it is traditional to append some
letters to the end of the 3 for languages other than C; for example, Perl
modules tend to be in section C<3pm>, and TCL functions in C<3tcl>.  Usual
practice is to have one manual page for each group of closely related
functions; in languages with packages or namespaces, documenting one package
or namespace per page would make sense, but you will need to come up with your
own division for less disciplined languages like C.

=item 4

Device drivers and device-like kernel interfaces.  On Linux, the manual page
is traditionally named after the file used to communicate with the driver;
however, not all operating systems work like this.  If you use this section,
you're probably doing something highly system-specific anyway, so you can pick
appropriate conventions depending on your operating system.

=item 5

File formats.  If your program has a custom format for its configuration or
its source or output files, this is where you document it.

=item 6

Games, and similar frivolous programs.  This works the same way as section 1.

=item 7

Miscellaneous information.  In practice, this is mostly used to document
standards, or to give overviews of wide subject areas.

=item 8

System administration programs.  This also works the same way as section 1.
In general, a manual page goes in section 8 if it describes a program that
would be mostly or only useful to administrators.

=back

=item =for aimake manualname I<name>

Specifies the name of the manual page.  In sections 1, 6, and 8, this is the
name of the program that the manual page is associated with.  In other
sections, choose a suitable name that describes the situation.  Except when
other considerations exist (e.g. when documenting a function containing
uppercase letters in a case-sensitive language), favour short names (one or
two words at most), lowercase letters, and (if you have to use multiple words)
separating words with underscores.

=back

A special case of documentation is the license agreement.  This can be marked
using C<=for aimake eula> (and should not have the C<manualsection> and
C<manualname> lines); there should only be one.  Not all installers will care
about this; currently, it is only used on Windows when creating a WiX
installer, which will show it to the user before installation (requiring the
user to accept it), and also install it as "license.rtf" in C<docdir>.

=head2 BASIC CONFIGURATION

In addition to changing the source and headers that make up your project, it
is also possible to add a project-specific configuration file, that contains
configuration options or rules overrides.  This should be a file named
F<aimake.rules> in the source directory.  (A second file, named
F<aimake.local>, can also be used; the idea is that F<aimake.rules> can be
kept under version control and provided by the project authors, with
F<aimake.local> used for local changes.  You can also use C<--local-config> to
add further configuration files.)  Here's a sample configuration:

    {
        options => {
            packagename => 'example',
            packageversion => '1.0.0',
            CFLAGS => '-Wall -Wextra -g -O2',
            AM_CFLAGS => '-DBUILT_WITH_AIMAKE',
        },
        libraries => {
            'z' => 'compress',
        },
        features => {
            gui => {
                description => 'Build a graphical user interface',
                object => qr/^path:gui\/.*/,
                default => 1,
            },
        },
    }

The format of the configuration file is explained in much more detail later
(see L<the section on configuration|/"CONFIGURATION">), in case you need to do
something complex or custom.  However, the most common tasks will be explained
here:

=head3 Setting package-wide options

There are some options that aimake is unable to automatically infer: the most
important are the C<packagename> and C<packageversion> options, that tell
aimake what name and version number that your project has.  (Automated
installation systems will need this information in order to be able to install
your project correctly.)  These are set using the C<options> dictionary of the
configuration file, using the syntax shown above.  Note that because the
C<packagename> may be used for filenames, it has a very limited character set;
you can use a separate C<packagename_text> option if you want to use uppercase
letters, punctuation, or the like.

For more information on the package-wide options you can set, see
L</"THE options DICTIONARY">.

=head3 Setting default compiler flags

The compiler flags (such as C<CFLAGS>, flags to pass to the C compiler) can be
set by the user using environment variables or the C<--var> option (see the
documentation for that option for the flags that exist).  The defaults for
these values can be set in the C<options> dictionary, just as with
package-wide options.

In addition to the regular C<CFLAGS> and friends, there are also versions with
an C<AM_> prefix (C<AM_CFLAGS>, etc.).  These will be combined with a possible
user setting for C<CFLAGS>.  Thus, flags like C<-O2> that should be under user
control should be placed in the C<CFLAGS>; additional flags required for the
correct functionality of your package should typically be in C<AM_CFLAGS>.

=head3 Linking in additional libraries

The C<libraries> dictionary allows you to link in additional libraries to your
project.  For each library, you specify the portion of the name of the library
that the linker uses to find it (e.g. for the compression library "zlib", you
specify C<z>, because you link in the library using C<-lz>), and you specify
one symbol within that library (typically a function name, although you could
also use an exported variable).  In this case, we used C<compress>; it's best
to specify either a function that's part of the core functionality of the
library and unlikely to change, or an initialization function that's required
to use the library.  (The specified symbol is used by aimake in order to
ensure that the library is linked correctly.)

aimake will not report an error upon failure to find a library, unless it
turns out that the library is actually required by the project.  Thus, it's
safe to specify a library that is only used in certain configurations, on
certain operating systems, or the like; there won't be an error about a
failure to find it in configurations where it's unused.

=head3 Defining a feature

Many projects will want to provide multiple configurations, in which the user
can choose what subset of the project to build.  In aimake, this is
accomplished via the C<features> dictionary.  The simplest version of this
specifies a set of source files that will not be built if the feature is
turned off, as is shown in the example configuration file.  (You specify the
files using a regular expression that matches filenames in aimake syntax, so
that the same set of files is matched on every platform.)

For more information about defining features, see
L</"THE features DICTIONARY">.

=head1 INTERNALS

=head2 THEORY

aimake operates almost entirely using a set of rules (which are described in
its configuration file; a default configuration file exists at the end of the
F<aimake> script, and can be augmented for a specific project via a file
F<aimake.rules>, if that project needs to do something unusual like generating
some of its source files).  Almost the entire build process is written in
terms of rules; for instance, there is a rule to determine which files need
compiling.  (The main activities that occur without being driven by rules is
to change the "hash" of C<sys:always_rebuild>, to parse the configuration file
into a set of objects, to verify that the build directory has not been
tampered with (or recover if it has), and to handle side-effects of the
install process; that's about it.)

Each rule has three parts.  First are the conditions under which the rule
runs; in order for a rule to run, all its dependencies must be in place, and
the rule will be rerun if any of its dependencies change.  A rule can have a
hardcoded dependency list (in which case it only runs once in each
compilation); alternatively, it can be parameterized by the object it applies
to (its C<object> field), in which case it runs once for each appropriate
object, and its dependencies are also parameterize by the object.  A rule that
is parameterized by an object uses a regular expression to specify which
objects it applies to, and it will run once for each appropriate object; the
combination of the rule and object is known as a "pair" internally, and almost
all internal operations are based on pairs rather than rules (rules with
hardcoded dependencies and no objects are considered pairs of their own).  So
for instance, C<compile_c> is a built-in rule; C<compile_c path:hello.c> is a
pair, that refers to the operation of running a compiler on F<hello.c>, to
create a file such as F<hello.o> or F<hello.obj> depending on platform.  A
rule's dependencies are specified in its C<command> field.

The objects that make up a pair's dependencies can have dependencies of their
own: a I<use dependency> of an object is another object that will be included
in any dependency list that contains the original object.  A pair cannot run
unless its C<command>, its use dependencies, their use dependencies, and so on
recursively, are all in place already (i.e. they exist, and none of the
objects they were generated from have changed).  A pair's C<object> is also
usually a dependency of the pair; aimake will include it in the pair's command
by default, because it is usually appropriate, but this can be disabled
manually using the C<object_dependency> field of the rule (e.g. in cases where
the pair's operation depends only on the object's I<name>, and thus changes to
the object).  As an exception, if the pair's purpose is at least partially to
determine dependencies of its object, then clearly it cannot depend on its
object's dependencies (because it would lead to an infinite regress), so in
this case, the pair depends only on the existence of the object itself, not on
any of the object's dependencies.

The second part of the rule is the actual command that aimake runs in order to
run the pair.  This can be internal to aimake, part of the system's toolchain,
or even an executable that was generated as part of the build process.  This
is calculated from the pair's dependencies; any C<cmd:> or C<intcmd:> object
among the pair's recursively expanded use dependencies specifies the command
to run (or if none are available, any C<bpath:> object that refers to an
executable, and failing that, C<intcmd:nop>), and any C<optpath:> and
C<optstring:> objects specify the command line options to that command.  The
rule's C<command> thus specifies not only the pair's dependencies, but also
the command to run to execute the pair, together with arguments to it;
alternatively, the command or arguments can come from dependencies of objects
in the C<command>.  Thus, it is quite common for a file to depend on whatever
command-line option is needed to use that file in the commands that need to
use it; a library C<libm> could depend on C<optstring: -lm>, for instance
(although the details will vary by platform).  This approach is slightly
inflexible, in that it assumes that if a file is used as an argument to more
than one command, each such command will expect the same syntax for specifying
the file in question; although this is rarely an issue, the problem does come
up occasionally, and although a workaround exists (via manipulating
C<dependencies:> objects manually and using the C<avoid_rules> field of a
rule), it is complex and error-prone.  We intend to add a more direct way to
accomplish this in the future.

The remaining part of a rule specifies what the rule accomplishes when it
runs.  There are several possibilities, and a rule can accomplish many of them
simultaneously, or the same possibility applying to multiple different
objects:

=over 4

=item Producing files

A pair can produce one or more files on the filesystem (and the matching
object in aimake's internal state, which refers to that file).  Typically, the
file will have been generated by the command that was just run, but it is also
possible to "produce" a pre-existing file in order to make aimake aware of it
(in which case the C<information_only> field of the rule should be set, or
else aimake may well complain that your rule overwrote a file that it
shouldn't be overwriting).

A rule can specify the files that it is producing in three ways.  Often, the
command that was run will take a command-line argument that specifies where to
place its output; in this case, you can use C<output_from_optpath> to tell
aimake about this convention, and it will look in the same place for the
output.  Sometimes, the command that was run will print information about
where it placed its output on standard output (in which case C<output> can be
a regular expression to match it), or standard error (in which case, you do
the same and set C<also_match_stderr>); this technique is particularly useful
if you don't know what files will be output in advance.  Finally, you can just
hardcode a filename by using a constant value for C<output> (that's a
C<path:>, C<bpath:>, C<spath:>, or C<standardlib:> object).

Examples of built-in rules that produce files are C<compile_c> that produces
object files from C files, and C<generate_search_test_file> which generates a
specific file, C<bpath:aimake/aimake_1.c> (and does not have a specific input
object).

=item Providing objects

aimake objects are more general than just files on the filesystem; they can
also refer to abstract concepts such as "functions named C<yyinput>", "files
with basename F<project.h>", "options that are typically given to the C
compiler", or the like.  Pretty much the only difference between these and
files on the filesystem, from the point of view of aimake's internals, is that
they are defined entirely by their use dependencies, rather than having a file
on the filesystem to match.  When a pair provides an object, it specifies the
set of objects it's producing, and a set of use dependencies for them; both
the set of objects and the set of use dependencies are constructed out of
components, any of which can be hardcoded, or obtained from the output of the
command from a regex match; C<inner> defaults to the pair's C<object>.  The
produced objects are specified via C<output>, C<outputarg>, C<inner>
(C<output> is concatenated to C<outputarg>, and C<inner> is added on the end
if the object name is incomplete; likewise, C<outdepends> is concatenated to
C<dependsarg>, with C<inner> added on the end if the object name is
incomplete).

The normal purpose of this sort of rule output is to determine under what
circumstances a file can fulfil a dependency.  For instance, the built-in rule
C<o_file_provisions> runs B<nm> on an object file to obtain a list of the
symbols in it, and provides appropriate C<symbol:>, C<direct_symbol:>, and
C<symbol_in_object:> objects to represent the symbols in question.

=item Specifying dependencies

An object sometimes has use dependencies specified as it is created via the
use of C<outdepends>; this is useful when the same command that generates the
objects also outputs the dependencies.  Frequently, though, the command that
determine the dependencies of a file (e.g. B<nm> for an object file) will be
different from the command that produces that file (e.g. B<cc> for an object
file), and objects can meaningfully have use dependencies even if they weren't
even produced by aimake.  Thus, there needs to be an approach to determine use
dependencies of an object after it is created.

This can actually be accomplished without any extra types of rule behaviour:
for each rule that wants to specify dependencies for an object, and each rule
that can create that object, the first rule provides an object named
C<dependencies:>I<rulename>C<:>I<objectname>, and the second rule adds that
object as a use dependency of the original object while providing or producing
it (via C<outdepends>).  Then all that is necessary is to set the
C<object_dependency> field of the rule that specifies dependencies to
C<'none'>.  However, this process is complex, and most importantly, requires
all the rules that can provide an object to be modified every time a rule that
wants to specify dependencies of that object is added.

using the actual root directory.  (For instance, giving B<-i> F</usr>
As such, aimake provides sugar for this very common situation; using
C<depends> allows the rule to specify use dependencies of its object, using
the mechanism explained above.  This works identically to C<outdepends>,
building the dependencies piecewise out of C<depends>, C<dependsarg> (if
present), and C<inner> (if necessary).

An example of a built-in rule that adds dependencies to an object is
C<ch_file_dependencies>, which runs the preprocessor in order to determine the
dependencies of a C source file, and (among other things) parses the output in
order to determine which header files it attempted to include, adding C<file:>
dependencies as necessary.

=item Installing files

Installing cannot be carried out in exactly the same way as other aimake
operations, nor can it be carried out the same time, because it may need to
run in a separate aimake process (for permissions-related reasons).  Thus, a
rule that installs a file cannot do anything else.  Install rules have a
C<install_dir> field that specifies the directory in which their C<object>
should be installed; their C<command> should not have side effects (although
aimake cannot check this), and is typically omitted (although occasionally, a
program will do a conditional install via giving one or more objects that need
to have been built, along with C<intcmd:nop>).

=back

At the start of the build, aimake "changes" C<sys:always_rebuild>, and parses
the configuration file into C<config_option:> and C<config_rule:> objects.
(The rules are in the configuration file, so it needs to be parsed
separately.)  It statically considers all C<optstring:>, C<optpath:>,
C<intcmd:> and C<cmd:> objects to exist (as well as most C<sys:> objects).
Other objects are I<not> statically considered to exist; in particular,
C<path:> and C<spath:> objects need to be located via rule (there are built-in
rules for this), or aimake will consider them nonexistent despite actually
existing on the filesystem.  This means that aimake will notice changes,
additions, and deletions of files in the source tree (the files are "produced"
via the built-in rule C<find_source_files>; although this is run every time
you run aimake, this does not cause the entire project to be rebuilt because
most of the files will likely retain the same modification time or hash as
last time).

From then on, everything is done by rules.  Each pair is either I<changed>,
meaning that running it might potentially do something, or I<unchanged>,
meaning that nothing relevant has changed since last time it ran; initially,
all rules are unchanged, but many will be marked as changed at the start of
the run due to the "change" to C<sys:always_rebuild>.  (There's actually one
more state internally, for optimization purposes: I<blocked> pairs are changed
pairs that are missing one or more direct dependencies.  While a pair is
blocked, aimake doesn't bother calculating its indirect dependencies, like it
would with a non-blocked changed pair.)  Each object (including nonexistent
objects!) is either I<sure>, meaning that aimake knows the object does not
need to be rebuilt (either because it knows it's correct on disk / in memory,
or because it knows it doesn't exist), or I<unsure>, meaning that aimake does
not know whether the object needs rebuilding (or that it definitely does need
rebuilding).  Here's what the main loop looks like:

=over 4

=item *

Whenever an object's contents (i.e. hash or modification time) changes, then
all pairs with a dependency on that object become changed.  (Exception: if the
pair also has a dependency on a nonexistent, sure object, I<and> either has
never been run, or produced no output last time it ran; in this case, there
cannot be any reason to run it again until that nonexistent object starts
existing.  This optimization leads to the pair remaining unchanged if its full
use dependencies are known, or becoming blocked if the nonexistent object is a
direct dependency and thus there was no need to calculate the full use
dependencies.)

=item *

Whenever a pair becomes changed, all objects that it proviced last time it ran
become unsure.  (We can't know whether it will provice them the same way
again, or a different way, or even end up not provicing them at all after
running.)

=item *

For efficiency, a cache is maintained of each pair's full use dependencies
(i.e. all the use dependencies specified in the object being operated on, the
rule's command, any use dependencies of those, and so on).  (aimake version 2
was very slow; the lack of this cache was one of the reasons, although its
algorithm was inefficient in general and not amenable to one being added.)
Whenever a provided object is changed, any pair that has a use dependency on
that object has its cache recalculated.

=item *

If a pair is changed, and has no unsure objects in its full use dependencies,
their build dependencies, I<their> build dependencies, and so on, then the
pair can be run.  (As an exception, if an object in the pair's use
dependencies isn't unsure but also doesn't exist, then the pair "runs" but
produces no output, and any output it previously had is deleted.  This is what
allows aimake to recover from a source file being deleted, for instance;
previous versions had trouble with this case.  There's another minor exception
to do with C<searchfile:> objects, in case a generated source file wants to
search for the same header file that the source of the generator wanted to
search for; the situation is obviously benign, as it'll find it in the same
place, but would potentially cause a dependency loop without special casing.
The same special case applies in some other situations too; the general rule
is that if an object is provided by multiple rules with the same outdepends,
only one of them has to be sure.)  When the pair is run, it becomes unchanged,
and the hashes of anything it previously output, and anything it now outputs,
are updated.  Such objects also become sure (with a slight exception in the
dubious case where the same object is output by multiple pairs).  An object no
longer being produced by a pair counts as a hash change (the hash of a
nonexistent object is treated as different from the hash of an object that
exists).

Any warnings produced running the pair are recorded with the pair.  If the
pair produced an I<error>, then any objects it previously produced are marked
as unsure (and cannot be marked as sure again until the rule runs
successfully), holding them and all their descendants in limbo until the error
is fixed.  (If they are deleted from the filesystem in the process, which is
quite likely, their hash will also change.)  This means that if fixing the
error causes the objects to be recreated with the same hash, there will not be
a need to recreate their descendants in the future, avoiding the need for a
long recompile in the case of a widely depended-on file (like a generator for
a generated header file that is included almost everywhere) having an error.

=back

There's one other source of errors: dependency problems.  aimake's core
doesn't notice a problem if something can't be built due to a missing
dependency (it simply assumes it built correctly with no output), but the user
probably considers this situation a bug in their program that they would want
aimake to tell them about.  As such, an internal list is kept of pairs that
aren't producing any output; and that list is scanned for pairs that didn't
produce output due to missing expanded use dependencies that weren't in the
command, to let the user know what went wrong.

=head2 AIMAKE OBJECTS

aimake tracks a lot more types of objects than just files:

=over 4

=item C<path:>

One of the files in the source directory.  (aimake is designed for out-of-tree
builds, although it can build into a subdirectory of the source directory; it
simply treats any subdirectory that contains an aimake state file as not
existing.)  aimake scans these for changes.  This is a relative, not absolute,
path (so that it continues to work correctly if the source directory is
renamed), in aimake relative path format (that is, directories are separated
with slashes, and colons, slashes and backslashes in path components are
escaped with backslashes; note that aimake relative path format cannot
represent an absolute path, which saves having to worry about how the
filesystem is rooted).  Because they represent specific files, C<path:>
objects are produced, not provided.

=item C<bpath:>

One of the files in the build directory: things like object files.  Like with
C<path:>, this is a relative path in aimake relative path format.  C<bpath:>
objects are produced, not provided.

=item C<spath:>

One of the files that exists as part of the system's toolchain: compilers,
system libraries, system headers, and the like.  This is always an absolute
path, and is in aimake's absolute path format (which works like its relative
path format, except that it has an extra component at the start, which
represents the filesystem root to use in a system-dependent manner; this might
be the null string on systems whose filesystem only has one root).

C<spath:> objects can only be created via things external to aimake (such as
the system's package manager), but they can be produced via a no-op command,
to tell aimake to consider them to be relevant; they are considered
nonexistent until that happens.

=item C<searchpath:>

A set of directories that is looked in for include files, libraries, or the
like.  This looks something like C<searchpath:systeminclude>, and the actual
paths to search are stored as dependencies (the same way as an C<optionset:>
works).  Search paths are typically used to produce objects on the search
path.

=item C<searchfile:>

A filename that is being searched for (most likely, because there's an unmet
dependency on some unknown file with that name).  This looks something like
C<searchfile:stdio.h>.  Note that all objects providing a C<searchfile:> must
provide the same list of dependencies for it (the built-in rules create
searchfiles with the empty set of dependencies); aimake assumes requests to
search for files with a particular name to be interchangeable.

=item C<searchlib:>

A library that is being searched for (not including naming conventions of the
platform, e.g. 'libfoo.a' on Linux would become 'searchlib:foo:' and a
symbol), followed by a C<symbol:> object that exists within that library.
(The symbol has two purposes: ensuring that the correct library is found, and
persuading linkers to actually try to link the library while it's being
searched for.)  aimake assumes that these are interchangeable the same way
C<searchfile:>s are.

=item C<standardlib:>

A library that is linked by default.  This works the same way as C<spath:> in
terms of what file it refers to, but these libraries are omitted from linker
command lines, in the knowledge that the linker will link them in anyway.
(This is mostly just for neatness on Linux or Windows, but on some platforms,
such as recent versions of OS X, it's required for the compile to complete.)

=item C<extend:>

A filename that's produced from another filename.  This is formed out of an
extension and a file-like object, and is just an alias for something in the
C<bpath:>, not an object in its own right.  For instance,
C<extend:.s:path:src/foo.c> might be an alias for C<bpath:src/foo.s>.  (This
is mostly used to tell compilers and similar tools where to place their
output.)  As a special case, an extension of ".." causes the filename to be
deleted too, producing the directory of the object:
C<extend:..:path:src/foo.c> is C<path:src>.  This construction might produce
an C<spath:>, C<path:> or C<bpath:>.  As another special case, an extension of
"..." produces the filename by itself, removing the directories, and producing
an output in the root of the C<bpath:>.  Finally, an extension of "/" causes a
file (which should be in the C<path:>) to be placed in a directory with its
own name: C<extend:/:path:src/foo.c> is C<bpath:src/foo.c/foo.c>.  (aimake
uses this last case internally, to avoid filename clashes, and because many
system toolchains work at the directory level, not the file level.)

C<extend:> can also extract the inside object name from a C<symbolset:> or
C<dependencies:> object, e.g. C<extend:.o:dependencies:foo:path:foo.c> is
C<bpath:foo.o>.

=item C<file:>

A reference to a file with a particular name.  This is used to represent
dependencies produced via code like C<#include "foo.h">.  It is possible for
multiple rules to provide the same C<file:> object.  (The difference between
C<file:> and C<searchfile:> is that if an unknown file is included, that'll
I<produce> a C<searchfile:> object to let aimake know to search for it, and
I<depend on> a C<file:> object to let aimake know to use it once it's found.)

=item C<symbol:>

A reference to a symbol (as would be used by a linker); this is used the same
way as C<file:>, but for linking rather than compiling.

=item C<shared_symbol:>

A symbol that is exported by the file that provides it, and is intended to be
compiled as part of the API of a library.  aimake's standard rules will
attempt to create a C<symbolset:> containing each shared_symbol that is
defined.

C<shared_symbol:> objects have their dependencies built cumulatively; if
multiple pairs try to generate one, their C<outdepends> will be combined.

=item C<direct_symbol:>

A symbol that is exported from an object file, not a library.  This exists in
order to avoid an infinite regress in the shared libary code.  Anything that
produces a C<direct_symbol:> should produce the matching C<symbol:> too.

=item C<symbol_in_object:>

A reference to a symbol produced by a specific object.  This is used
internally to determine which C files contain a C<main> function.

=item C<symbolset:>

A set of exported symbols, ready to be made into a library.  Symbol sets are
defined with reference to a filename and version suffix, as in
C<symbolset:.1.2.3:bpath:libfoo>.  When aimake creates a symbol set, the
filename is based on the common prefix of the source files that define those
symbols, and the version number on C<AIMAKE_ABI_VERSION> macros in the source
files that define those symbols.  Symbol sets are provided objects; they don't
represent a file on disk (thus, the filename is a I<suggested> filename that
will most likely be used to represent the resulting library, most likely with
the extension changed to something platform-specific like F<.so> or F<.dll>.).
If a C<symbolset:> object is used in an C<optpath:> or C<extend:> object, it
will be treated as if it were just its filename portion; this does not happen
for other uses of C<symbolset:> objects.

The dependencies of a C<symbolset:> object are built cumulatively; if multiple
pairs try to provide the same C<symbolset:>, it will result in one
C<symbolset:> with the combined dependencies of all of them. This is how
multiple symbols are bundled into one library.

=item C<config_option:>

An option in the config file.  This is mostly used in dependencies, to specify
things like "this object file needs to be rebuilt if the CFLAGS change" (a
build dependency), or "_aimake_get_option.c has the install path substituted
into it at compile time" (a use dependency).  The object is named using the
option name after C<config_option:>, e.g.  C<config_option:CFLAGS>.  These
dependencies are added automatically when options are substituted into
commands.

=item C<config_rule:>

A rule in the config file.  Every rule implicitly includes itself as a use
dependency.  That way, if the config file is changed, files are recompiled
accordingly.  Each rule has its own name for this purpose.

=item C<hash_on_disk:>

Generated as a dummy output dependency of produced objects to record the hash
of the file on disk that they created; these objects are used to detect when a
file is modified on disk outside aimake.  These objects should not be used
except via aimake's engine internals (in particular, they should not appear in
any part of a configuration rule, because this will not give the desired
behaviour; these objects will be ignored as build or use dependencies, and
never exist as C<object>s of a rule).

=item C<sys:>

Things like dummy targets, file-like objects that aren't files, and so on.
The following C<sys:> objects exist:

=over 4

=item C<sys:always_rebuild>

An object that conceptually changes with each run of aimake.  This should only
be used for, e.g., "last build" reports in the About box of a program.
(B<aimake> also uses it internally to determine when to scan for new files in
the source tree, a task that should always be performed.)

=item C<sys:rebuild_late>

An object that conceptually depends on everything that doesn't depend on it.
This is typically used for wildcard-style build rules where you want to depend
on everything that obeys a particular pattern.  This is implemented via
marking it as unsure until no further compilation is possible, then marking it
as sure and continuing the compile.  If you also need the rule to re-run every
time (which is likely when doing wildcard-style dependencies), also add a
dependency on C<sys:always_rebuild>.

=item C<sys:installing>

An object that conceptually depends on everything that doesn't depend on it,
including C<sys:rebuild_late>.  This is used to ensure that installing is
performed last of all, and is implicitly added as a dependency of install
rules.  (It is probably a bad idea to add it manually.)

=item C<sys:clean>

An object that is always sure and never exists.  Any rule that depends on
C<sys:clean> can run "successfully", causing it to delete all its outputs.
It's rare to use C<sys:clean> in a configuration rule manually; rather, aimake
will add it to dependency lists automatically when it's required to clean up
after a rule is changed, or after a command starts producing a different set
of outputs, and thus although it has defined semantics, it's likely best to
treat it as internal use only.

=item C<sys:touch_only>

An object that conceptually represents a file that is deleted immediately
after being installed.  It can be installed in a directory to force the
directory to be created at install time.  Changing its permissions changes the
permissions of the directory.

=item C<sys:create_subdir>

An object that conceptually represents a subdirectory.  It can be installed in
a directory, with a specific name, to force a subdirectory with that name to
be created at install time (if it doesn't already exist).

=item C<sys:empty_file>

An object that conceptually represents a zero-length file.  Its only use is to
be installed, creating or truncating an install target.  (This could
theoretically be implemented in terms of C<intcmd:writefile>, but that would
be rather unintuitive and hard to read.)

=item C<sys:ensure_exists>

An object that conceptually represents the file that already exists at an
install target.  When installed, it will ensure that the install target exists
(by creating it as a zero-length file if necessary), but will not overwrite an
existing file at that location.

=back

=item C<cmd:>

Represents a command shipped with the system, like B<gcc>.  This is only
meaningful in the part of a configuration file that specifies what command to
run to accomplish something.  (C<bpath:>, C<tool:> and C<intcmd:> objects can
also be used in the same context.)  This is just a filename, no directories
are involved, and it omits any extension that might be customary for
executables on the platform (thus C<cmd:gcc> has the same meaning everywhere).

=item C<tool:>

A type of command shipped with the system, such as C<tool:c_compiler>.  These
are provided by C<cmd:> objects, and are typically listed in use dependencies
of files that need compilation.

=item C<intcmd:>

Represents a command that's emulated by aimake.  This gives system-independent
behaviour for some commonly used commands:

=over 4

=item C<intcmd:nop>

An internal command that does nothing and produces no output.  Typically used
in dependency rules that cause a particular object to unconditionally depend
on another object, with no complex computation of object names needed.

=item C<intcmd:cat>

An internal command that just outputs the file given as its argument. (The
file will be assumed to be encoded in UTF-8, regardless of the encoding of
the operating system.)

=item C<intcmd:echo>

An internal command that outputs its arguments, separated by spaces.  Any
C<optpath::>s in the arguments will be output in aimake format.

C<intcmd:echo> can also output the content of files, or extract parts of
object names, even if they aren't paths:

=over 4

=item C<optpath:-w:>

The whole object name (for file-like objects, equivalent to not specifying the
C<-w>, but it works on other types of object too);

=item C<optpath:-q:>

The file that a file-like object represents, in whatever path format is
standard for the operating system you are using, formatted as a C string
(i.e. surrounded with double quotes and with special characters escaped).

=item C<optpath:-t:>

The object type, without the colon (e.g. C<optpath>, C<intcmd>);

=item C<optpath:-a:>

The object argument (as would be generated by an C<outputarg> specifier in a
rule); this is the bit between the colons for a nested object, or the entire
object name apart from the type for a simple object name.

=item C<optpath:-i:>

The "inside" object (the part after the second colon for a nested object); do
not use this for non-nested objects.

=item C<optpath:-c:>

The contents of the file that an object represents.  (Remember to add a
dependency on the file!)

=back

=item C<intcmd:writefile>

An internal command that takes a filename (as an C<optpath::>, i.e. no prefix)
and a set of contents for that file (as any number of C<optstring:>s, or
C<optpath:>s with a prefix, which are interpreted as for C<intcmd:echo>.)  Any
underscores in the contents will be replaced with spaces, and any spaces with
newlines, and then the resulting string will be written to that file (which
should be in the C<bpath:>); underscores and backslashes can be escaped with
backslashes.  This is used to generate things like input files for compiler
tests.

=item C<intcmd:symlink>

An internal command that causes each of its output arguments
(C<optpath:-o:...>) to become an alias for its input argument
(C<optpath::...>).  This will be done via a symbolic link if possible, but on
some platforms it may need to copy the file; thus, there is no guarantee that
the two arguments will have the same meaning forever.  This will overwrite its
second argument if necessary.  (On POSIXy systems, this is similar to B<ln
-sf>, except that it handles relative paths more intuitively.)

=item C<intcmd:assert_equal>

An internal command that compares two arguments (optstrings or optpaths).  It
succeeds if they are equal, and fails otherwise, producing no output.  The
intended use of this command is in combination with fail_silently, to create
rules that work only in certain circumstances (e.g. on specific OSes).

=item C<intcmd:testcase>

An internal command used for testing aimake.  It prints its arguments to the
user and records them as warnings, and errors out if the first argument
contains "failed" anywhere.  There shouldn't be much of a need to use this in
anything other than a testsuite for aimake itself.

=item C<intcmd:testruncount>

An internal command used for testing aimake.  It writes the number of times
aimake has been run with the current F<aimake.objects> file to a file given as
an C<optpath:>.  (The main use of this in testing is to allow the construction
of a rule that has a side effect upon being run twice with nothing changing.)
This command is unlikely to be useful except in testing aimake.

=item C<intcmd:optionvalues>

An internal command that takes config options as its arguments
(e.g. C<optpath::config_option:packagename>), and outputs their values. An
C<optstring:> can be used to specify what format to output them in:

=over 4

=item C<optstring:--equals>

Values will be output in the form C<name=value> form.  Any values that are
aimake objects that represent files will be converted to pathnames as the
operating system understands them.  No quoting will be used.  This is the
default, if no optstring is given.

=item C<optstring:--struct>

Values will be output in the form C<{"name", "value", -1},>.  The names and
values will be quoted according to the rules of C strings.  Any values that
are aimake objects that represent files will be converted to pathnames as the
operating system understands them; however, on Windows, if the file is in a
known folder directory, the value will be the path relative to that directory,
and the -1 will be replaced by the name of a constant representing the name of
that directory (such as C<CSIDL_PERSONAL>).  This format was designed for the
implementation of C<aimake_get_option>, but can be used directly if necessary.

=item C<optstring:--optstring-escape>

This option can be given alongside one of the others, and causes the output to
be escaped suitably for C<intcmd:writefile> (i.e. replacing underscore with
backslash-underscore, space with underscore, newline with space).

=back

=item C<intcmd:podformat>

An internal command that formats documentation.  Its only argument is an
C<optpath:>, which represents a file in Plain Old Documentation format (see
L<perlpod> for details).  This file will be translated into an appropriate
format for your operating system: a F<man> page on UNIX-like systems, and HTML
on Windows.  The output filename will depend on details of the input, so it
will be output on standard output, so that you know where the output was
placed.

The input should contain two lines to indicate to aimake where to put the
file: "=for aimake manualsection I<section>" to specify which manual section
it goes into, and "=for aimake manualname I<name>" to specify what the manual
is talking about.  (As usual for POD, they should have a blank line before and
afterwards.)  Alternatively, "=for aimake eula" will
cause the file to be marked as a license agreement (you can only have one such
file), and with some install toolchains, shown to the user for acceptance
before installation will happen.

=item C<intcmd:filetest>

An internal command that takes an C<optstring:> and an C<optpath:>, and either
succeeds or errors out depending on information about the filename referred to
by the C<optpath:>.  The C<optstring:> can be:

=over 4

=item C<-e>

The filename exists and refers to something (which might be a file, directory,
special file, symlink, etc.; aimake won't check what sort of entity the
filename refers to).

=item C<-f>

The filename refers to an ordinary file.

=item C<-d>

The filename refers to a directory.

=item C<-l>

The filename refers to a symbolic link.

=item C<-x>

The filename refers to an executable.  (Depending on the operating system,
this might check whether the filename has permissions that allow the current
user to execute it, or it might check the filename for extensions like
F<.exe>.)

=item C<-z>

The filename refers to an empty file.

=item C<-s>

The filename refers to a nonempty file.

=item C<-T>

The filename refers to a text file.  (This cannot be checked 100% reliably.)

=item C<-B>

The filename refers to a binary file.  (This cannot be checked 100% reliably,
either.)

=back

=item C<intcmd:listtree>

An internal command that takes any number of directory names as its arguments,
and returns a list of all the files (but not directories) recursively inside
those directories, one per line.  (As such, it's similar to the POSIXy
B<find>.)  Any symbolic links found are returned, but not dereferenced or
followed.  Unlike calling commands external to aimake (whose output is
typically split on newlines before being fed to the regular expression
specified in the config file), an internal mechanism is used to remember where
the boundaries of each filename are, so this will work correctly even if, for
some reason, your filenames contain newlines, NULs, or other such bizarre
characters.

If given an optstring as well as an optpath, the optstring specifies the
maximum nesting depth to go down the tree; 0 will just list the directory
itself, 1 will also list its subdirectories, and so on.

If given an optpath that's a C<searchfile:> rather than a directory, the
output will be limited to files with that filename.

=item C<intcmd:xuse_statistics>

An internal command that outputs some information about the rule that caused
it to run (specifically, the expanded set of use dependencies of the rule's
commands, i.e. the build dependencies of its output).  Any number of
C<optstring:> arguments can be given; they should be of the following forms:

=over 4

=item -sI<regex>

Only objects matching the regex will be included in the output C<hash>.  Do
not include the slashes around the regex.

=item -rI<regex>

The command will fail unless at least one expanded use dependency matches the
regex.  (The intended purpose of this is to detect when a rule will have no
useful effect, e.g. the creation of a library with no object files, in
combination with C<fail_silently>.)  Do not include the slashes around the
regex.

=back

The output is a number of lines in key=value form, and may be expanded with
extra information in future. At present, the currently output keys are:

=over 4

=item hash

The MD5 hash (in hexadecimal) of the string constructed by sorting then
concatenating the names of all the objects (that match the regex given by the
C<-s> option, if present) in the expanded use dependencies, separated by
colons.  The main purpose of this is to be able to easily compare sets of
dependencies.

=item stem

The longest common prefix of the C<namehint:>s in the expanded use
dependencies of the rule; any final slash will be removed, and the resulting
object name will be on the C<bpath:>.  The intended purpose of this is to find
a sensible filename and location for objects that would not otherwise have an
obvious filename.

=item version

The numerically largest observed version number among the C<namehint:>s in the
expaned use dependencies of the rule, with a leading dot (this makes regexes
that manipulate version numbers easier to write).

=item dependency

A use dependency of the rule's commands, including non-file-like objects,
objects on the C<spath:>, or objects that do not match the suffixes given.

=back

=back

=item C<optstring:>

An C<optstring:> object represents an option that needs to be provided to a
command.  So for instance, the B<ar> command often used to make libraries
might have C<optstring:cr> as a use dependency.  C<optstring:> objects are the
first thing to appear on a command line when a command is executed, and
normally start with an appropriate option character for the system (typically
slash on systems that don't use slashes as path separators, and hyphens
otherwise).  These are specified as use dependencies, but become build
dependencies unchanged.

C<optstring:> objects are split on spaces, because typically the only use for
spaces inside an option is to specify a filename which contains embedded
spaces, and that would be done via C<optpath:>.  Each space-separated
component becomes a separate command-line argument.

An C<optstring:> that has a leading space is moved to the end of the command
line, but otherwise works like the C<optstring:> without the space.  This is
mostly used for libraries, e.g. C<optstring: -lm>.

=item C<optpath:>

A combination of an C<optstring:> and a file-like object.  The format is,
e.g., C<optpath:-o:bpath:file.h> if they should be combined into one
command-line option, and C<optpath:-o :bpath:file.h> (that's a space and a
colon) if they should be left as two consecutive command-line options; to just
mention a file with no prefix, use C<optpath::bpath:file.h>.  (Many fields of
configuration rules will fill in a missing object name with the pair's
C<object>; thus, C<optpath::> is a common sight in a command, to substitute a
pair's object into its command line.)

Like an C<optstring:>, an C<optpath:> with a leading space
(e.g. C<optpath: -o :bpath:file.h>, or even C<optpath: :libm.so>) is moved to
the end of the command line, but otherwise works like the C<optpath:> without
the leading space.  (Specifically, the order of arguments is C<optstring:>s
with no leading space, C<optpath:>s with something between the colons and no
leading space, C<optpath:>s with nothing between the colons, C<optpath:>s with
a leading space, and C<optstring:>s with a leading space.)  Apart from this
sorting, aimake will try, as far as is meaningful, to leave options in the
order in which they were specified.

=item C<optionset:>

A set of options commonly used together, such as the C<CFLAGS> commonly used
by B<make> programs (which would be C<optionset:CFLAGS>).

The dependencies of an C<optionset:> object are built cumulatively, the same
way that the dependencies of a C<symbolset:> object are.  This is useful if
you want to combine all files output via a certain rule into an archive.

=item C<namehint:>

A clue as to what would make a sensible name and version number for an object.
Objects that particularly strongly hint at a name depend on their own names;
e.g. a file C<bpath:main_c.o> that contained the main routines for a file
might well depend on C<namehint::bpath:main_c.o>.  For objects that hint at
creating libraries, a version number is needed too:
C<namehint:1.2.3:bpath:library.c>.  C<namehint:> objects always exist (thus
depending on them doesn't cause problems, unless someone adds dependencies to
them using dependency rules; don't do that), and are added by the default
configuration according to some heuristics.  Therefore, you should never need
to deal with them yourself.

=item C<dependencies:>

The set of dependencies generated by a particular dependency rule,
e.g. C<dependencies:ch_file_dependencies:path:header.h> would represent the
dependencies of C<header.h> that were found via the rule
C<ch_file_dependencies>.  Dependency objects generated by dependency rules are
automatically added as dependencies of the objects they are dependencies for.
These can be generated manually too, in which case they behave like
C<optionset:> objects; you might want to do this if, for instance, you only
want the object to respect certain set of dependencies for the purpose of
specific other rules, or if you want something that works like an
C<optionset:> but which is parameterized on an object name.

=back

=head1 CONFIGURATION

aimake is designed not to need configuration on simple projects, but
sufficiently complex projects may need some configuration to explain things to
aimake that it couldn't possibly guess (such as how to generate files that are
used as part of the build process).

Much of the workings of aimake are driven by a configuration file that's
embedded into the F<aimake> script itself, in order that only a single file
need be shipped.  Any part of this script can be overriden by a configuration
file F<aimake.rules> in the root of the package source directory, via
specifying an option or a rule with the same name.

=head2 CONFIGURATION FILE SYNTAX

The format of the configuration file itself is Perl object notation; this
allows for comments, dictionaries, lists, numbers, strings, and regular
expressions:

    # this is a comment, from the # to the end of line
    4                       # a number
    'abcde'                 # a literal string
    "x\n\t$var"             # a string containing escapes and/or variables
    qr/foo.*bar/i           # a regular expression (qr//; the i is a modifier)
    [1, 2, 3, 4,]           # a list, trailing comma optional
    {foo => 1, bar => 2,}   # a dictionary, trailing comma optional

Whitespace is ignored, except inside strings.

The configuration file allows defining one or more variables (either to
abbreviate what would otherwise be repeated code, or to avoid "magic numbers"
in the code).  There are also some predefined variables, which hold
platform-specific extensions: $exeext (executables), $objext (object files),
$libext (static libraries), $dllext (dynamic libraries), $impext (import
libraries; on many systems, this is the same as $dllext because the dynamic
libraries are their own import libraries, but on some systems it differs);
there is also $symbolprefix, which is an underscore on systems in which
symbols have their names prefixed with underscores in libraries, and an empty
string otherwise, and $pointerbits, which allows the rules to learn whether
they're running on a 32- or 64-bit platform.  (In order to catch mistakes due
to omitting $exeext, it will never be set to the null string, but rather to an
arbitrary string on platforms that do not normally use a special extension for
executables.  This extension will be removed when installing the executable.)

After any variable definitions comes the main body of the configuration file.
This is a single dictionary, which can contain keys C<options>, C<features>,
C<libraries>, C<directories>, C<tests>, and C<rules>.  C<rules> is the most
complex, and documented in L</"RULE SYNTAX">; C<tests> is currently
undocumented because the API is subject to change; and C<libraries> was
documented earlier in L</"Linking in additional libraries">.  The other
sections are documented below.

Here's a simple example F<aimake.rules>:

    $version = "1.2.3";        # variable definition

    {
        options => {
            packagename => 'configexample',  # override an option
        },
        features => {
            large_data_files => {            # define a feature
                description => 'Generate large data files',
                object => qr/^path:datagen\.c$/,
                default => 0,
            },
        },
        rules => {
            install_executable => undef,     # undefine a rule
            _generate_usage => {             # define a new rule
                command => ['extend:$exeext:bpath:gendocs', 'optstring:-u'],
                output => 'bpath:doc/usage',
            },
        },
    }

=head3 THE options DICTIONARY

The options dictionary is very simple: keys of the dictionary are options, and
the corresponding values their values.  The following options are recognised
(unrecognised options are also legal, but will be ignored except for
C<config_option:> dependencies):

=over 4

=item packagename

A name that identifies the package.  If the build layout requires files or
directories to be given names specific to the package (to avoid clashes with
other packages), this name will be used as the filename.  This is intended for
use in automation, and so does not have to be user-friendly (but does have to
be unique), although it may be shown to the user in package archives and the
like.  Legal characters include lowercase letters, digits, hyphens, and
underscores (although by convention, hyphens are reserved to provide
namespaces, e.g. C<foo-plugin-bar> might be used for a plugin for a package
C<foo>).

The default is the name of the directory holding the source files.

=item packagename_text

A name that identifies the package.  Unlike C<packagename>, this can contain
spaces and punctuation.  It will be used when defining metadata of installed
files.

The default is to copy the C<packagename> option.

=item packagename_ui

A name that identifies the package.  This is used in cases where a system
shows filenames to a user directly.  This can only contain characters which
are legal for filenames in all supported platforms, but has more latitude; in
addition to legal characters for a C<packagename>, it also permits uppercase
letters, spaces, commas, and periods.

The default is to copy the C<packagename_text> option if it contains only
legal characters, and otherwise to copy the C<packagename> option.  Thus, this
option will rarely need to be set explicitly.

=item packageversion

The package's version number.  This is a string that contains a sequence of
numbers (of up to four digits), separated by dots (e.g. C<"1.0.0">).
Components other than the first can also be of the form C<"alpha"> or
C<"beta"> followed by a number, e.g. C<"1.1.beta5">; this will be converted to
an appropriate format for your operating system that sorts before C<"1.1.0">
but after C<"1.0.0">.  It is currently used when defining metadata of
installed files, and to let installers know when a file has upgraded (if you
want upgrades from one version of your package to another to work, you must
increase the version of the package and all files with each new package, and
this increase must occur within the first three components); in the future, it
may also be used to avoid clashes between different versions of the same
package, on some operating systems.

The default is C<"0.1">.

=item companyname

The organization that produces this package.  The default is to append a space
and C<"developers"> to the C<packagename_text> option.

=item ignore_directories

A regex of directory names to never consider part of the source tree.  (By
default, this is a list of directories used to hold data by a range of version
control systems.)

=item ignore_directories_with_files

A list of filenames that cause directories containing them to never be
considered part of the source tree.  (By default, this is a list of files
generated to hold internal state by autoconf, CMake, and aimake, which
indicate that the directory is being used as a build directory.)

=item ignore_files

A regex of filenames to never consider part of the source tree.  (By default,
this is a list of filename patterns used for backup, autosave, and similar
files in a range of editors.)

=back

=head3 THE features DICTIONARY

Features are dictionaries with the following keys:

=over 4

=item description

A description to show in the B<--with=?> help output, and similar places where
a user-readable description of what the feature does is needed.  This should
be less than a line long, and will be used for UI elements where there is
limited space (e.g. entries in a menu).

=item long_description

Serves the same purpose as C<description>, but allows considerably more text.
This is used for UI elements where more space is available (and will typically
be on-screen at the same time as the C<description>).  This should not contain
newlines, but will be wrapped on spaces in order to fit it into the space
available for it.

=item object

A regular expression matching objects that are considered to be part of the
feature.  If the feature is turned off, aimake will refuse to consider any
source files that match the expression as existing.  Other objects that match
the expression will be disregarded when output, but will still be considered
to exist if they already exist (due to a previous aimake run where the feature
was turned on) and do not need rebuilding.  (We are considering changing this
rule in future versions of aimake.  For the time being, it's best to use this
only to match C<path:> objects.)

If you want the feature to only have an install-time effect, rather than a
build-time effect, you can use the regex C<qr/(?!)/>, which matches nothing.

=item default

Set this to 0 for the feature to be off by default, or 1 for the feature to be
on by default.

=item depends

The name of another feature.  This feature will not be built or installed if a
feature it depends on is not built or installed.  This is optional, and can be
omitted.  (Each feature can only depend on a single other feature, although
more than one feature can depend on a given feature; thus, the features form
a "forest", a tree that can potentially have more than one root.  The implicit
root of the tree is the package as a whole.)

=back

=head3 THE directories DICTIONARY

When installing files, aimake will determine which directory to place each
file into based on two factors.  One is the C<install_dir> field of the rule
that installs the file; this specifies a directory logically, such as
C<bindir>.  The other is the directory layout in use, which is specified by
the C<--directory-layout> and C<-i> options.

aimake's built-in configuration file specifies many directory layouts in its
C<directories> dictionary.  You can create directory layouts of your own, too.
Each key of the C<directories> dictionary is the name of a directory layout;
the corresponding value is a dictionary that specifies the layout itself.

A C<directories> layout has two special keys, C<autodetect> and
C<preferred_installdir>.  These both handle the case where the user specifies
only one of C<-i> and C<--directory-layout>.  The C<autodetect> key is a
regular expression that matches an aimake-syntax filename (e.g. the
C<autodetect> key for the C<fhs> layout is C<qr/^spath:\/(?:usr)?$/>, which
matches only C<spath:/> and C<spath:/usr>); aimake will use this layout for an
C<-i> option matching the given regular expression.  The
C<preferred_installdir> option is an aimake-syntax filename, that specifies a
default value for the C<-i> option in the case where only
C<--directory-layout> is given.

The other keys are all directory names ending in C<dir>, as aimake-syntax
paths.  These can also substitute in the values of other directory names (or
C<installdir>, the argument to the C<-i> option), e.g. the C<fhs> layout sets
C<bindir> to C<$installdir/bin>, C<staterootdir> to C<spath:/var>, and
C<logdir> to C<$staterootdir/log>.  Note that these should be single-quoted in
the configuration file (i.e. C<bindir => '$installdir/bin'); otherwise, they
will be confused with a variable substitution using a variable from the
configuration file.

=head2 RULE SYNTAX

The rules dictionary is the most complex part of a configuration file.  It
consists of a number of rules; the keys are the rule names, and the values the
rules themselves.  aimake's predefined rules will all start with a lowercase
letter.  In order to avoid clashes with them when defining your own rules,
start the names of your own rules with an underscore.

A rule itself is written as a dictionary.  The keys of the dictionary specify
information about the rule's dependencies and how to run it; what messages the
rule produces; how to parse its output; and what to do after it has been run.

=head3 DEPENDENCIES AND RUNNING A RULE

All of these fields are meaningful for any rule.

=over 4

=item object

Although there are only finitely many rules in the configuration file (and in
aimake's internal configuration file that specifies the built-in rules), there
can be an unlimited number of pairs; a rule can run multiple times, each time
applying to a different object.

The C<object> field allows a rule to be parameterized by an object.  It can
either be a string (to have only one copy of the rule, always parameterized by
the same object), or a regular expression (in which case there will be a copy
of the rule for each object that matches, each leading to a different pair).
The default is to use a hardcoded C<sys:no_object>.

Each pair that shares a rule has some fields parameterized by its C<object>.
Any object names that are left unfinished (such as C<optpath:-i :>) have the
C<object> substituted at the end of them (so if the C<object> was
C<bpath:foo.txt>, this would be equivalent to C<optpath:-i :bpath:foo.txt>).
The default value of C<inner> is also equal to the C<object>, meaning that
fields such as C<output> and C<depends> have this substitution performed on
them by default, too; unlike the C<command>, though, this behaviour can be
overriden via explicitly setting C<inner>.

The C<object> is also the object that has dependencies attached to it via
rules that use the C<depends> field in order to attach use dependencies to
objects "after" they are generated (although this is just a complex form of
syntactic sugar, as explained above).

For convenience, the C<object> is implied into the C<command> by default in
many cases (because this is normally what is wanted); see the description of
the C<object_dependency> field.  This behaviour can always be overriden via
changing C<object_dependency>.

Some types of object are disallowed in the C<object> (basically either because
infinitely many of that object exist, or because the object is entirely
virtual, or because aimake doesn't track how many of those objects exist):
C<sys:>, C<cmd:>, C<intcmd:>, C<optstring:>, C<optpath:>.

=item command

The C<command> has two purposes: it specifies the build dependencies of a
rule, and also which command must be run in order to execute the rule.  This
is a list of objects (if it has length 1, the C<[]> surrounding the list can
be omitted, and the single object specified will be treated as a 1-element
list).  The default value is a list consisting only of C<intcmd:nop>.

The build dependencies of the rule are calculated via starting with the
C<command>, and recursively expanding it with the use dependencies of the
objects in it, their use dependencies, and so on.  The executable-like and
option-like objects in the resulting list are also interpreted as a command to
run in order to execute the rule.

A null string in the C<command> of a dependency rule refers to the C<object>
(which must be given).  This is, however, mostly pointless; the C<object> is
automatically implied into the list whenever it would not lead to an infinite
regress, with the default value for C<object_dependency>.  Likewise, if just
the "outside" part of an object (e.g. C<optpath::>) is given, the C<object> is
used to fill in the "inside" (and this can be meaningful in any sort of rule).
Note that just because the C<object> is automatically included in the
dependency lists, this doesn't necessarily mean it will be mentioned on the
command line (given that the C<object> is not an option-like object); use
C<optpath::> for that.  The command line arguments to the executable being
run are produced entirely out of C<optstring:> and C<optpath:> objects; no
other objects have an influence on it, unless you consider the name of the
executable itself to be part of the command line.

=item object_dependency

Typically speaking, the contents of a pair's C<object> matters to the pair's
C<command>; the object must be up to date before anything can be produced or
provided from it.  Sometimes, a provision (or in extreme circumstances where
only the object's name is relevant and its contents irrelevant, a production
rule) rule will not need the normal use dependencies of an object to be in
place.  (For instance, when looking at a file to see which symbols it
provides, you don't need access to the symbols that that file uses.)

The C<object_dependency> field of a rule allows control over where the object
is included. Its value is a string:

=over 4

=item auto

The object is included in the C<command> if all the rule's C<action>s are
provision, production, or install actions; and not included anywhere if all
the rule's C<action>s are dependency actions.  In other cases, this value is
an error.  C<< object_dependency => "auto" >> is the default.

=item outdepends

The object is included in the C<outdepends> of any provision actions of the
rule.  This allows the use dependencies of the pair to be "deferred" one
level; they don't need to be in place to run the rule, but they do need to be
in place to make use of the rule's output.

=item nowhere

The object is not automatically included anywhere, perhaps because it works
differently for different actions of the rule (you can get something
equivalent to C<< object_dependency => "outdepends" >> via adding a null
string to an C<outdepends> list).  This is mostly useful when the object's use
dependencies are truly irrelevant, such as when providing C<searchfile:>
objects.

=back

=item in_subdir

By default, aimake uses absolute paths for command line arguments.  Sometimes,
a program will only function correctly with relative paths.  In such a case,
set C<in_subdir> to specify the current directory for running the command;
C<optpath:>s that refer to files within that subdirectory will be formatted as
relative paths.

This option can also be used simply to make command lines shorter, making them
easier to read in error messages.  In such cases, it would typically be set to
C<bpath:>.

=item avoid_rules

Sometimes, an object can be provided by more than one pair.  This is not an
error; aimake attempts to choose the most appropriate.  Sometimes, though,
which object is most appropriate depends on which rule was involved in
creating it; in this case, you can set C<avoid_rules> to a regular expression
that matches the names of rules.  Provided objects created by rules whose
names match the regular expression will not be considered to satisfy
dependencies of this pair; and produced objects created by rules whose name
match the regular expression will not be considered as an C<object> of the
rule.  (You would use this, for instance, to avoid an infinite regress when
creating a dynamic library; you would want the symbols to come from object
files, not from the dynamic library that the rule itself had created.)

=item avoid_built_from

C<avoid_built_from> works like C<avoid_rules>, except that it excludes
provided objects only, and is based on the C<object> they were built from,
rather than the rule they were built from.  This is a single object name,
which will have missing portions filled in with the C<object> the same way as
with the C<command>.  (For instance, this is used in the scenario where a
source file produces an implementation and an interface in separate files, and
compiling the implementation needs access to the interface of other files; it
should not be compiled in terms of its own interface, or it will attempt to
import from itself, which typically leads to problems.)

=item force_locale

Setting C<force_locale> to a particular value forces the LC_ALL environment
variable to have that value while running the C<command:>.  This is used when
the rule needs to parse human-readable output from the command; many commands
will vary their output depending on the locale, typically to translate it into
the user's language.  The usual value for C<force_locale>, when needed, is
"C"; this value is defined to be supported by every program, and designed to
cause them to try to make their "human-readable" output as machine-readable as
possible: messages are written in a default language (normally English, or a
terser version of English), numbers are written with a period as the decimal
separator and no grouping marks, and so on.

The locale is also used to work out what character encoding a program's output
is likely to be in, in order to correctly convert it to Unicode for regular
expression matches.

=item require_match

If set to a nonzero integer, aimake will consider the command to have errored
out if any regexes in the rule fail to match any lines of output.  (This helps
detect typos in regexes, or unusual output formats from the command you're
regexing, in the case where you know that correct operation will cause the
regex to match at least once.)  This option overrides C<on_failure> in the
situation where both are given.

=back

=head3 CONTROLLING MESSAGES

These values can be set for any rule, and have no effect on anything but the
messages displayed to the user.

=over 4

=item low_message_priority

C<low_message_priority> is an integer, defaulting to 0.  If this is set to a
nonzero value, it causes aimake not to print messages about this rule being
run unless the verbosity level is increased to at least 1.  (This is used for
production rules that make aimake aware of objects on the C<spath:>, mostly.)
There is no point in specifying this for rules which consist entirely of
dependency actions, because those messages require a verbosity level of 1 or
more to be printed anyway.

=item debug_trace

C<debug_trace> is sort of a conceptual opposite of C<low_message_priority>;
however, unlike that field, it is mostly only useful for debugging aimake
rules files, and should not be used in production use.  If set to a nonzero
integer (the default is 0), it will cause aimake to print debug information
concerning the rule in question; aimake will print a message when the rule
starts to run and finishes running, and the command line and output of any
commands that it runs, even if the verbosity level is at 0.

=item ignore_warnings

C<ignore_warnings> is an integer.  If set to a value other than its default of
0, any warnings produced while running the rule's command will be discarded,
rathe than shown to the user as is normal.  This is mostly useful when you
know that the rule will produce spurious warnings in some situations.

(If you actually wanted to react to the warnings, rather than just hiding
them, see the C<also_match_stderr> field.)

=item hide_errors

C<hide_errors> works like C<ignore_warnings>, but instead of discarding
warnings, it "discards" errors when set to a nonzero integer.  The errors
nonetheless happen, and C<on_failure> is respected like normal; they just aren't
shown to the user.

The default value is normally 0, but it defaults to 1 if any actions of the
rule have their C<on_failure> fields set explicitly in the rule, or if the
C<on_failure> fields are set to C<auto> and the program produced error output
that caused this to resolve to C<inapplicable> rather than the default of
C<fail>.  It can be overriden explicitly to 0 if required, or explicitly to a
nonzero value if required.  Note that overriding this to 0 will cause the
build to fail if any errors occur, even though C<on_failure> handles the
resulting errors, and thus this combination is probably not very useful.

=item verb

C<verb> affects the message given (e.g. "Built file.o") when a pair fails or
succeeds, and can be used to make aimake's output a little more user-friendly
than normal; most built-in rules have an appropriate C<verb>, and you can set
it in your custom rules, too.  The default depends on what actions the rule
takes upon succeeding, typically "built" or "found".

=back

=head3 PARSING OUTPUT

Although many of the internal commands (i.e. an C<intcmd:> object that's
directly or indirectly included in the C<command>) are very well-behaved,
using an internal mechanism to remember rule boundaries and with no encoding
issues, commands external to aimake are rarely so well-behaved.  The fields in
this section instruct aimake to perform various processing on the output
before the rule's actions match it with regular expressions.

=over 4

=item filter

If C<filter> is set to a regular expression, aimake will disregard any lines
of output that do not match the regular expression.

=item linesep

Setting C<linesep> changes what is considered to be a line separator in the
output.  You might, for instance, want to split the output on spaces if trying
to parse a Makefile rule.  The default is a newline (C<"\n">).  This can be a
regular expression, or a string (which is matched literally).

If C<linesep> is combined with C<unescape>, then escaped literal newlines will
be deleted (as usual with C<unescape>, escaped C<linesep>s will be considered
to be a literal C<linesep>, unless C<linesep> is a newline itself),
non-escaped literal newlines will be considered to be newline characters that
don't break a line, and non-escaped C<linesep>s will be considered a
transition from one line to the next.  (This makes it possible for every
codepoint to be used in the output from a program; as such, C<aimake> will
track the line separators internally.)

=item lineskip

After applying the C<filter> and C<linesep>, specifies the first line of
output that will be read, by specifying how many of the lines to skip at the
start (as an integer).  The default is 0.

=item linemax

After applying the C<filter>, C<linesep> and C<lineskip>, specifies the
maximum number of lines of output that will be read (as an integer).  If not
provided (the default), all the lines will be read.

=item unescape

When set to a string, causes aimake to unescape the output from a program.  By
default, no unescaping is done.  At present, the only recognised values for
C<unescape> are:

=over 4

=item C<'backslash'>

Backslash-newline is deleted; backslash followed by any letter in C<abfnrt>
will be replaced by a corresponding control character according to the rules
of C; and backslash followed by any other character will be replaced by that
character.  (No vertical tabs, sorry.  They're not portable between character
sets.  At present, we don't implement decimal/hexadecimal/octal escapes,
either.)

=item C<'backslash_whitespace'>

Backslash-newline is deleted; backslash followed by other whitespace, or
another backslash, deletes the backslash but leaves the whitespace or second
backslash; and backslash followed by any other character preserves both the
backslash and the character.  (This is the encoding gcc uses for makefile
fragments.)

=back

=item also_match_stderr

If set to a nonzero integer, causes the command's output to be considered to
include standard error as well as standard output.  (That is, messages on
stderr will not be considered to be warnings, but rather will be matched by
any regular expressions used.)  If left at its default value of 0, anything
printed on stderr will be assumed to be a warning or error message, rather
than the part of the program's output that regular expressions are trying to
match.

=back

=head3 ACTIONS

After a rule is run, it can produce objects, provide objects, add dependencies
to objects, or install files â or any combination of these (except that
installing must be done on its own, because it might need special
permissions).  If a rule only has one action, the fields that describe that
action can be placed into the rule's dictionary directly.  Otherwise, each
action has its own dictionary, all of which are specified using the C<actions>
field.

=over 4

=item actions

If a rule has more than one action, they cannot be specified directly in the
rule's dictionary, because then their fields would get muddled with each
other.  Rather, each action has its own dictionary.  The C<actions> field
takes a list of these dictionaries as its value.

For example, a complete rule might look like this:

 foo_c_includes_foo_h => {
     object => "bpath:foo.c",
     object_dependency => "nowhere",
     actions => [
         { depends => "file:foo.h" },
         { output => "searchfile:foo.h", outdepends => [] },
     ],
 }

This rule has a provision action, and a dependency action.

A rule can contain any number of provision actions, any number of production
actions, and up to one dependency action; alternatively, it can contain a
single install action (in which case using C<actions> is pointless; you could
simply specify the install action directly).

=item actiontype

I<Available for: any sort of action>

Normally, aimake will automatically attempt to determine which sort of action
is which, by looking for the C<output>, C<outdepends>, C<install_dir>, and
C<depends> field.  However, there is a potential ambiguity in cases where both
C<output> and C<outdepends> are specified.  aimake will assume that such
actions are provision actions, by default; in the case where this is actually
a production action, an explicit C<< actiontype => 'produce' >> must be given.

Any type of action can have an explicit C<actiontype> setting that specifies
the type of action explicitly: the action types are C<provide>, C<produce>,
C<depend>, and C<install>.

=item output

I<Available for: provision actions, production actions>

The C<output> field is used in provision and production actions to specify
which objects are created as a result of running the rule.  This can be a
single, hardcoded string; a list of hardcoded strings; or a regular
expression.  In order to generate the full names for the output objects,
C<output> and C<outputarg> will be concatenated; and if this generates an
incomplete object name, a colon (if necessary) and C<inner> will be appended.
The action will run once for each element in the list, or each time the
regular expression matches, applying to a different element or match each
time.

When using a regular expression, the first parenthesized group of the
expression will be interpreted as the output object, and in most cases,
translated from whatever format your operating system uses for filenames to an
aimake object name.  The exception is when using an internal command that
operates on objects, such as C<intcmd:listtree>; aimake knows that those
commands operate on object names, and so the regular expression match will be
interpreted as an object name in those cases.

If the action produces a file-like object, aimake will error out if the file
does not actually exist on disk.  (This is to catch mistakes in the
configuration files; it would be less code to permit this case, but it is
unlikely to be what was intended, and seem to have no purpose.)  The file does
not actually have to be created by the command; especially in the case of
C<path:> and C<spath:> objects, it's sufficient for the file to be
pre-existing (in which case producing it merely lets the file be used as an
aimake object).

As a special case, the C<object> is ignored if it appears in the C<output>,
because it is meaningless for an object to provide or produce itself, and
because it often makes it much easier to write regular expressions to parse
output without having to handle that special case.

A provision action requires C<output>; a production action requires either
C<output> or C<output_from_optpath>.

=item output_from_optpath

I<Available for: production actions>

One very common situation in which a rule is used is that the build system
needs to run a command on some set of files, which produces some other file as
an output, and a command-line option is used to tell that command where the
output goes.  Instead of repeating whatever calculation was used to determine
the destination filename, you can instead use C<output_from_optpath> to tell
aimake to look at the command-line options to find out where the output goes,
the same way as the command does.  For instance, if the program took an option
C<optpath:-o :bpath:foo.i>, you would use C<< optpath_from_output => '-o ' >>;
aimake would interpret this as an C<output> of C<bpath:foo.i>.  You can give
an array here too, e.g. C<< optpath_from_output => ['-o ', '--header='] >>,
for if the command has more than one option that controls output locations.

=item information_only

I<Available for: production actions>

Normally, outputting something in the C<path:> or C<spath:> (including
C<standardlib:>) is a mistake.  If you do it intentionally (e.g. to make
aimake aware of files in the C<spath:>), set C<information_only> to a nonzero
integer so that aimake will know that you're merely talking about the files,
not changing them, and so not error out.  The default is 0.

=item outdepends

I<Available for: provision actions, production actions>

Provision actions don't generate files on disk; they just say "objects X can
be used to provide object Y".  In this case, object Y is the C<output>;
C<outdepends> specifies what objects X, the use dependencies of object Y, are.
This is in exactly the same format as the C<output>, although instead of being
concatenated with C<outputarg> and maybe C<inner>, it uses C<dependsarg> and
C<inner> instead.  C<outdepends> is required for provision actions (although
it can be set to an empty list C<[]>).  It can also be used with production
actions; this is typically only useful when the way in which an output file
must be handled depends on which rule was used to produce it, a situation
which is rare but not unthinkable.

=item depends

I<Available for: dependency actions>

A dependency action adds a set of use dependencies to C<object>.  This
specifies those objects.  This works exactly like C<output> and C<outdepends>,
using C<dependsarg> and C<inner>.  This must be set for dependency actions,
but not for any other sort of action (it's the field that distinguishes a
dependency action from other types of action).

=item install_dir

I<Available for: install actions>

An install action causes the C<object> to be installed in a given directory.
This must be given for install actions, and only for install actions, and
takes one of the following strings as its value:

=over 4

=item bindir

A directory used for installing executables runnable by the user.  When
installing system-wide, this will typically be somewhere that's on the $PATH
by default (except on Windows, where there are no suitable locations, and so a
project-specific subdirectory of Program Files is used by default).

=item libdir

A directory used for installing libraries that are used by tools provided with
the system, such as C compilers.  This should be used for
architecture-dependent files.

=item specificlibdir

A directory used for installing libraries that are only used by the program
being installed.  Like libdir, this should be used for architecture-dependent
files.

=item includedir

A directory used for installing include files that are used by tools provided
with the system (e.g. C header files).  This should be used for
architecture-independent files.

=item specificincdir

A directory used for installing architecture-independent include files that
are specific to the program being installed (although they will still be
visible to system tools if an appropriate path fragment is used when including
them; this does not cause the files to be secret, it simply tries to namespace
the files to avoid filename clashes).

=item configdir

A directory used for system-wide configuration files (that apply to all users
on a multi-user system); these may be intended to be edited by the user, but
should not be edited by the program itself.  These should be text files.

=item datadir

A directory used for general architecture-independent read-only data files
used by the program.

=item docdir

A general-purpose directory used for documentation, when no more specific
directory is available.  Use this directory for documentation in unusual
formats.

=item mandir

A directory used for documentation in UNIX manual format.  These directories
are often divided into sections, in which case aimake will automatically
place installed files into the correct section.

=item infodir

A directory used for documentation in GNU Info format.

=item sourcecodedir

A directory for installing source code.

=item shortcutdir

A directory that contains descriptions of executables and is typically used to
show a menu to run them (e.g. the Start menu on Windows, or
F</usr/share/applications> on Linux).

=item statedir

A directory used for general architecture-independent data files that are both
read and written by the program (and that are shared between all users).

Note that in many cases, this directory will be administrator-owned;
therefore, your program will not actually be able to write to this directory
unless it's being run with administrator permissions, or you use the
C<install_permission> option in order to grant write permissions to a wider
audience.

=item rootbindir

Like C<bindir>, but for executables designed to be run with elevated
permissions.  This doesn't actually do anything to elevate the permissions,
nor to prevent users without elevated permissions running the executables;
rather (on many operating systems) it makes it harder for non-administrators
to run the program by accident.

If you want to outright require administrator permissions to run the program,
see the C<install_permission> field.

=item gamesbindir

Like C<bindir>, but for executables which are games.  (Some sites may have
policy that handles game executables specially.)

=item gamesdatadir

Like C<datadir>, but for read-only data files for games.

=item gamesstatedir

Like C<statedir>, but for read-write shared data files for games (such as high
score tables).

=item logdir

A directory used for log files that are written by the program.

=item lockdir

A directory used for files, shared between all users, that are transient in
nature.  (The directory is likely, but not guaranteed, to be one where files
are deleted on reboot.)  It is probably a bad idea to install anything into
this directory, but aimake tracks it so that compiled programs can refer to
it via C<aimake_get_option>.

=item specificlockdir

A directory used for files, shared between all users, that are transient in
nature, that is not used by any other package (and thus, can be given files
with arbitrary filenames without worrying about name clashes).  In addition to
the warnings under C<lockdir>, bear in mind that the directory itself may be
deleted on reboot, and as such, may have to be re-created each time it is
used.

=back

=item install_name

I<Available for: install actions>

The basename to install a file under; this defaults to the basename of the
C<object>.  This can include forward slashes to install into a subdirectory
(regardless of what the path separator happens to be on the system in
question).

=item copy_structure

I<Available for: install actions>

If set to 1 to mean true, defaults C<install_name> to the entire path of the
C<object> (relative to C<path:>, C<bpath:>, or C<spath:>), rather than just
the basename.  The main use for this is internal, to allow the installation of
source code without losing information about its directory structure.

=item exeparams

I<Available for: install actions>

When installing an executable, also generate appropriate OS-specific metadata
for that executable (setting its human-readable name, icon, etc.).  The format
of these parameters as given to aimake is OS-independent, and will be
converted into an appropriate form for the OS you are targetting; depending on
the OS, this might involve installing extra files, making changes to the files
after install, or both.

This option can only meaningfully be set for executables and C<intcmd:symlink>
aliases to executables (in which case, a copy will be used rather than an
alias if this is necessary to respect the operating system's metadata format).

This option will have no effect on Windows unless the Perl module
C<Win32::Exe> is installed.  (However, this module is often shipped with Perl
interpreters on Windows.)

Note that some operating systems place maximum lengths on individual values
here, or on the total length of all values, and aimake may not be able to
detect if the maximum lengths are exceeded.  You should, therefore, try to
keep the metadata values as short as possible.

The value is a dictionary, with the following keys, all of which are optional,
and which will be ignored if they do not apply to the operating system in
question:

=over 4

=item icon

An aimake object that represents a file on the filesystem (such as
C<path:icon.png>), or a regular expression that matches one or more such
objects.  All such objects must be PNG-format images.  These images specify
the icon that will be associated with the executable; the operating system
will pick an appropriate image from the images given based on the size it
needs to render the image at (and perhaps rescale it, if no image fits the
given size exactly).  By default, no icon will be explicitly specified (most
likely, the OS will substitute a generic icon).

In order for icons to be usable by all OSes, they must be square, and have one
of the following sizes (in pixels): 16, 24, 32, 48, 64, 72, 96, 128, 256.
Additional sizes (including non-square sizes) can be specified, but may be
ignored.

This option currently does not work correctly on versions of Windows prior to
Windows Vista.  (However, such versions are by now dangerously obsolete.)

=item copyright

A string that specifies the copyright status of the executable (for example,
C<"Copyright (C) 2014 Alex Smith">).  By default, no copyright status will be
embedded into the executable's metadata.  Not all operating systems have any
use for this, so it may be ignored.

=item version

A string that specifies the version number of the executable.  This should be
comprised of dot-separated numbers (e.g. C<"1.0.0">); some operating systems
may disallow more complex version components, or add trailing C<.0> components
(although aimake will handle C<alpha> and C<beta> components the same way as
with C<packageversion>, converting them to numbers if necessary).  By default,
the value will be taken from the C<packageversion> option, but it can be given
explicitly to override this (e.g., if different executables have different
versions).

For upgrades to work correctly on every operating system, aim to ensure that
with every new released version, the version number of every file increases
within the first three components.  (Defaulting this to the C<packageversion>,
and just increasing the C<packageversion>, is the easiest way to do this.)

=item name

A human-readable name for the executable.  This will be used to name the
executable in menus and similar structures, especially when it isn't running
(and thus there is no window title that could be used instead).  The default
is to use the filename with any extension removed.

=item description

A human-readable description for the executable.  On some operating systems,
this will be used as a tooltip for the executable on menus.  (Others will just
use its C<name>, especially if they have an icon-based rather than text-based
menu system, and thus aren't displaying the C<name> anywhere else.)

=item terminal

0 for false or 1 for true.  If true, then aimake will attempt to tell the
operating system that this application always needs a terminal window to
connect its standard input and output to (and thus, if the application is run
from outside a terminal, the OS will have to create a new terminal to run it
in).  If false, then no terminal will be created for the application (meaning
that it might not have a standard input and output to use, and thus will need
to use some other method of communicating with the user, such as opening a
window).

This option has no effect if the application already has control of a terminal
(e.g. the application is run using a command prompt that is already open in a
terminal), and might not be respected on all OSes in all circumstances (one
example of when it isn't is when using the Alt-F2 shortcut that exists in some
Linux desktop environmens, which runs a program via filename without reading
its metadata and without an existing terminal).

The default is to respect whatever setting the compiler used, or in the case
where it didn't specify, 1.  (It is quite common for the compiler not to
specify, so you should probably set this to the right value explicitly.)

=item interactive

0 for false or 1 for true (default).  If true, then aimake will attempt to
tell the operating system that it's meaningful to run this application
directly, without extra parameters, and that the application will then attempt
to interact with the user.  If you set this to false, this indicates that the
application needs command-line arguments to function correctly, has no visible
effect when run, or both; this will cause aimake to try to leave it out of the
OS's menu system for running applications.

There is currently no situation in which a non-C<interactive> program would
benefit from a C<description>; aimake ignores the C<description> in this case.
You may wish to specify the combination anyway in case it ever becomes
relevant in the future.

=back

=item link_to_directory

I<Available for: install actions>

This can only be used when installing a directory (i.e. C<sys:touch_only>).
This is a string, which will give a user-readable name for the directory
(under the same rules for legal characters as the C<packagename_ui> option).
What effect this name has will depend on the operating system; on Windows, it
will create a Start Menu entry for the directory, and on Linux, it will place
a symlink to the directory in the package's documentation directory.

=item install_permission

I<Available for: install actions>

A value that causes aimake to adjust the permissions on installed files.  In
most cases, this refers to who can read or execute the resulting files; in the
case of C<statedir> and similarly writable directories, this additionally
refers to who can write them.

Options for this field include "ADMINISTRATOR" (only administrators can
read/execute/write the files), and "ANYONE" (anyone can read/execute the
files, and write files in the C<statedir>).  Leaving the field absent allows
anyone to read or execute the files, but only adminstrators able to write
them.  Other values may be understood, depending on the operating system; for
instance, "games" is common under UNIX-like operating systems, meaning that
the file should only be readable/writable by games, not by players directly;
this can be used to protect the integrity of high score tables, for instance.

If a user is installing for their own use (via C<-i> into a directory they
own, rather than a public one), aimake will not do any special permissions
handling (i.e. C<install_permission> and C<install_elevation> will be
ignored); that user will be able to do what they like with the installed
files, other users will not be able to write those files (and may or may not
be able to read or execute them depending on how that user has configured the
permissions on the install directory).  Likewise, the B<--natural-permissions>
option disables permissions handling.

Permissions are implemented as groups on UNIX-like operating systems (apart
from "ADMINISTRATOR", which is implemented using the user with a UID of 0, and
"ANYONE", which does not need a user/group to correspond to), and thus only
exist where a group with the same name exists.  You may need to create the
group separately before running aimake.  On Windows, permissions cannot be
granted by aimake's own install process; however, aimake will communicate
information about permissions to other installers, and thus an install via
B<--gen-installer> will set permissions appropriately (although any values
other than "ADMINISTRATOR" will be considered as synonyms for "ANYONE").

If the permission in question does not exist, aimake will print a warning and
substitute the default setting (anyone can read/execute, but only
administrators can write).

=item install_readable

I<Available for: install actions>

If set to a nonzero integer (the default is 0), causes C<install_permission>
to control only write and execute permissions; anyone will be able to read the
file.  This makes C<install_permission> redundant except on executables or on
writable files.

=item install_elevation

I<Available for: install actions>

A value that causes aimake to attempt to grant permissions to the executables
it installs.  (Granting permissions to a non-executable is meaningless, and
thus ignored.)  The values (and system-specific caveats) are the same as for
C<install_permission>; an executable with a given C<install_elevation> can
read, write, and execute files with a matching C<install_permission>.  Thus,
if you want to protect a file so that it can only be read/written by means of
the executables you install, give the executables an C<install_elevation>
matching the C<install_permission> of the file.  (Operating-system-specific
techniques may be needed to cause the permission to exist in the first place.)

Although C<aimake> supports an C<install_elevation> value of "ADMINISTRATOR",
we strongly recommend that you do not do this, because it nearly always leads
to security problems unless the elevated executables are very well written.

=item install_feature

I<Available for: install actions>

Features (see B<--with>/B<--without>) have a compile-time effect, preventing
files being built.  However, they can also have an effect on what is
installed.  If the C<install_feature> field of an install rule is set, that
rule will not run unless the matching feature is requested.

In some cases involving B<--gen-installer>, aimake can represent the behaviour
of this field inside the generated installer.  In such a case, the install
rule will not even be included in the installer if the feature is disabled
with B<--without> (or having a disabled default); if the feature is enabled
with B<--with> (or having an enabled default), it will be included in the
installer, but the option as to whether to install the feature will be under
the control of the person who uses the installer (and its default value in the
installer interface will be the same as the default value of the feature in
aimake).

=item inner

I<Available for: production, provision, and dependency actions>

There are a few compound objects like C<searchpath:> and C<optpath:>.  To
output such objects, C<output> or C<depends> can be set to just the "outside"
part of the object (e.g. C<searchpath:library:> or C<optpath:-o :>), and
C<inner> is used to specify the "inside" part of the object.  It can be a
regular expression, with the same meaning as making C<output> or C<depends> a
regular expression.  The default value of C<inner> is for it to be the same as
the C<object>.

=item outputarg

I<Available for: production actions, provision actions>

Nested objects have the form C<objtype:outputarg:inner>.  If C<output> is just
a C<objtype:outputarg:>, the C<inner> is used to fill in the rest of the
object name.  If output is just a C<objtype:>, however, the C<outputarg> is
used to fill in the rest of the name; this works for both nested and
non-nested objects.  (It's possible to have both an C<outputarg> and an
C<inner> in the case of a nested object.)  C<outputarg> should be omitted if
not needed, and should be specified if needed.  Just as with C<inner>, it can
be a regular expression (and typically is only useful if it's a regular
expression); unlike with C<output> and C<inner>, it's always interpreted as a
plain old string, not as a filename or object name.

Although it is usual to divide up an object name between C<output> and
C<outputarg> such that C<output> contains the object name up to the first
colon, and the C<outputarg> contains the part of the object name between the
first two colons, this is not mandatory; the C<output> and C<outputarg> will
be concatenated regardless of what they contain, and interpreted as an object name
(or a nested object name missing the C<inner>).

=item dependsarg

I<Available for: production, provision, and dependency actions>

Works exactly like C<outputarg>, except for C<depends> and C<outdepends>
rather than C<output>.

=item command_line_override

I<Available for: provision actions>

This specifies the name of an environment variable.  If the variable is set in
the environment, as an option in a configuration file's C<options>, or using
the B<--var> option, the C<outdepends> of this action is entirely replaced
with the value of that variable.  (This is how things like C<CFLAGS> are
implemented internally; their default values are specified in a rule which has
a C<command_line_override>.)

=item on_failure

I<Available for: production, provision, and dependency actions>

If a command fails to run (that is, it reports a failure using its exit code,
or it crashes), there are several ways that aimake can handle the resulting
situation.  The default is always C<auto>, but there are more possibilities
than that available, which can be specified separately for each action using
the C<on_failure> option:

=over 4

=item auto

Normally acts like C<fail>.  However, if the string C<!AIMAKE_FAIL_SILENTLY!>
is observed in the command's error messages, acts like C<inapplicable> instead
(and if C<hide_errors> is not specified explicitly, changes its default to 1).
This allows a file to conditionally mark itself inapplicable via using
whatever facilities the program interpreting it provides to force an error.
For instance, a Windows-specific C file might contain directives like this:

 #ifndef AIMAKE_BUILDOS_MSWin32
 # error !AIMAKE_FAIL_SILENTLY! This file only works on Windows systems.
 #endif

=item fail

If the command fails to run, do not attempt to produce this output, and delete
any existing output (for a production or provision action); or do not allow
the use dependencies of the C<object> to be fulfilled (for a dependency
action).  In other words, do not attempt to proceed with the build further if
it would require this rule to have succeeded.

=item inapplicable

Acts identically to C<fail> for a provision/production action, and
C<conditional> for a dependency action, except with different messages; the
user will be informed that the rule was not run due to the configuration.
This also changes the default value of C<hide_errors> to 1, because it is not
C<fail>, meaning that an inapplicable rule will not cause aimake to report
that the compile failed unless C<hide_errors> is set to 0 explicitly.

=item empty

If the command fails to run, assume that it succeeded, but produced no output
on stdout.  This typically works out to the same thing as C<fail> when the
C<output> is a regex match (and is not very useful when not using regex
matches).  However, if the C<depends>/C<outdepends> is a regex match, this can
lead to a successful output with fewer dependencies than it would otherwise
have; occasionally, this is what you want.

=item conditional

This can only be given for dependency actions, and provision actions whose
C<output> is hardcoded (otherwise it would be unclear what to output if the
command failed).  If the command fails to run, use an empty
C<depends>/C<outdepends> rather than the specified C<depends> or
C<outdepends>.  The intended use of this is to add dependencies conditionally.

=item alternative

This is similar to C<conditional>, but provides more control; if the command
fails to run, use the C<depends>/C<outdepends> given in the rule's
C<alternative> field, rather than the specified C<depends> or C<outdepends>.
This is intended for use in writing F<autoconf>-like tests.

=item parse

If the command fails to run, parse what output (if any) it produced before it
exited or crashed, as if it had succeeded.  This setting is useful in the case
of commands that otherwise work, but produce a failure code, perhaps because
they fail only after they've produced the messages you are interested in.

=back

=item preference

I<Available for: provision actions>

C<preference> is an integer from 0 to 100, defaulting to 0.  When multiple
actions (in the same rule, or across different rules) attempt to provide the
same object, various heuristics are used to determine which object should be
used for any given purpose.  C<preference> provides a global tie-break on
this, allowing (for instance) aimake's default ruleset to prefer linking
against shared libraries than linking against static libraries with the same
basename.

=item output_as_searchfile

I<Available for: provision actions>

Causes any C<file:> objects that would be output to be output as
C<searchfile:> objects instead, if set to a nonzero integer.

=item output_as_standardlib

I<Available for: production actions>

Causes any C<spath:> objects that would be output to be output as
C<standardlib:> objects instead, if set to a nonzero integer.

=item filter_absolute

I<Available for: production, provision and dependency actions>

Causes any objects other than C<file:> objects (i.e. any objects that
correspond to an absolute path) that would be generated via a regular
expression match to be ignored if set to a nonzero integer (this is most
common/useful in dependency rules).  It should be set to a nonzero integer or
omitted.

=item filter_spath

I<Available for: production, provision and dependency actions>

Causes any C<spath:> objects that would be generated via a regular expression
match to be ignored, if set to a nonzero integer.  (This is most useful in the
case where you aren't interested in dependencies on system headers.)

=item filter_nonexistent_files

I<Available for: production, provision and dependency actions>

If set to a nonzero integer, causes any objects that would be generated via a
regular expression match to be ignored if they don't appear to be the filename
of an existing file (that's either a regular file or a symbolic link).  It
should be set to a nonzero integer or omitted, and is mostly useful for
avoiding false positives when parsing output that mixes filenames with other
information.

=item filter_text_files

I<Available for: production, provision and dependency actions>

If set to a nonzero integer, causes any objects that would be generated via a
regular expression match to be ignored if they appear to be text files, rather
than binary files (the main purpose of this is for filtering out linker
scripts, which cannot be distinguished from libraries via filename alone).  It
should be set to a nonzero integer or omitted.  Note that testing whether or
not a file is a text file is not 100% reliable (although it tends to be
reliable enough to distinguish a linker script from a library, because both
are in formats that are easy to test for binary-ness).

=back

=for comment
You can provide a list of dictionaries rather than a single dictionary as the
definition of a rule.  This allows for alternative versions of rules to work
using different compilers, or the like.  aimake will pick the first rule on
the list which doesn't contain a nonexistent object in its C<command>, nor its
C<outdepends>.  This can only be used for rules with no C<object>, for
efficiency reasons (it's mostly intended for rules that provide C<tool:>
objects).

=for comment
Apparently, there's no POD version of the GPL available, so we use this
plaintext version instead.  (I can't reformat it due to the no-derivs
metalicense.)  (Comment on this comment: "=for comment" is not followed by a
newline, unlike most POD directives.)

=head1 COPYRIGHT

Copyright (C) 2013, 2014, 2015 Alex Smith.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

Note that the author of this program does not believe that programs compiled
using aimake are a derivative work of aimake (in the same way that, for
instance, programs compiled using autoconf are not a derivative work of
autoconf).  As such, the license of aimake does not restrict what licenses and
distribution terms you use for programs that you compile with aimake.

                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007

  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.

                             Preamble

   The GNU General Public License is a free, copyleft license for
 software and other kinds of works.

   The licenses for most software and other practical works are designed
 to take away your freedom to share and change the works.  By contrast,
 the GNU General Public License is intended to guarantee your freedom to
 share and change all versions of a program--to make sure it remains free
 software for all its users.  We, the Free Software Foundation, use the
 GNU General Public License for most of our software; it applies also to
 any other work released this way by its authors.  You can apply it to
 your programs, too.

   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
 them if you wish), that you receive source code or can get it if you
 want it, that you can change the software or use pieces of it in new
 free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
 these rights or asking you to surrender the rights.  Therefore, you have
 certain responsibilities if you distribute copies of the software, or if
 you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
 gratis or for a fee, you must pass on to the recipients the same
 freedoms that you received.  You must make sure that they, too, receive
 or can get the source code.  And you must show them these terms so they
 know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
 (1) assert copyright on the software, and (2) offer you this License
 giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
 that there is no warranty for this free software.  For both users' and
 authors' sake, the GPL requires that modified versions be marked as
 changed, so that their problems will not be attributed erroneously to
 authors of previous versions.

   Some devices are designed to deny users access to install or run
 modified versions of the software inside them, although the manufacturer
 can do so.  This is fundamentally incompatible with the aim of
 protecting users' freedom to change the software.  The systematic
 pattern of such abuse occurs in the area of products for individuals to
 use, which is precisely where it is most unacceptable.  Therefore, we
 have designed this version of the GPL to prohibit the practice for those
 products.  If such problems arise substantially in other domains, we
 stand ready to extend this provision to those domains in future versions
 of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
 States should not allow patents to restrict development and use of
 software on general-purpose computers, but in those that do, we wish to
 avoid the special danger that patents applied to a free program could
 make it effectively proprietary.  To prevent this, the GPL assures that
 patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
 modification follow.

                        TERMS AND CONDITIONS

   0. Definitions.

   "This License" refers to version 3 of the GNU General Public License.

   "Copyright" also means copyright-like laws that apply to other kinds of
 works, such as semiconductor masks.

   "The Program" refers to any copyrightable work licensed under this
 License.  Each licensee is addressed as "you".  "Licensees" and
 "recipients" may be individuals or organizations.

   To "modify" a work means to copy from or adapt all or part of the work
 in a fashion requiring copyright permission, other than the making of an
 exact copy.  The resulting work is called a "modified version" of the
 earlier work or a work "based on" the earlier work.

   A "covered work" means either the unmodified Program or a work based
 on the Program.

   To "propagate" a work means to do anything with it that, without
 permission, would make you directly or secondarily liable for
 infringement under applicable copyright law, except executing it on a
 computer or modifying a private copy.  Propagation includes copying,
 distribution (with or without modification), making available to the
 public, and in some countries other activities as well.

   To "convey" a work means any kind of propagation that enables other
 parties to make or receive copies.  Mere interaction with a user through
 a computer network, with no transfer of a copy, is not conveying.

   An interactive user interface displays "Appropriate Legal Notices"
 to the extent that it includes a convenient and prominently visible
 feature that (1) displays an appropriate copyright notice, and (2)
 tells the user that there is no warranty for the work (except to the
 extent that warranties are provided), that licensees may convey the
 work under this License, and how to view a copy of this License.  If
 the interface presents a list of user commands or options, such as a
 menu, a prominent item in the list meets this criterion.

   1. Source Code.

   The "source code" for a work means the preferred form of the work
 for making modifications to it.  "Object code" means any non-source
 form of a work.

   A "Standard Interface" means an interface that either is an official
 standard defined by a recognized standards body, or, in the case of
 interfaces specified for a particular programming language, one that
 is widely used among developers working in that language.

   The "System Libraries" of an executable work include anything, other
 than the work as a whole, that (a) is included in the normal form of
 packaging a Major Component, but which is not part of that Major
 Component, and (b) serves only to enable use of the work with that
 Major Component, or to implement a Standard Interface for which an
 implementation is available to the public in source code form.  A
 "Major Component", in this context, means a major essential component
 (kernel, window system, and so on) of the specific operating system
 (if any) on which the executable work runs, or a compiler used to
 produce the work, or an object code interpreter used to run it.

   The "Corresponding Source" for a work in object code form means all
 the source code needed to generate, install, and (for an executable
 work) run the object code and to modify the work, including scripts to
 control those activities.  However, it does not include the work's
 System Libraries, or general-purpose tools or generally available free
 programs which are used unmodified in performing those activities but
 which are not part of the work.  For example, Corresponding Source
 includes interface definition files associated with source files for
 the work, and the source code for shared libraries and dynamically
 linked subprograms that the work is specifically designed to require,
 such as by intimate data communication or control flow between those
 subprograms and other parts of the work.

   The Corresponding Source need not include anything that users
 can regenerate automatically from other parts of the Corresponding
 Source.

   The Corresponding Source for a work in source code form is that
 same work.

   2. Basic Permissions.

   All rights granted under this License are granted for the term of
 copyright on the Program, and are irrevocable provided the stated
 conditions are met.  This License explicitly affirms your unlimited
 permission to run the unmodified Program.  The output from running a
 covered work is covered by this License only if the output, given its
 content, constitutes a covered work.  This License acknowledges your
 rights of fair use or other equivalent, as provided by copyright law.

   You may make, run and propagate covered works that you do not
 convey, without conditions so long as your license otherwise remains
 in force.  You may convey covered works to others for the sole purpose
 of having them make modifications exclusively for you, or provide you
 with facilities for running those works, provided that you comply with
 the terms of this License in conveying all material for which you do
 not control copyright.  Those thus making or running the covered works
 for you must do so exclusively on your behalf, under your direction
 and control, on terms that prohibit them from making any copies of
 your copyrighted material outside their relationship with you.

   Conveying under any other circumstances is permitted solely under
 the conditions stated below.  Sublicensing is not allowed; section 10
 makes it unnecessary.

   3. Protecting Users' Legal Rights From Anti-Circumvention Law.

   No covered work shall be deemed part of an effective technological
 measure under any applicable law fulfilling obligations under article
 11 of the WIPO copyright treaty adopted on 20 December 1996, or
 similar laws prohibiting or restricting circumvention of such
 measures.

   When you convey a covered work, you waive any legal power to forbid
 circumvention of technological measures to the extent such circumvention
 is effected by exercising rights under this License with respect to
 the covered work, and you disclaim any intention to limit operation or
 modification of the work as a means of enforcing, against the work's
 users, your or third parties' legal rights to forbid circumvention of
 technological measures.

   4. Conveying Verbatim Copies.

   You may convey verbatim copies of the Program's source code as you
 receive it, in any medium, provided that you conspicuously and
 appropriately publish on each copy an appropriate copyright notice;
 keep intact all notices stating that this License and any
 non-permissive terms added in accord with section 7 apply to the code;
 keep intact all notices of the absence of any warranty; and give all
 recipients a copy of this License along with the Program.

   You may charge any price or no price for each copy that you convey,
 and you may offer support or warranty protection for a fee.

   5. Conveying Modified Source Versions.

   You may convey a work based on the Program, or the modifications to
 produce it from the Program, in the form of source code under the
 terms of section 4, provided that you also meet all of these conditions:

     a) The work must carry prominent notices stating that you modified
     it, and giving a relevant date.

     b) The work must carry prominent notices stating that it is
     released under this License and any conditions added under section
     7.  This requirement modifies the requirement in section 4 to
     "keep intact all notices".

     c) You must license the entire work, as a whole, under this
     License to anyone who comes into possession of a copy.  This
     License will therefore apply, along with any applicable section 7
     additional terms, to the whole of the work, and all its parts,
     regardless of how they are packaged.  This License gives no
     permission to license the work in any other way, but it does not
     invalidate such permission if you have separately received it.

     d) If the work has interactive user interfaces, each must display
     Appropriate Legal Notices; however, if the Program has interactive
     interfaces that do not display Appropriate Legal Notices, your
     work need not make them do so.

   A compilation of a covered work with other separate and independent
 works, which are not by their nature extensions of the covered work,
 and which are not combined with it such as to form a larger program,
 in or on a volume of a storage or distribution medium, is called an
 "aggregate" if the compilation and its resulting copyright are not
 used to limit the access or legal rights of the compilation's users
 beyond what the individual works permit.  Inclusion of a covered work
 in an aggregate does not cause this License to apply to the other
 parts of the aggregate.

   6. Conveying Non-Source Forms.

   You may convey a covered work in object code form under the terms
 of sections 4 and 5, provided that you also convey the
 machine-readable Corresponding Source under the terms of this License,
 in one of these ways:

     a) Convey the object code in, or embodied in, a physical product
     (including a physical distribution medium), accompanied by the
     Corresponding Source fixed on a durable physical medium
     customarily used for software interchange.

     b) Convey the object code in, or embodied in, a physical product
     (including a physical distribution medium), accompanied by a
     written offer, valid for at least three years and valid for as
     long as you offer spare parts or customer support for that product
     model, to give anyone who possesses the object code either (1) a
     copy of the Corresponding Source for all the software in the
     product that is covered by this License, on a durable physical
     medium customarily used for software interchange, for a price no
     more than your reasonable cost of physically performing this
     conveying of source, or (2) access to copy the
     Corresponding Source from a network server at no charge.

     c) Convey individual copies of the object code with a copy of the
     written offer to provide the Corresponding Source.  This
     alternative is allowed only occasionally and noncommercially, and
     only if you received the object code with such an offer, in accord
     with subsection 6b.

     d) Convey the object code by offering access from a designated
     place (gratis or for a charge), and offer equivalent access to the
     Corresponding Source in the same way through the same place at no
     further charge.  You need not require recipients to copy the
     Corresponding Source along with the object code.  If the place to
     copy the object code is a network server, the Corresponding Source
     may be on a different server (operated by you or a third party)
     that supports equivalent copying facilities, provided you maintain
     clear directions next to the object code saying where to find the
     Corresponding Source.  Regardless of what server hosts the
     Corresponding Source, you remain obligated to ensure that it is
     available for as long as needed to satisfy these requirements.

     e) Convey the object code using peer-to-peer transmission, provided
     you inform other peers where the object code and Corresponding
     Source of the work are being offered to the general public at no
     charge under subsection 6d.

   A separable portion of the object code, whose source code is excluded
 from the Corresponding Source as a System Library, need not be
 included in conveying the object code work.

   A "User Product" is either (1) a "consumer product", which means any
 tangible personal property which is normally used for personal, family,
 or household purposes, or (2) anything designed or sold for incorporation
 into a dwelling.  In determining whether a product is a consumer product,
 doubtful cases shall be resolved in favor of coverage.  For a particular
 product received by a particular user, "normally used" refers to a
 typical or common use of that class of product, regardless of the status
 of the particular user or of the way in which the particular user
 actually uses, or expects or is expected to use, the product.  A product
 is a consumer product regardless of whether the product has substantial
 commercial, industrial or non-consumer uses, unless such uses represent
 the only significant mode of use of the product.

   "Installation Information" for a User Product means any methods,
 procedures, authorization keys, or other information required to install
 and execute modified versions of a covered work in that User Product from
 a modified version of its Corresponding Source.  The information must
 suffice to ensure that the continued functioning of the modified object
 code is in no case prevented or interfered with solely because
 modification has been made.

   If you convey an object code work under this section in, or with, or
 specifically for use in, a User Product, and the conveying occurs as
 part of a transaction in which the right of possession and use of the
 User Product is transferred to the recipient in perpetuity or for a
 fixed term (regardless of how the transaction is characterized), the
 Corresponding Source conveyed under this section must be accompanied
 by the Installation Information.  But this requirement does not apply
 if neither you nor any third party retains the ability to install
 modified object code on the User Product (for example, the work has
 been installed in ROM).

   The requirement to provide Installation Information does not include a
 requirement to continue to provide support service, warranty, or updates
 for a work that has been modified or installed by the recipient, or for
 the User Product in which it has been modified or installed.  Access to a
 network may be denied when the modification itself materially and
 adversely affects the operation of the network or violates the rules and
 protocols for communication across the network.

   Corresponding Source conveyed, and Installation Information provided,
 in accord with this section must be in a format that is publicly
 documented (and with an implementation available to the public in
 source code form), and must require no special password or key for
 unpacking, reading or copying.

   7. Additional Terms.

   "Additional permissions" are terms that supplement the terms of this
 License by making exceptions from one or more of its conditions.
 Additional permissions that are applicable to the entire Program shall
 be treated as though they were included in this License, to the extent
 that they are valid under applicable law.  If additional permissions
 apply only to part of the Program, that part may be used separately
 under those permissions, but the entire Program remains governed by
 this License without regard to the additional permissions.

   When you convey a copy of a covered work, you may at your option
 remove any additional permissions from that copy, or from any part of
 it.  (Additional permissions may be written to require their own
 removal in certain cases when you modify the work.)  You may place
 additional permissions on material, added by you to a covered work,
 for which you have or can give appropriate copyright permission.

   Notwithstanding any other provision of this License, for material you
 add to a covered work, you may (if authorized by the copyright holders of
 that material) supplement the terms of this License with terms:

     a) Disclaiming warranty or limiting liability differently from the
     terms of sections 15 and 16 of this License; or

     b) Requiring preservation of specified reasonable legal notices or
     author attributions in that material or in the Appropriate Legal
     Notices displayed by works containing it; or

     c) Prohibiting misrepresentation of the origin of that material, or
     requiring that modified versions of such material be marked in
     reasonable ways as different from the original version; or

     d) Limiting the use for publicity purposes of names of licensors or
     authors of the material; or

     e) Declining to grant rights under trademark law for use of some
     trade names, trademarks, or service marks; or

     f) Requiring indemnification of licensors and authors of that
     material by anyone who conveys the material (or modified versions of
     it) with contractual assumptions of liability to the recipient, for
     any liability that these contractual assumptions directly impose on
     those licensors and authors.

   All other non-permissive additional terms are considered "further
 restrictions" within the meaning of section 10.  If the Program as you
 received it, or any part of it, contains a notice stating that it is
 governed by this License along with a term that is a further
 restriction, you may remove that term.  If a license document contains
 a further restriction but permits relicensing or conveying under this
 License, you may add to a covered work material governed by the terms
 of that license document, provided that the further restriction does
 not survive such relicensing or conveying.

   If you add terms to a covered work in accord with this section, you
 must place, in the relevant source files, a statement of the
 additional terms that apply to those files, or a notice indicating
 where to find the applicable terms.

   Additional terms, permissive or non-permissive, may be stated in the
 form of a separately written license, or stated as exceptions;
 the above requirements apply either way.

   8. Termination.

   You may not propagate or modify a covered work except as expressly
 provided under this License.  Any attempt otherwise to propagate or
 modify it is void, and will automatically terminate your rights under
 this License (including any patent licenses granted under the third
 paragraph of section 11).

   However, if you cease all violation of this License, then your
 license from a particular copyright holder is reinstated (a)
 provisionally, unless and until the copyright holder explicitly and
 finally terminates your license, and (b) permanently, if the copyright
 holder fails to notify you of the violation by some reasonable means
 prior to 60 days after the cessation.

   Moreover, your license from a particular copyright holder is
 reinstated permanently if the copyright holder notifies you of the
 violation by some reasonable means, this is the first time you have
 received notice of violation of this License (for any work) from that
 copyright holder, and you cure the violation prior to 30 days after
 your receipt of the notice.

   Termination of your rights under this section does not terminate the
 licenses of parties who have received copies or rights from you under
 this License.  If your rights have been terminated and not permanently
 reinstated, you do not qualify to receive new licenses for the same
 material under section 10.

   9. Acceptance Not Required for Having Copies.

   You are not required to accept this License in order to receive or
 run a copy of the Program.  Ancillary propagation of a covered work
 occurring solely as a consequence of using peer-to-peer transmission
 to receive a copy likewise does not require acceptance.  However,
 nothing other than this License grants you permission to propagate or
 modify any covered work.  These actions infringe copyright if you do
 not accept this License.  Therefore, by modifying or propagating a
 covered work, you indicate your acceptance of this License to do so.

   10. Automatic Licensing of Downstream Recipients.

   Each time you convey a covered work, the recipient automatically
 receives a license from the original licensors, to run, modify and
 propagate that work, subject to this License.  You are not responsible
 for enforcing compliance by third parties with this License.

   An "entity transaction" is a transaction transferring control of an
 organization, or substantially all assets of one, or subdividing an
 organization, or merging organizations.  If propagation of a covered
 work results from an entity transaction, each party to that
 transaction who receives a copy of the work also receives whatever
 licenses to the work the party's predecessor in interest had or could
 give under the previous paragraph, plus a right to possession of the
 Corresponding Source of the work from the predecessor in interest, if
 the predecessor has it or can get it with reasonable efforts.

   You may not impose any further restrictions on the exercise of the
 rights granted or affirmed under this License.  For example, you may
 not impose a license fee, royalty, or other charge for exercise of
 rights granted under this License, and you may not initiate litigation
 (including a cross-claim or counterclaim in a lawsuit) alleging that
 any patent claim is infringed by making, using, selling, offering for
 sale, or importing the Program or any portion of it.

   11. Patents.

   A "contributor" is a copyright holder who authorizes use under this
 License of the Program or a work on which the Program is based.  The
 work thus licensed is called the contributor's "contributor version".

   A contributor's "essential patent claims" are all patent claims
 owned or controlled by the contributor, whether already acquired or
 hereafter acquired, that would be infringed by some manner, permitted
 by this License, of making, using, or selling its contributor version,
 but do not include claims that would be infringed only as a
 consequence of further modification of the contributor version.  For
 purposes of this definition, "control" includes the right to grant
 patent sublicenses in a manner consistent with the requirements of
 this License.

   Each contributor grants you a non-exclusive, worldwide, royalty-free
 patent license under the contributor's essential patent claims, to
 make, use, sell, offer for sale, import and otherwise run, modify and
 propagate the contents of its contributor version.

   In the following three paragraphs, a "patent license" is any express
 agreement or commitment, however denominated, not to enforce a patent
 (such as an express permission to practice a patent or covenant not to
 sue for patent infringement).  To "grant" such a patent license to a
 party means to make such an agreement or commitment not to enforce a
 patent against the party.

   If you convey a covered work, knowingly relying on a patent license,
 and the Corresponding Source of the work is not available for anyone
 to copy, free of charge and under the terms of this License, through a
 publicly available network server or other readily accessible means,
 then you must either (1) cause the Corresponding Source to be so
 available, or (2) arrange to deprive yourself of the benefit of the
 patent license for this particular work, or (3) arrange, in a manner
 consistent with the requirements of this License, to extend the patent
 license to downstream recipients.  "Knowingly relying" means you have
 actual knowledge that, but for the patent license, your conveying the
 covered work in a country, or your recipient's use of the covered work
 in a country, would infringe one or more identifiable patents in that
 country that you have reason to believe are valid.

   If, pursuant to or in connection with a single transaction or
 arrangement, you convey, or propagate by procuring conveyance of, a
 covered work, and grant a patent license to some of the parties
 receiving the covered work authorizing them to use, propagate, modify
 or convey a specific copy of the covered work, then the patent license
 you grant is automatically extended to all recipients of the covered
 work and works based on it.

   A patent license is "discriminatory" if it does not include within
 the scope of its coverage, prohibits the exercise of, or is
 conditioned on the non-exercise of one or more of the rights that are
 specifically granted under this License.  You may not convey a covered
 work if you are a party to an arrangement with a third party that is
 in the business of distributing software, under which you make payment
 to the third party based on the extent of your activity of conveying
 the work, and under which the third party grants, to any of the
 parties who would receive the covered work from you, a discriminatory
 patent license (a) in connection with copies of the covered work
 conveyed by you (or copies made from those copies), or (b) primarily
 for and in connection with specific products or compilations that
 contain the covered work, unless you entered into that arrangement,
 or that patent license was granted, prior to 28 March 2007.

   Nothing in this License shall be construed as excluding or limiting
 any implied license or other defenses to infringement that may
 otherwise be available to you under applicable patent law.

   12. No Surrender of Others' Freedom.

   If conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
 excuse you from the conditions of this License.  If you cannot convey a
 covered work so as to satisfy simultaneously your obligations under this
 License and any other pertinent obligations, then as a consequence you may
 not convey it at all.  For example, if you agree to terms that obligate you
 to collect a royalty for further conveying from those to whom you convey
 the Program, the only way you could satisfy both those terms and this
 License would be to refrain entirely from conveying the Program.

   13. Use with the GNU Affero General Public License.

   Notwithstanding any other provision of this License, you have
 permission to link or combine any covered work with a work licensed
 under version 3 of the GNU Affero General Public License into a single
 combined work, and to convey the resulting work.  The terms of this
 License will continue to apply to the part which is the covered work,
 but the special requirements of the GNU Affero General Public License,
 section 13, concerning interaction through a network will apply to the
 combination as such.

   14. Revised Versions of this License.

   The Free Software Foundation may publish revised and/or new versions of
 the GNU General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.

   Each version is given a distinguishing version number.  If the
 Program specifies that a certain numbered version of the GNU General
 Public License "or any later version" applies to it, you have the
 option of following the terms and conditions either of that numbered
 version or of any later version published by the Free Software
 Foundation.  If the Program does not specify a version number of the
 GNU General Public License, you may choose any version ever published
 by the Free Software Foundation.

   If the Program specifies that a proxy can decide which future
 versions of the GNU General Public License can be used, that proxy's
 public statement of acceptance of a version permanently authorizes you
 to choose that version for the Program.

   Later license versions may give you additional or different
 permissions.  However, no additional obligations are imposed on any
 author or copyright holder as a result of your choosing to follow a
 later version.

   15. Disclaimer of Warranty.

   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
 HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
 OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
 THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
 IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
 ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

   16. Limitation of Liability.

   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
 THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
 DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
 PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGES.

   17. Interpretation of Sections 15 and 16.

   If the disclaimer of warranty and limitation of liability provided
 above cannot be given local legal effect according to their terms,
 reviewing courts shall apply local law that most closely approximates
 an absolute waiver of all civil liability in connection with the
 Program, unless a warranty or assumption of liability accompanies a
 copy of the Program in return for a fee.

                      END OF TERMS AND CONDITIONS

             How to Apply These Terms to Your New Programs

   If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
 free software which everyone can redistribute and change under these terms.

   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.

     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

 Also add information on how to contact you by electronic and paper mail.

   If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:

     <program>  Copyright (C) <year>  <name of author>
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

 The hypothetical commands `show w' and `show c' should show the appropriate
 parts of the General Public License.  Of course, your program's commands
 might be different; for a GUI interface, you would use an "about box".

   You should also get your employer (if you work as a programmer) or school,
 if any, to sign a "copyright disclaimer" for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL, see
 <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
 <http://www.gnu.org/philosophy/why-not-lgpl.html>.

=cut

####### Imports
#
# We want everything required for aimake to run to be contained in this single
# file, apart from the Perl distribution itself (which is obviously required
# to be able to run it). As such, only modules that ship with Perl are legal
# here. Additionally, in order to keep as much portability as possible, we aim
# for compatibility with old Perl versions. The oldest supported version is
# 5.10, based on which modules we need and on the hope that 5.8 died out in
# the past few years. There's a list of which modules shipped with which
# versions in Module::CoreList.  (Additionally, avoid modules that were
# removed or deprecated in later versions.)
use 5.010;

use Getopt::Std qw/getopts/;
use File::Path qw/make_path/;
use File::Spec ();
use File::Temp qw/tempfile/;
use File::Find qw/finddepth/;
use File::Copy ();
use Cwd qw/cwd realpath/;
use Fcntl qw/:DEFAULT :flock :seek/;
use FindBin qw'$RealBin $RealScript';
use ExtUtils::MakeMaker;
use Time::HiRes ();
use Memoize;
use Carp;
use Config;
use Getopt::Long;
use Pod::Usage qw/pod2usage/;
use POSIX qw/sigprocmask SIG_SETMASK/;
use PerlIO;
use PerlIO::encoding;
use Encode qw/encode :fallbacks/;
use Data::Dumper;
use Digest::SHA qw/sha1_hex sha256_hex/;
use Scalar::Util qw/refaddr/;
use Safe;
use Storable qw/store_fd fd_retrieve dclone/; # why the naming inconsistency?
use warnings FATAL => qw/recursion/; # crashes with backtraces > infinite loops
my $win32_available;
my $win32_exe_available;
BEGIN {
    eval {
        require Win32;
        Win32->import;
        $win32_available = 1;
    };
    eval {
        require Win32::Exe;
        Win32::Exe->import;
        $win32_exe_available = 1;
    };
}

####### Global variables and constants

use constant configfilename => 'path:aimake.rules';
use constant localconfigfilename => 'path:aimake.local';
use constant statefilename => 'bpath:aimake.objects';

select STDERR;
$| = 1;
select STDOUT;

my ($opt_verbose, $opt_install, $opt_prefix, $opt_dump, @opt_warnings,
    $opt_ignore_builtin_config, $opt_version, $opt_dlayout, $opt_config_only,
    $opt_install_only, $opt_elevate_permissions, $opt_specific_exit_status,
    @opt_with, @opt_without, @opt_with_default, $opt_nonempty_directory,
    %opt_directory_overrides, $opt_nocr, @opt_rebuild, $opt_documentation,
    $opt_gen_installer, %opt_var, $opt_profile, $opt_no_sanity_checks,
    $opt_license, $opt_filelist, $opt_noperms, @opt_local_config); # options
my ($codeset, $text_layers, $binary_layers,
    $utf8_layers, $ascii_layers); # encodings
my ($path, $bpath, $ipath, $singledir); # important paths
our ($cwd, $oscwd);                     # current directories (often local-ed)
my $installing;                   # mode of operation
my %config_hashes = ();           # configuration
my ($state, $state_fh, $config);  # state and configuration handling
my $errorexit = 1;                # for --specific-exit-status
my %rule_object_prefixes = ();    # an optimization on rules_that_apply_to
our $os_parsed = $^O;
$os_parsed eq 'msys' and $os_parsed = "MSWin32";

# a UUID generated for the purpose of avoiding clashes with other things
our $longrandomstring = 'AIMAKE_e15d5ce8_c8f0_40c9_9a3f_3b568bcd59d5_';

####### Subroutines

##### Portability

### Backwards compatibility for old perl versions
#
# The // operator was introduced in Perl 5.10, so here's a function that
# does the same thing.
sub defined_or { defined $_[0] and return $_[0]; return $_[1]; }

### OS independence for symlinking
sub ai_symlink ($$) {
    my $rv;
    my $rv_valid = 0;
    eval {
        $rv = symlink $_[0], $_[1];
        $rv_valid = 1;
    };
    $rv_valid and return $rv;
    # "symlink" doesn't exist; copy the file instead
    open my $fhfrom, "<$binary_layers", $_[0]
        or return 0;
    open my $fhto, ">$binary_layers", $_[1]
        or return 0;
    print $fhto $_ for <$fhfrom>;
    close $fhfrom; close $fhto;
    -x $_[0] and return chmod 0755, $_[1];
    return 1;
}

##### Progress reporting
sub run_command;
{
    my $colwidth = undef;
    my $last_report_msg = '';
    # There's no portable way to determine the screen width, but
    # we can do it via tput if tput exists. Otherwise, 80 is a
    # reasonable guess.
    sub screenwidth {
        my $failreason;
        $colwidth and return $colwidth;
        ($failreason, $colwidth) =
            run_command "cmd:tput", "optstring:cols", \ "nostderr"
            and !$failreason and return $colwidth;
        $colwidth = 80; return $colwidth;
    }
    sub print_stderr_tl {
        # Calling binmode on stderr makes all redirects on it slower, for the
        # rest of the program, leading to quadratic performance. So we do
        # things the old-fashioned way instead.
        my $msg = shift;
        $msg = encode($codeset, $msg);
        print STDERR $msg;
    }
    sub progress_report {
        my $level = shift;
        my $str = shift;
        if ($level <= $opt_verbose && !$opt_nocr) {
            # We may have to clear the line the old-fashioned way.
            print_stderr_tl (' ' x (length defined_or($last_report_msg,"")) .
                             "\r");
            $last_report_msg = '';
        }
        my $ldiff = (length $str) - length defined_or($last_report_msg,"");
        $ldiff < 0 and $str .= ' ' x -$ldiff;
        if ($level <= $opt_verbose + 0.5 && $level > $opt_verbose
            && $level < 3 && !$opt_nocr) {
            $str = substr $str, 0, screenwidth() - 1;
            print_stderr_tl "$str\r";
            $str =~ s/ +$//;
            $last_report_msg = $str;
        } elsif ($level <= $opt_verbose) {
            print_stderr_tl "$str\n";
            $last_report_msg = '';
        }
        return 1;
    }
}

##### Generic utilities

### String pooling
#
# We map strings to integers because there are many repeated uses of strings in
# the state file, and this uses up an enormous amount of memory (enough that the
# compile causes swapping in some cases). The mapping is stored in the
# statefile; thus these functions need to be guarded with atomically{} /
# atomic_read{} respectively.

my %unintern;
sub intern ($) {
    my $i = $state->{_intern}{$_[0]};
    $i and return $i;
    # Note: start _intern_number high enough that it doesn't interfere with, say,
    # the use of 1 as a boolean
    $i = $state->{_intern_number} = defined_or($state->{_intern_number}, 100) + 1;
    $state->{_intern}{$_[0]} = $i;
    $unintern{$i} = $_[0];
    return $i;
}
sub unintern ($) {
    return $unintern{$_[0]};
}

# Note: modifies the first argument in-place exploiting @_ alias behaviour
# A little obscure, but easier to read than the other versions I tried
sub recursive_unintern;
sub recursive_unintern {
    defined $_[0] or return;
    if (!ref $_[0]) {
        my $u = unintern $_[0];
        defined $u and $_[0] = $u;
    } elsif (ref $_[0] eq 'ARRAY') {
        recursive_unintern $_ for @{$_[0]};
    } elsif (ref $_[0] eq 'HASH') {
        for my $k (keys %{$_[0]}) {
            recursive_unintern $_[0]{$k};
            my $u = unintern $k;
            if (defined $u) {
                $_[0]{$u} = $_[0]{$k};
                delete $_[0]{$k};
            }
        }
    }
}


# We don't want the statefile to grow indefinitely due to unused strings. So
# find unused strings, and remove them from _intern. This is done by copying
# all the strings that are actually used to a new array.
#
# This is a conservative garbage collection, so it can leave numbers floating
# around if they're used both as strings and as non-strings. This is mostly
# safe; aimake doesn't typically use numbers, except for 1 to mean "true", and
# timestamps (which are all in the billions).
#
# The algorithm used here clobbers %unintern.  This is safe for all current
# uses of garbage_collect_statefile, but bear it in mind for other potential
# uses.
sub collect_used_numbers;
sub collect_used_numbers {
    my $sv = shift;
    return unless defined $sv;

    my $new = shift;

    if (ref $sv) {
        my $seen = shift;

        $seen->{refaddr $sv} and return;
        $seen->{refaddr $sv} = 1;

        if (ref $sv eq 'HASH') {
            while (my ($k, $v) = each %$sv) {
                $k eq '_intern' and next;
                exists $unintern{$k} and $new->{$unintern{$k}} = $k;
                delete $unintern{$k};
                collect_used_numbers $v, $new, $seen;
            }
        } elsif (ref $sv eq 'ARRAY') {
            collect_used_numbers $_, $new, $seen for @$sv;
        }
    } else {
        exists $unintern{$sv} and $new->{$unintern{$sv}} = $sv;
        delete $unintern{$sv};
    }
}
sub garbage_collect_statefile {
    my $newintern = {};

    collect_used_numbers $state, $newintern, {};

    $state->{_intern} = $newintern;
}

### Scalar manipulation

# Deep compare on two scalars (a bit like a deep copy); returns true if they
# are copies of each other (deep, shallow, or in between).  $omitting can be
# a regex that specifies hash keys that are considered to be irrelevant for
# the purposes of the comparison.
sub deepequals {
    my $x1 = shift;
    my $x2 = shift;
    my $omitting = shift;
    !defined $x1 and return !defined $x2;
    !defined $x2 and return;
    !ref $x1 && !ref $x2 and return $x1 eq $x2; # neither is a reference
    !ref $x1 || !ref $x2 and return; # one is a reference, the other isn't
    ref $x1 ne ref $x2 and return; # they're different types of reference
    ref $x1 eq 'SCALAR' and return deepequals($$x1, $$x2, $omitting);
    if (ref $x1 eq 'ARRAY') {
        return unless $#$x1 == $#$x2;
        deepequals($x1->[$_], $x2->[$_], $omitting) or return for 0..$#$x1;
        return 1;
    }
    if (ref $x1 eq 'HASH') {
        my @keys1 = sort grep {!$omitting || !/$omitting/} keys %$x1;
        my @keys2 = sort grep {!$omitting || !/$omitting/} keys %$x2;
        return unless deepequals(\@keys1, \@keys2, $omitting);
        deepequals($x1->{$_}, $x2->{$_}) or return for @keys1;
        return 1;
    }
    die "Cannot compare references of type '" . ref $x1 . "'";
}

# Deep clone of a scalar. Like the standard dclone(), except it doesn't
# attempt to clone regular expressions (dclone() tries and fails).
sub deepclone {
    my $x1 = shift;
    if (ref $x1 eq 'ARRAY') {
        return [map deepclone($_), @$x1];
    }
    if (ref $x1 eq 'HASH') {
        my $x2 = {};
        $x2->{$_} = deepclone($x1->{$_}) for keys %$x1;
        return $x2;
    }
    return $x1;
}

# Hashing arbitrary scalars.
sub serialize_sv {
    my $sv = shift;
    defined $sv or return 'u';
    # Make sure we're always using the string version of $sv.
    ref $sv or return "s" . (length "$sv") . " $sv";
    (ref $sv) =~ /\bRegexp$/ and return "r" . (length "$sv") . " $sv";
    if (ref $sv eq 'ARRAY') {
        my $x = "a" . scalar @$sv . " ";
        $x .= serialize_sv($_) for @$sv;
        return $x;
    }
    if (ref $sv eq 'HASH') {
        my @keys = sort keys %$sv;
        my $x = "h" . scalar @keys. " ";
        $x .= serialize_sv($_). serialize_sv($sv->{$_}) for @keys;
        return $x;
    }
    die "serialize_sv called on unsupported SV " . Dumper($sv);
}
sub sv_hash {
    return sha256_hex(serialize_sv(shift));
}

# Convert a string to a GUID (actually UUID), using the algorithm from RFC 4122.
sub guid_from_string {
    my $guid = uc sha1_hex (
        # This magic hex string means "treat the rest of the string as a URL".
        "\x6b\xa7\xb8\x11\x9d\xad\x11\xd1\x80\xb4\x00\xc0\x4f\xd4\x30\xc8" .
        # We use a namespace inside the aimake website for uniqueness.
        "http://nethack4.org/aimake/uuid/" . shift);
    substr $guid, 32, 8, "";
    substr $guid, 20, 0, "-";
    (substr $guid, 16, 1) =~ y/0123456789ABCDEF/89AB89AB89AB89AB/;
    substr $guid, 16, 0, "-";
    substr $guid, 12, 1, "5"; # means "this UUID is SHA-1 based".
    substr $guid, 12, 0, "-";
    substr $guid, 8, 0, "-";
    return $guid;
}

# Escaping appropriately for C.
sub quoted_c_string {
    my $string = shift;
    $string =~ s{([^ -~]|\\)}{$1 eq '\\' ? "\\\\" :
                              ord $1 < 128 ? sprintf "\\x%02x", ord $1 :
                              sprintf "\\u%04x", ord $1}eg;
    return "\"$string\"";
}

### Version number processing
#
# An aimake version number has any number of components, each of which are
# numbers, or "alpha"+number or "beta"+number. On some operating systems, we
# can directly convert this into something the OS's install toolchain
# understands. On others, we need a numerical version number; we can't
# /guarantee/ numerical ordering, but we can use very large numbers to do the
# right thing in the vast majority of cases.

sub pvtransform {
    my $vn = shift;

    if ($os_parsed eq 'MSWin32') {
        # Windows wants numeric components in the range 0 to 65535.
        my @vn = (split /\./, $vn);
        @vn > 1 or return $vn;
        for my $i (1 .. $#vn) {
            $vn[$i] =~ /^alpha(.*)$/ and @vn[$i-1,$i] = ($vn[$i-1]-1, 40000+$1);
            $vn[$i] =~ /^beta(.*)$/  and @vn[$i-1,$i] = ($vn[$i-1]-1, 50000+$1);
        }
        $vn = join '.', @vn;
    } elsif ($os_parsed eq 'linux') {
        # Debian's version number parser sorts '~' before even the null
        # string. This covers a decent propotion of Linux systems. TODO: check
        # how the version number parsers of other toolchains work; Red Hat's
        # is likely the second most used.
        $vn =~ s/\.(alpha|beta)/~$1/g;
    }

    return $vn;
}

### Profiling
my $last_profile_point = Time::HiRes::time();
my %profile_intervals;
sub charge_profiled_time_to {
    $opt_profile or return;

    my $new_profile_point = Time::HiRes::time();
    $profile_intervals{+shift} += $new_profile_point - $last_profile_point;
    $last_profile_point = $new_profile_point;
}

##### Object name handling
#
# All objects have an object type, and a value. Depending on the object type,
# they might also have an inner (nested) object. Some objects are produced,
# and some are provided.
my %objtype_nested = (
    path => 0, bpath => 0, spath => 0, extend => 1, file => 0, symbol => 0,
    direct_symbol => 0, shared_symbol => 0, symbolset => 1, symbol_in_object
    => 1, namehint => 1, config_option => 0, config_rule => 0, cmd => 0, tool
    => 0, intcmd => 0, optstring => 0, optpath => 1, optionset => 0, sys => 0,
    searchpath => 0, searchfile => 0, standardlib => 0, searchlib => 1,
    dependencies => 1, hash_on_disk => 1);
my %objtype_provided = (
    path => 0, bpath => 0, spath => 0, extend => 0, file => 1, symbol => 1,
    direct_symbol => 1, shared_symbol => 1, symbolset => 1, symbol_in_object
    => 1, namehint => 0, config_option => 0, config_rule => 0, cmd => 0, tool
    => 1, intcmd => 0, optstring => 0, optpath => 0, optionset => 1, sys => 0,
    searchpath => 1, searchfile => 1, standardlib => 0, searchlib => 1,
    dependencies => 1, hash_on_disk => 0);

# Some object types allow multiple interchangeable providers, in which
# case we merge the outdepends of each provider. This is done via a
# regex, rather than via parsing + a hash, because it's part of the
# inner loop.
use constant multiple_providers_ok_regex =>
    qr/^(?> s(?:earch(?:file|lib) |
             tandardlib |
             ymbolset |
             hared_symbol |
             path) |
            path |
            optionset |
            dependencies) : /x;

# Some object types don't act normally, and are just virtual. This is also
# done via regex; parsing the object name takes up over 6% of the program
# runtime for small dirty builds.
use constant objtype_is_special_regex =>
    qr/^(?> extend |
            namehint |
            cmd |
            intcmd |
            opt(?: string |
                   path) |
            sys |
            hash_on_disk)/x;

# Splits an object name into its components. If the second argument is true,
# don't worry about missing components.
sub parse_objname {
    my $objname = shift;
    # second argument is $relaxed, but we use it directly as $_[0] to save
    # shifting time in the usual case where it isn't needed
    $objname =~ /:/ or croak "Invalid object name $objname";
    # Normally we'd use m//p to extract the bits of the name before and after
    # the colon, but that doesn't work in 5.8, so replicate the behaviour
    # here.
    my $objtype = substr $objname, 0, $-[0];
    my $objvalue = substr $objname, $+[0];
    if ($objtype_nested{$objtype}) {
        unless ($objvalue =~ /:/) {
            $_[0] or croak "Invalid object content $objvalue";
            return ($objtype, $objvalue);
        }
        return ($objtype, (substr $objvalue, 0, $-[0]),
                (substr $objvalue, $+[0]));
    }
    return ($objtype, $objvalue);
}
# don't memoize; it's very slightly slower (40 microseconds, not 32)

# Splits a pair name into components. A pair name is "$rule $object".
sub parse_pairname {
    my $pairname = shift;
    $pairname =~ /^([^ ]+) (.*)$/s or
        croak "Invalid pair name '$pairname'";
    return ($1, $2);
}

# Returns the object name, or the rule name if the object is boring.
sub extract_interesting_pair_component {
    my ($rulename, $objname) = parse_pairname +shift;
    $objname ne 'sys:no_object' and return $objname;
    return $rulename;
}

# Resolve an extend: object. Other objects are returned unchanged.
# extend: objects are either used to find parent directories (value = ..), or
# used to construct filenames in the build directory (other values).
sub aipath_parent;
sub parse_aipath;
sub deparse_aipath;
sub resolve_extend;
sub resolve_extend {
    my $objname = shift;

    # Bail out quickly if there's no possible way this could do anything.
    $objname =~ /extend/ or return $objname;

    my ($objtype, $objvalue, $objinner) = parse_objname $objname;

    if ($objinner) {
        $objinner = resolve_extend $objinner;
        $objtype eq 'extend' or return "$objtype:$objvalue:$objinner";
    } else {
        $objtype eq 'extend' or return $objname;
    }

    $objvalue eq '..' and return aipath_parent $objinner;

    (undef, undef, $objinner) = parse_objname $objinner
        while $objinner =~ /^(?:symbolset|dependencies):/;

    if ($objvalue eq '/') {
        my @components = parse_aipath $objinner;
        $components[0] = 'bpath';
        push @components, $components[-1];
        return deparse_aipath @components;
    }

    if ($objvalue eq '...') {
        my @components = parse_aipath $objinner;
        return deparse_aipath 'bpath', $components[-1];
    }

    my @aipath = parse_aipath $objinner;
    # Remove any existing extension. It's OK if this doesn't match.
    $aipath[-1] =~ s/\.[^.]+//s;

    # Add all the path components from $objvalue to the end of @aipath,
    # merging the first component with the last component of $aipath.
    $objvalue = (pop @aipath) . $objvalue;
    push @aipath, $1 while $objvalue =~ m=((?:[^\\\/:]|\\.)*)( / | $ )=gsx;
    pop @aipath; # remove the trailing ''

    $aipath[0] = 'bpath';

    return deparse_aipath @aipath;
}

# Given a potentially incomplete reference to an object name, complete it if
# it actually is incomplete. Incomplete object names could be of any of the
# following formats:
# [the null string]
# type:
# type:value                [for nested types]
# type:value:
# type:value:incomplete_inner
# Complete object names could be either of these:
# type:value                [for non-nested types]
# type:value:complete_inner
sub objname_needs_completion;
sub objname_needs_completion {
    my $objname = shift;
    $objname eq '' and return 1;
    my ($objtype, $objvalue, $objinner) = parse_objname $objname, 1;
    $objtype_nested{$objtype} or return 0;
    if (defined $objinner && $objinner ne '') {
        return objname_needs_completion $objinner;
    } else {
        return defined $objinner ? 1 : 2;
    }
}
sub complete_objname {
    my $objname = shift;
    my $inner = shift;
    my $how_incomplete = objname_needs_completion $objname;
    $how_incomplete == 0 and return $objname;
    $how_incomplete == 1 and return "$objname$inner";
    $how_incomplete == 2 and return "$objname:$inner";
    die "objname_needs_completion returned an out-of-range value";
}
memoize('complete_objname');
sub complete_and_extend {
    my $onameref = shift;
    my $inner = shift;
    my $x = complete_objname $$onameref, $inner;
    $$onameref = resolve_extend $x;
}

# Constructs an object name in a form that's nice for users to read, even if
# it loses a bit of information. This means using their own native path format
# when possible (with relative paths to save space, and conflating the path
# and the bpath because it usually doesn't matter), removing extraneous
# metadata, etc.
sub aipath2ospath;
sub friendly_objname;
sub friendly_objname {
    return shift if $opt_verbose >= 4;

    my ($objtype, $objvalue, $objinner) =
        parse_objname (resolve_extend shift);

    # The bpath in the first case is correct; we conflate the path and bpath
    $objtype eq  'path' and return aipath2ospath "bpath:$objvalue", 'bpath:';
    $objtype eq 'bpath' and return aipath2ospath "bpath:$objvalue", 'bpath:';
    $objtype eq 'spath' and return aipath2ospath "spath:$objvalue";
    $objtype eq 'standardlib' and return aipath2ospath "spath:$objvalue";

    $objtype eq 'symbol'           and return $objvalue;
    $objtype eq 'symbol_in_object' and return $objvalue;

    defined $objinner and return "$objtype:$objvalue:$objinner";
    return "$objtype:$objvalue";
}

##### Path handling
#
# All internal calculations are done using aimake path format.
#
# Relative paths are specified as a slash-separated list of directory names,
# perhaps ending in a filename. Arbitrary characters are allowed inside
# directory and file names, but any slashes, backslashes, or colons are
# protected via preceding them with a backslash. The path format itself does
# not distinguish between files and directories, and contains no equivalent to
# . or .. (and as such cannot reach out above the directory the path is
# relative to). Likewise, aimake paths are case-sensitive regardless of the
# underlying filesystem; if running on a case-insensitive filesystem, they're
# forced to consistent case (foldcase if there's enough Unicode support
# available to do that, otherwise lowercase).
#
# Absolute paths are similar, but have one extra component at the start,
# specifying which root on the filesystem to use. This component is present no
# matter what the OS, but on OSes like UNIX that have a single root on their
# filesystem, it's the null string.
#
# aimake paths are only ever used as components of object names; as such,
# they're always preceded by an object type. Here are the object types that
# can be passed to these functions:
#
# bpath:[relative path]    A path relative to the build directory ($bpath)
# path:[relative path]     A path relative to the source directory ($path)
# spath:[absolute path]    An absolute path
#
# When outputting an aimake object name, the same object types are used (and
# also, in special cases, file:).
#
# There are other object types that conceptually represent files, like
# extend:, but those are too high-level to be passed to these low-level
# routines, and must be converted to [bs]?path:s first.

### Logical path manipulation

# The most important directories. Note that $bpath and $path are stored as
# spaths, contrary to normal practice; this is to avoid a circular definition.
# $path is set when parsing options.
sub ospath2aipath;

# Given an aimake path, splits it into components, unescaping them.
# The first component will be path/bpath/spath.
my $aipath_element = qr//s;
sub parse_aipath;
sub parse_aipath {
    my $aipath = shift;
    my ($objtype, $objvalue, $objinner) = parse_objname $aipath;
    $objtype =~ /^[bs]?path$/ or $objtype =~ 'standardlib' or
        croak "Invalid path type $objtype";
    my @aipath = ();
    push @aipath, $1 while $objvalue =~ m=((?:[^\\\/:]|\\.)*)( / | $ )=gsx;
    pop @aipath; # remove a null string at the end
    s/\\(.)/$1/gs for @aipath;
    return ($objtype, @aipath);
}

# Given the components of an aimake path, creates the path, via escaping them
# and adding appropriate separators. This is the inverse of parse_aipath.
sub deparse_aipath {
    my $objtype = shift;
    my @aipath = (@_);
    s/([\\\/:])/\\$1/gs for @aipath;
    return $objtype . ":" . join '/', @aipath;
}

# On Windows, there are various "known folders" which effectively act like
# extra roots for the filesystem, and aimake treats them as such.
my %spath_substitutions = ();
if ($win32_available) {
    for my $win32_constant (@Win32::EXPORT_OK) {
        if ($win32_constant =~ /^CSIDL_/) {
            my $csidl_location;
            {
                no strict 'refs';
                $csidl_location =
                    Win32::GetFolderPath(&{"Win32::$win32_constant"});
            }
            $csidl_location or next;
            $spath_substitutions{ospath2aipath $csidl_location, undef, 2} =
                "spath:$win32_constant";
        }
    }
}

$oscwd = cwd;
$bpath = ospath2aipath $oscwd, undef, 2;
$cwd = 'bpath:';

# Parsing an aimake path can be kind-of slow. Thus, we use a custom memoizer
# for aipath2ospath, which can remember the results of the reverse conversion
# (i.e. ospath2aipath) in addition to recording aipath2ospath results.
# Take care to record only absolute ospaths in the cache.
my %ospath_of_aipath_cache;

# Given a native OS path, returns the matching aimake path, as an object name.
#
# The OS path should typically be an absolute path. If no second argument is
# given, relative paths are taken to be relative to the current directory
# (typically $bpath). If some second argument is given, then relative paths
# are interpreted as files in some unknown location, and returned as file:
# objects; the second argument is just interpreted as a boolean. The third
# argument prevents path/bpath substitution if set to at least 1, and also
# spath substitution if set to 2; this is used to prevent circular
# dependencies.
sub ospath2aipath {
    my $ospath = shift;
    my $required_by = shift;
    my $force_spath = shift || 0;

    # If we're trying to convert a nonexistent path, we won't be able to
    # realpath it successfully. So we need an eval to trap errors.
    $ospath = eval {
        !defined $required_by || File::Spec->file_name_is_absolute($ospath)
            and realpath($ospath);
    } || $ospath;

    if (File::Spec->case_tolerant) {
        $ospath = defined_or(
            eval 'use feature ":5.16"; fc $ospath',
            lc $ospath);
    }

    if (File::Spec->file_name_is_absolute($ospath)) {
        my ($vol, $dirs, $file) = File::Spec->splitpath($ospath);
        my @dirs = File::Spec->splitdir($dirs);
        $dirs[0] eq File::Spec->rootdir and shift @dirs;
        my @aipath = ('spath', $vol, (grep {$_ ne ''} @dirs, $file));
        my $aipath = deparse_aipath @aipath;
        if (!$force_spath) {
            # A nice property of aimake spaths: if spath X contains spath Y,
            # then X is textually a prefix of Y. The bpath might be inside
            # the path, but not vice versa, so we check the bpath first.
            $aipath eq $bpath and $aipath = 'bpath:';
            $aipath =~ /^\Q$bpath\E\/(.*)$/ and $aipath = "bpath:$1";
            $path and $aipath eq $path and $aipath = 'path:';
            $path and $aipath =~ /^\Q$path\E\/(.*)$/ and $aipath = "path:$1";
        }
        if ($force_spath < 2) {
            # Check our list of substitutions and see if any apply. We want to
            # check the longest ones first; some may well be subdirectories of
            # others.
            for my $spath_substitution (sort { length $b <=> length $a }
                                        keys %spath_substitutions) {
                if ($aipath eq $spath_substitution ||
                    $aipath =~ /^\Q$spath_substitution\E\//) {
                    $aipath =~ s/^\Q$spath_substitution\E/
                        $spath_substitutions{$spath_substitution}/e;
                    last;
                }
            }
        }
        $ospath_of_aipath_cache{$aipath} = $ospath;
        return $aipath;
    } else {
        # Ignore the root: we can't make anything sensible of D:.. anyway
        my (undef, $dirs, $file) = File::Spec->splitpath($ospath);
        my @dirs = File::Spec->splitdir($dirs);
        my @aipath = (grep {$_ ne ''} 'file', @dirs, $file);
        return deparse_aipath @aipath;
    }
}

# Given an aimake path (as an object name), returns an equivalent filename (or
# directory name) that can be interpreted by the native operating system.
#
# This will typically be an absolute path regardless of the location of the
# aimake path. The second argument can be set to a directory (an aimake path)
# to instead attempt to produce a short path, by using a relative path to that
# path if possible (for simpler visual inspection, or because the filename is
# being recorded in an archive, or perhaps because the filename is going to be
# passed to a program that's expecting a specific name). Sensible values for
# $shorten are pretty much limited to undef, $bpath, and $cwd.
sub aipath2ospath {
    my $aipath = shift;
    my $shorten = shift;
    !$shorten and exists $ospath_of_aipath_cache{$aipath} and
        return $ospath_of_aipath_cache{$aipath};
    $shorten and $aipath eq $shorten and return File::Spec->curdir();
    $shorten and $shorten ne 'bpath:' and $shorten ne 'path:' and
        $shorten .= '/';
    if ($shorten && $aipath =~ /^\Q$shorten\E(.*)$/s) {
        # A relative path is requested and possible.
        my @aipath = parse_aipath "path:$1";
        shift @aipath; # remove the dummy "path:"
        # A bare filename/dirname with no path?
        scalar @aipath == 1 and return $aipath[0];
        # Otherwise, concatenate the path together. (File::Spec->catfile
        # requires at least two components to work correctly. Even then, it
        # assumes it's producing a file rather than a directory, but we don't
        # have enough information to tell otherwise.)
        return File::Spec->catfile(@aipath);
    } else {
        # An absolute path is requested, or necessary.
        # (Note that path: might not be set yet during system initialization,
        # due to the chicken-and-egg problem of the path depending on the
        # statefile and the statefile being in the bpath.)
        $aipath eq 'path:' and $aipath = $path;
        $aipath eq 'bpath:' and $aipath = $bpath;
        $path and $aipath =~ s=^path:=$path/=;
        $aipath =~ s=^bpath:=$bpath/=;

        $aipath =~ s=^standardlib:=spath:=;

        # Replace any spath substitutions with the actual path.
        while (my ($expanded, $short) = each %spath_substitutions) {
            if ($aipath eq $short || $aipath =~ /^\Q$short\E\//) {
                $aipath =~ s/^\Q$short\E/$expanded/;
            }
        }

        my (undef, $vol, @dirs) = parse_aipath $aipath; # ignore the spath:
        my $file = pop @dirs;
        unshift @dirs, File::Spec->rootdir;
        my $ospath = File::Spec->catpath($vol, File::Spec->catdir(@dirs), $file);
        $ospath_of_aipath_cache{$aipath} = $ospath;
        return $ospath;
    }
}

# Like aipath2ospath, but quoted as a C string.
sub quoted_ospath {
    my $aipath = shift;
    my $shorten = shift;
    my $ospath = aipath2ospath $aipath, $shorten;
    return quoted_c_string $ospath;
}

# Given an aimake path, returns the containing directory.
# This cannot meaningfully be done for "path:" (the source directory),
# "bpath:" (the build directory), or any spath: object without slashes
# (a root of the OS filesystem).
sub aipath_parent {
    my $aipath = shift;
    my @aipath = (parse_aipath $aipath);
    pop @aipath;
    scalar @aipath < 1 || ($aipath[0] =~ /(?:spath|standardlib)/ &&
                           scalar @aipath < 2)
        and croak "Tried to take the parent of root '" .
        friendly_objname($aipath) . "'";
    return deparse_aipath @aipath;
}

# Given an aimake path (as an object name), returns it as an aimake path
# (again, as an object name). The result might not match the original if, say,
# it's actually inside the bpath but specified as an spath, or contains
# similar issues.
sub cleanup_aipath {
    return ospath2aipath(aipath2ospath($_[0]));
}

# Given an aimake path as seen from the point of view of the program being
# built, returns an aimake path as seen from the point of view of the
# filesystem being installed onto. (The two are normally identical, but the
# user can specifically override this with options like --destdir.)
sub destdir_transform {
    my $aipath = shift;
    if ($opt_prefix) {
        my $aiprefix = ospath2aipath $opt_prefix;
        my @components1 = parse_aipath $aiprefix;
        my @components2 = parse_aipath $aipath;
        $components2[0] eq 'spath' or die
            "Bad --destdir option: --install is inside source " .
            "or build directory";
        # Meanwhile, $components1[0] not being on the spath is
        # meaningful, albeit probably not useful.

        # Remove the "spath" from the output_target. Also remove the
        # drive, if it's blank.  (This means that we create directories
        # with names like CSIDL_PROGRAMS on Windows when using --destdir.
        # However, that's better than losing information, and may well be
        # what the installer wants.)
        shift @components2;
        if (length $components2[0]) {
            # A root name like "C:" is not a legal directory name on
            # Windows, so we need to mangle it (in this case, by removing
            # the colon).
            $os_parsed eq 'MSWin32' and $components2[0] =~ s/\:$//;
        } else {
            shift @components2;
        }

        $aipath = deparse_aipath @components1, @components2;
    }
    return $aipath;
}

### I/O

# Complains (and halts the program) if the argument is not writable.
#
# We consider the bpath: to be freely writable, the path: to be untouchable,
# and the spath: to be usually untouchable except during install operations.
# This is a check to avoid accidentally overwriting files that we shouldn't
# change (most likely due to a misconfiguration), and is separate from any
# read-only status that might exist in the filesystem.
sub verify_writable {
    my $aipath = shift;
    my $installing = shift;
    my $aipath_c = cleanup_aipath $aipath;
    my $fon = friendly_objname $aipath_c;
    $aipath_c =~ /^path:/ and !$installing and
        croak "Attempt to overwrite source file '$fon'";
    $aipath_c =~ /^(spath|standardlib):/ and !$installing and croak
        "Attempt to overwrite system file '$fon' = '$aipath_c'";
    1; # return true so we can use this with &&
}

# Creates a directory, if it doesn't already exist.
#
# The directory's parents will also be created if necessary. If the second
# argument is false, the first argument is the directory to create. If the
# second argument is true, the first argument is a file inside the directory
# to create (and as such, the containing directories will be created, but not
# the file itself).
#
# This will do nothing, rather than error out, if given an object that isn't
# an aimake path.
sub ensure_directory {
    my $aipath = shift;
    my $containing_only = shift;
    my $installing = shift;
    my $dont_die = shift;

    my ($objtype, undef) = parse_objname $aipath;
    $objtype =~ /^[bs]?path$/ or return;

    $containing_only and $aipath = aipath_parent $aipath;
    my $fon = friendly_objname $aipath;
    my $ospath = aipath2ospath $aipath;

    return 1 if -d $ospath; # must be before verify_writable
    verify_writable $aipath, $installing;

    die "Found a non-directory at '$fon'" if -e $ospath;
    $dont_die or progress_report 1, "Creating directory '$fon'...";
    $@ = undef;
    unless (eval {make_path $ospath}) {
        $dont_die and return 0;
        die "Could not create directory '$fon': ".defined_or($@,$!);
    }
    progress_report 1, "Created directory '$fon'.";
    return 1;
}

# Given a directory option name and a filename, carries out all side effects
# that would be necessary when installing that file into that directory (e.g.
# creating the directory and adding the file to the file list), then returns
# the directory that the file must actually be installed into. In array
# context, also returns the directory the installed program thinks it was
# installed into.
my %filelist_directories;
my $filelist_body;
my %filelist_features;
my %filelist_feature_parents;
my %filelist_folder_removers;
my %filelist_feature_seen;
sub calculate_permissions;
sub calculate_installation_path {
    my $install_dir = shift;
    my $install_name = shift;

    my $feature = shift;

    my $permission = shift;
    my $elevation = shift;
    my $readable = shift;

    my $shortcut_target = shift;
    my $shortcut_description = shift;

    my $create_subdir = shift;

    my $executable = $create_subdir ? 2 : $install_dir =~ /bindir$|libdir$/;

    my $instpath = $install_dir =~ /^[bs]?path:/ ?
        $install_dir : $config->{options}{$install_dir};

    $install_name eq 'sys:touch_only' and $executable = 2;

    # For installations of manual pages in mandir, we add a section.
    # Except on Windows, where it'd be more confusing than useful.
    if ($install_dir eq 'mandir' && $os_parsed ne 'MSWin32') {
        $install_name =~ qr=\.([1-9][a-z]*)(?:\.[^./])?$=s
            and $instpath .= "/man$1";
    }

    my ($octal, undef, undef) = calculate_permissions
        $permission, $elevation, $readable, $executable,
        scalar ($install_dir =~ /(?:state|lock|log)dir$/);

    my $aipath = "$instpath/$install_name";

    my $outpath = ($shortcut_target || $install_dir =~ /^[bs]?path:/)
        ? $aipath : destdir_transform $aipath;

    $instpath or die
        "Unrecognised installation directory '$install_dir'";

    if ($install_name eq 'sys:touch_only') {
        $outpath = destdir_transform $instpath;
        ensure_directory $outpath, 0, 1;
        $aipath = $instpath;
    } elsif (!$shortcut_target) {
        ensure_directory $outpath, 1, 1;
    }

    $shortcut_target and defined wantarray and
        die "shortcut_target used but return address wanted";
    $shortcut_target and $opt_filelist ne 'wix' and return;

    # In some cases, we're installing to a different directory than
    # instpath.
    my @aipath = parse_aipath $aipath;
    $install_name eq 'sys:touch_only' or $create_subdir or pop @aipath;
    my $instdir = deparse_aipath @aipath;

    $opt_filelist ||= '';
    if ($opt_filelist eq 'basic') {
        $filelist_body = defined_or($filelist_body, '');
        $filelist_body .= (aipath2ospath $aipath) . "\n";
    } elsif ($opt_filelist eq 'listing') {
        $filelist_body = defined_or($filelist_body, '');
        $filelist_body .= ($octal & 0400) ? 'r' : '-';
        $filelist_body .= ($octal & 0200) ? 'w' : '-';
        $filelist_body .= ($octal & 04000) ? 's' : ($octal & 0100) ? 'x' : '-';
        $filelist_body .= ($octal & 0040) ? 'r' : '-';
        $filelist_body .= ($octal & 0020) ? 'w' : '-';
        $filelist_body .= ($octal & 02000) ? 's' : ($octal & 0010) ? 'x' : '-';
        $filelist_body .= ($octal & 0004) ? 'r' : '-';
        $filelist_body .= ($octal & 0002) ? 'w' : '-';
        $filelist_body .= ($octal & 0001) ? 'x' : '-';
        $filelist_body .= ' ' . (aipath2ospath $aipath) . "\n";
    } elsif ($opt_filelist eq 'wix') {
        # We use one component per file. Generate an ID for the component.
        my $id = "x" . sha256_hex($aipath);
        my $ospath = $shortcut_target ? undef : aipath2ospath $outpath;
        my $dirref = "x" . sha256_hex($instdir);
        my $bitness = "";

        # Binaries and libraries need their bitwidths marked.
        if (($executable || 0) == 1) {
            $bitness = ' Win64="' .
                ($Config{ptrsize} == 8 ? "yes" : "no") . '"';
        }

        # We don't want to deny any permissions; just to not grant the
        # permissions we don't care about. So we use a special value KEYDEL in
        # order to mark attributes we don't want to set.
        #
        # On Windows, being Administrator is insufficient to override an
        # "admins can't..." permission (unlike on Linux), so we force the
        # admins to have full permission, and only control the ACL for
        # Everyone. Otherwise, system administration can become quote
        # difficult.
        #
        # Also, for some crazy reason, execute permission is needed to read a
        # file in some cases. So when the file isn't an executable, we set the
        # execute bit based on the read bit.

        ($octal & 0700) >= 0600 or $opt_no_sanity_checks or
            die "Refusing to deny read or write permission to Administrators";
        my $otherread  = ($octal & 0004) ? 'yes' : 'KEYDEL';
        my $otherwrite = ($octal & 0002) ? 'yes' : 'KEYDEL';
        my $otherexec  = ($octal & 0001) ? 'yes' : 'KEYDEL';

        $otherexec = $otherread unless $executable;

        # WiX can't create a GUID for a folder. Yet, we need a stable value,
        # because otherwise things will go wrong on upgrade. Our solution is
        # to use the MD5 of the path as a GUID; WiX apparently used to do
        # something similar.  We use our own GUIDs no matter what, so that
        # we have consistency if WiX ever changes its ideas on GUIDs (which
        # has happened once in the past).
        my $pname = $config->{options}{packagename};
        my $guid = guid_from_string "$pname/$aipath";

        my $filelist_entry;
        my $in_component;

        if ($shortcut_target) {
            # We have two possible approaches here. One is to put the shortcut
            # in a component of its own. This produces warning ICE69 (which
            # basically warns about a bug in Windows Installer itself), but we
            # can live with that. The bigger problem is that it also needs a
            # KeyPath, which cannot be a shortcut and cannot be in a "user"
            # directory (the Common Start Menu counts as a user directory
            # because due to a stupid API decision, the installer can't
            # distinguish it from the per-user Start Menu). The official
            # solution is to use a registry key in HKCU (i.e. creating
            # registry entries for no good reason at all), but that doesn't
            # work because the installer doesn't translate it to HKLM when
            # installing for all users. I thus believe that this approach
            # leaks registry entries if a program is uninstalled by someone
            # other than the person who installed it (and would leak Start
            # Menu shortcuts too, except that Microsoft probably noticed that
            # and asked people to use RemoveFolder entries as a workaround).
            #
            # The other, and much saner, approach is to put the shortcut in
            # the same component as the target, so they always both exist or
            # both don't exist. Sadly, the Common Start Menu = per-user Start
            # Menu bug means that Windows Installer now thinks that the same
            # component is installing to both a per-user and per-system
            # directory (ICE57), creating files in the user profile that
            # aren't correctly uninstalled (ICE64), and not using the
            # recommended registry workaround for shortcuts (ICE43). That's a
            # lot of false-positive errors... Currently, we use this approach,
            # and just request that those errors be suppressed while linking.
            my $targetid = "x" . sha256_hex $shortcut_target;
            my $bindir = $config->{options}{bindir};
            my $bindirref = "x" . sha256_hex $bindir;
            my $targetsigil = $filelist_directories{$shortcut_target}
                ? '$' : '#';

            $shortcut_description = defined_or($shortcut_description, "");
            $filelist_entry = qq[
                <Shortcut Id="$id" Name="$install_name"
                          Directory="\$(var.$dirref)"
                          Description="$shortcut_description"
                          Target="[$targetsigil$targetid]"
                          WorkingDirectory="\$(var.$bindirref)" />
];
            $filelist_entry =~ s/\n *Description=""//g;
            $in_component = $targetid;
        } elsif ($opt_noperms) {
            if (($executable || 0) == 2) {
                $filelist_entry = qq[
        <DirectoryRef Id="\$(var.$dirref)">
            <Component Id="$id" Guid="{$guid}">
                <CreateFolder />
                <RemoveFolder Id="\$(var.$dirref)" On="uninstall" />
            </Component>
        </DirectoryRef>
];
                $id eq $dirref or
                    die "Folder component mismatch: $aipath != $instdir";
                $filelist_folder_removers{$dirref} = $id;
            } else {
                $filelist_entry = qq[
        <DirectoryRef Id="\$(var.$dirref)">
            <Component Id="$id" Guid="{$guid}"$bitness>
                <File Id="$id" Source="$ospath" KeyPath="yes" />
            </Component>
        </DirectoryRef>
];
            }
        } elsif (($executable || 0) == 2) {
            $filelist_entry = qq[
        <DirectoryRef Id="\$(var.$dirref)">
            <Component Id="$id" Guid="{$guid}">
                <CreateFolder>
                     <Permission User="Everyone" Read="$otherread"
                                 GenericWrite="$otherwrite"
                                 GenericExecute="$otherexec"
                                 DeleteChild="$otherwrite"
                                 ReadAttributes="$otherread"
                                 ReadExtendedAttributes="$otherread"
                                 Traverse="$otherexec" ReadPermission="yes" />
                     <Permission User="Administrators" GenericAll="yes" />
                </CreateFolder>
                <RemoveFolder Id="\$(var.$dirref)" On="uninstall" />
            </Component>
        </DirectoryRef>
];
            $id eq $dirref or
                die "Folder component mismatch: $aipath != $instdir";
            $filelist_folder_removers{$dirref} = $id;
        } else {
            $filelist_entry = qq[
        <DirectoryRef Id="\$(var.$dirref)">
            <Component Id="$id" Guid="{$guid}"$bitness>
                <File Id="$id" Source="$ospath" KeyPath="yes">
                     <Permission User="Everyone" GenericWrite="$otherwrite"
                                 Read="$otherread" ReadPermission="yes"
                                 ReadAttributes="$otherread"
                                 ReadExtendedAttributes="$otherread"
                                 GenericExecute="$otherexec" />
                     <Permission User="Administrators" GenericAll="yes" />
                </File>
            </Component>
        </DirectoryRef>
];
        }

        $filelist_entry =~ s/ \w+="KEYDEL"//g;
        if ($in_component) {
            $filelist_body =~
                s/(<Component Id="\Q$in_component\E".*?)(\ *<\/Component>)/
                  "$1$filelist_entry$2"/es;
        } else {
            $filelist_body .= $filelist_entry;
        }

        # When being called to cleanup components, we're done at this point.
        defined_or($feature,'') eq '!' and return $outpath;

        # Create an entry for the feature.
        my ($feature_id, $fdesc, $flongdesc, $fparent, $fdefault);
        if ($feature) {
            $feature_id = "x" . substr sha256_hex($feature), 0, 36;
            $config->{features}{$feature} or die
                "Unknown feature name '$feature'";
            $fdesc = $config->{features}{$feature}{description};
            $fdesc =~ s/&/&amp;/; $fdesc =~ s/"/&quot;/;
            $flongdesc = defined_or(
                $config->{features}{$feature}{long_description}, '');
            $flongdesc =~ s/&/&amp;/; $flongdesc =~ s/"/&quot;/;
            $fdefault = $config->{features}{$feature}{default} ? 1 : 250;
            $fparent = defined_or($config->{features}{$feature}{depends},
                                  '');
            $filelist_feature_parents{$feature} = $fparent;
            $filelist_features{$feature} = defined_or(
                $filelist_features{$feature},
                qq[
        <Feature Title="$fdesc" Id="$feature_id" Level="$fdefault"
                 AllowAdvertise="no" Display="expand"
                 Description="$flongdesc">
]);
            $filelist_features{$feature} =~ s/\n *Description=""//;
        } else {
            $feature_id = "main";
            $fdesc = $config->{options}{packagename_text};
            $fdesc =~ s/&/&amp;/; $fdesc =~ s/"/&quot;/;
            $feature = '';
            $filelist_features{$feature} = defined_or(
                $filelist_features{$feature},
                qq[
        <Feature Title="$fdesc" Id="$feature_id" Level="1" Absent="disallow"
                 AllowAdvertise="no" Display="expand"
                 Description="The base files required for $fdesc.">
]);
        }

        my @pi = parse_aipath $instdir;
        $pi[0] eq 'spath' or $opt_nonempty_directory or
            die "Installing to build or source dir";

        $filelist_feature_seen{$feature}{$id} or
            $filelist_features{$feature} .=
            qq[        <ComponentRef Id="$id" />\n] unless $in_component;
        $filelist_feature_seen{$feature}{$id} = 1;
        $filelist_feature_seen{$feature}{$dirref} or @pi <= 2 or
            $filelist_features{$feature} .=
            qq[        <ComponentRef Id="$dirref" />\n];
            @pi <= 2 or $filelist_feature_seen{$feature}{$dirref} = 1;

        # Record the fact that this directory needs to be added to the
        # directories list.
        $filelist_directories{$instdir} =
            defined_or($filelist_directories{$instdir}, {});
        $filelist_directories{$instpath}{$install_dir} = 1
            unless $install_dir eq 'mandir' ||
            $install_dir =~ /^[bs]?path:/;

        # All its parents need to be present, too, going back to the root. And
        # their removers are all dependencies of the feature, apart from those
        # for the CSIDL_s themselves (which don't exist).
        while (@pi > 2) {
            pop @pi;
            my $ipp = deparse_aipath @pi;
            my $id = "x" . sha256_hex $ipp;
            $filelist_feature_seen{$feature}{$id} or @pi <= 2 or
                $filelist_features{$feature} .=
                qq[        <ComponentRef Id="$id" />\n];
            @pi <= 2 or $filelist_feature_seen{$feature}{$id} = 1;
            $filelist_directories{$ipp} =
                defined_or($filelist_directories{$ipp}, {});
        }
    }

    return ($outpath, $aipath) if wantarray;
    return $outpath;
}

# Actually writes the file list, when we're done.
# Returns undef on success, error message on failure.
my $wix3264 = $Config{ptrsize} == 8 ? '64' : '';
# Note: Instead of having separate common and non-common directories, Windows
# Installer switches between the two sets based on a runtime flag (whose
# default is settable at compile time). Given that this mechanism doesn't
# actually work (e.g. a shortcut that installs to StartMenuFolder must be
# keypathed to a registry key in HKCU, and that key will /not/ move to HKLM
# when installing for all users), we instead just translate the name as best
# we can and rely on ALLUSERS being set correctly by the installer at compile
# time and not customized to the wrong value.
my %wixfolders = (
    'spath:CSIDL_ADMINTOOLS' => 'AdminToolsFolder',
    'spath:CSIDL_APPDATA' => 'AppDataFolder',
    'spath:CSIDL_COMMON_APPDATA' => 'CommonAppDataFolder',
    'spath:CSIDL_COMMON_PICTURES' => 'PicturesFolder',
    'spath:CSIDL_COMMON_PROGRAMS' => 'ProgramMenuFolder',
    'spath:CSIDL_COMMON_STARTMENU' => 'StartMenuFolder',
    'spath:CSIDL_DESKTOP' => 'DesktopFolder',
    'spath:CSIDL_FAVORITES' => 'FavoritesFolder',
    'spath:CSIDL_FONTS' => 'FontsFolder',
    'spath:CSIDL_LOCAL_APPDATA' => 'LocalAppDataFolder',
    'spath:CSIDL_MYPICTURES' => 'MyPicturesFolder',
    'spath:CSIDL_PERSONAL' => 'PersonalFolder',
    'spath:CSIDL_PROGRAMS' => 'ProgramMenuFolder',
    'spath:CSIDL_PROGRAM_FILES' => "ProgramFiles${wix3264}Folder",
    'spath:CSIDL_RECENT' => 'RecentFolder',
    'spath:CSIDL_SENDTO' => 'SendToFolder',
    'spath:CSIDL_STARTMENU' => 'StartMenuFolder',
    'spath:CSIDL_STARTUP' => 'StartupFolder',
    'spath:CSIDL_SYSTEM' => "System${wix3264}Folder",
    'spath:CSIDL_TEMPLATES' => 'TemplateFolder',
    'spath:CSIDL_WINDOWS' => 'WindowsFolder',
);
sub write_filelist {
    $opt_filelist ||= '';
    my $fns = $opt_prefix ? "spath" : "bpath";
    if ($opt_filelist eq 'basic' || $opt_filelist eq 'listing') {
        $filelist_body = defined_or($filelist_body, '');
        my $aifilelist = destdir_transform "$fns:filelist.txt";
        open my $fh, '>', aipath2ospath $aifilelist or return $!;
        print $fh $filelist_body;
        close $fh or return $!;
    } elsif ($opt_filelist eq 'wix') {
        $filelist_body = defined_or($filelist_body, '');
        my $pname = $config->{options}{packagename};
        my $aifilelist = destdir_transform "$fns:$pname.wxs";
        open my $fh, ">$utf8_layers", aipath2ospath $aifilelist or return $!;
        my $pnametext = $config->{options}{packagename_text};
        $pnametext =~ s/&/&amp;/g; $pnametext =~ s/"/&quot;/g;
        my $cname = $config->{options}{companyname};
        my $pversion = pvtransform $config->{options}{packageversion};
        my $guid = guid_from_string $pname;
        my $pguid = guid_from_string "$pname/version:$pversion";
        my $ui = 'WixUI_FeatureTree';
        keys %filelist_features == 1 and $ui = 'WixUI_Minimal';
        # TODO: Should Language always be 1033?
        # InstallerVersion is set to 200 = Windows 2000 SP3, because that's
        # what's required for 64-bit installs to work.
        print $fh qq[<?xml version="1.0" encoding="UTF-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
    <Product Id="$pguid" UpgradeCode="$guid"
             Version="$pversion" Language="1033" Name="$pnametext"
             Manufacturer="$cname">
        <Package InstallerVersion="200" Compressed="yes"
                 Description="$pnametext" InstallScope="perMachine" />
        <Media Id="1" Cabinet="$pname.cab" EmbedCab="yes" />
        <UIRef Id="$ui" />
        <MajorUpgrade DowngradeErrorMessage=
            "To install an older version of $pnametext, please first uninstall any newer versions." />
];
        # Fix a bug in Emacs' syntax highlighter: qq[];

        # Create a variable for each directory we use. We use a (lowercase)
        # SHA-256 name if the directory isn't one of the install directories
        # we actually use. We would want to user uppercase names for the
        # customizable install directories, so that they can be changed, but
        # Windows Installer thinks that this is a problem if one user happens
        # to change it to a folder in their own profile while installing
        # per-machine. Although that case would indeed break, it seems like a
        # pretty clear case of user error to me, not a problem with the file
        # list, so we currently go with what we want (producing a spurious
        # warning ICE90).
        #
        # To select a sensible name, we use the uppercase of the name from the
        # configfile (e.g. CONFIGDIR) if there's only one (ignoring "specific"
        # or "games" prefixes if that's the only thing causing a tie), and
        # otherwise, concatenate the non-"DIR" portion (e.g. BINLIBDIR for a
        # directory holding both binaries and libraries). Exception: the roots
        # have their own, camelcase, names.
        #
        # Meanwhile, create a remover for each directory that doesn't already
        # have one.
        for my $dir (sort keys %filelist_directories) {
            my @vals = keys %{$filelist_directories{$dir}};
            my $dirref = "x" . sha256_hex $dir;
            my $wixfolder = $wixfolders{$dir};

            $filelist_folder_removers{$dirref} or $wixfolder or
                calculate_installation_path $dir, 'sys:touch_only', '!';

            if ($wixfolder) {
                print $fh qq[        <?define $dirref = "$wixfolder" ?>\n];
            } elsif (!@vals) {
                print $fh qq[        <?define $dirref = "$dirref" ?>\n];
            } else {
                my @vals2 = grep !/^(?:games|specific)/, @vals;
                @vals2 or @vals2 = @vals;
                map s/dir$//, @vals2;
                my $dirref2 = uc ((join '', sort @vals2) . 'dir');
                print $fh qq[        <?define $dirref = "$dirref2" ?>\n];
            }
        }

        # Calculate the directory tree. Our algorithm works like this:
        # - First, we sort the list of directories we're mentioning.
        # - We run through the list in order:
        #   - If we have a prefix of the previous directory, then
        #     create a new <Directory> tag;
        #   - If we don't, then repeatedly close </Directory> tags
        #     until we find one that is.
        print $fh qq[        <Directory Id="TARGETDIR" Name="SourceDir">\n];
        my @parents = ('', '', '');
        for my $dir (sort keys %filelist_directories) {
            while ((substr $dir, 0, length $parents[$#parents]) ne
                   $parents[$#parents]) {
                pop @parents;
                print $fh '    ' x @parents, "</Directory>\n";
            }
            my $dirref = "x" . sha256_hex $dir;
            my $basename = (parse_aipath $dir)[-1];
            if (@parents == 3) {
                # $dir is actually a CSIDL_ known folder
                print $fh '    ' x @parents,
                    qq[<Directory Id="\$(var.$dirref)">\n];
            } else {
                # $dir is a subdirectory of another $dir
                print $fh '    ' x @parents,
                    qq[<Directory Id="\$(var.$dirref)" Name="$basename">\n];
            }
            push @parents, $dir;
        }
        while (@parents > 2) {
            pop @parents;
            print $fh '    ' x @parents, "</Directory>\n";
        }

        print $fh $filelist_body;

        sub write_feature {
            my $fname = shift;
            my $indent = shift;
            my $fh = shift;
            my $xml = $filelist_features{$fname};
            $xml =~ s/^/" " x $indent/egm;
            print $fh $xml;
            for my $innerfeature (sort keys %filelist_feature_parents) {
                $filelist_feature_parents{$innerfeature} eq $fname
                    and write_feature($innerfeature, $indent + 4, $fh);
            }
            print $fh " " x $indent, "    </Feature>\n";
        }
        write_feature "", 1, $fh;

        print $fh "    </Product>\n</Wix>\n";
        close $fh or return $!;
    }
    return;
}

# Takes the hash of a file on disk. This modifies state, so should be
# protected via atomically{}.
#
# This uses the modification time to check to see if a file has been changed;
# however, we have to be careful. If the file was changed very recently, it's
# possible it'll be changed again in the same second, meaning we wouldn't
# notice the change. The obvious thing to do would be to compare the
# modification time to the current time, but that's unsafe due to clock skew;
# there's no guarantee that the filesystem is using anything approximating the
# same times as the system clock (and because the files may be on separate
# filesystems, also no guarantee that files use the same times as each other,
# meaning we can't just measure the clock skew and use the measured value).
#
# Instead, we use four fields:
#
# _mtime: the modification time of the file the last time we checked it;
#
# _ltime: the time on the system clock the last time _mtime or _mhash changed;
#
# _mhash: the hash of the file the last time we checked it;
#
# _hashok: true if the file was checked twice, 3 or more seconds apart, had
# the same mtime and mhash on both occasions, and _mtime and _mhash are still
# the same as they were then.
#
# If _hashok is set and _mtime equals the file's modification time, then the
# file must still have the same hash (barring manual timestamp adjustment);
# the hash was correct as of the second check, and any change to the file
# after the second check would have changed its modification time (because its
# modification time had the same value as the first check, and the filesystem
# clock must have changed since then).
sub file_hash {
    my $aipath = shift;
    my ($objtype, undef) = parse_objname $aipath;
    my $ospath = aipath2ospath $aipath;
    -e $ospath or return;
    my $mtime = (stat(_))[9];
    my $ltime = time;
    my $iaipath = intern $aipath;
    my $oldmtime = defined_or($state->{_mtime}{$iaipath}, -1);
    my $oldltime = defined_or($state->{_ltime}{$iaipath}, -1);
    my $oldmhash = defined_or($state->{_mhash}{$iaipath}, 'x');
    my $hashok = $state->{_hashok}{$iaipath};

    return $oldmhash if $mtime == $oldmtime && $hashok;

    $state->{_mtime}{$iaipath} = $mtime;
    my $digestor = Digest::SHA->new(256);
    open my $fh, "<$binary_layers", $ospath
        or croak "'$ospath' exists but is not readable";
    $digestor->addfile($fh);
    close $fh;
    my $mhash = $digestor->hexdigest;

    $state->{_mhash}{$iaipath} = $mhash;
    $state->{_ltime}{$iaipath} = $ltime
        if $oldmtime != $mtime || $oldmhash ne $mhash;
    $state->{_hashok}{$iaipath} =
        ($ltime > $oldltime + 3 &&
         $mtime == $oldmtime && $mhash eq $oldmhash);

    return $mhash;
}

sub final_symlink_target;
sub final_symlink_target {
    my $ospath = shift;
    my $depth = shift || 0;

    -l $ospath or return $ospath;

    $depth >= 8 and die "Symlink loop";

    my ($vol, $dirs, undef) = File::Spec->splitpath($ospath);
    my $ospathdir = File::Spec->catpath($vol, $dirs, '');
    my $target = File::Spec->rel2abs(readlink $ospath, $ospathdir);
    return final_symlink_target $target, $depth + 1;
}


##### Interfacing with OS facilities

### Commands

# Finds the executable for a command, or undef if the command doesn't exist on
# the system. MakeMaker's used to search for the command because it
# understands the differences between operating systems with respect to
# executable naming, and it's one of the modules we have access to in 5.8;
# IPC::Cmd would be reasonable in a more modern Perl (and just goes indirectly
# via MakeMaker anyway).
#
# Returns an OS path (to avoid issues with symlinks).
sub locate_command {
    my $cmd = shift;
    for my $dir (File::Spec->path) {
        my $fnos = File::Spec->rel2abs($cmd, $dir);
        my $cmdos = MM->maybe_command($fnos);
        return $cmdos if $cmdos;
    }
    return;
}
memoize('locate_command');

# Returns the name of a signal, given its number.
{
    my %signal_map = ();
    my $signal_map_initialized = 0;
    sub signal_name {
        my $signum = shift;
        $Config{sig_name} && $Config{sig_num}
            or return "SIG_$signum";
        unless ($signal_map_initialized) {
            @signal_map{split ' ', $Config{sig_num}} =
                (split ' ', $Config{sig_name});
            $signal_map_initialized = 1;
        }
        return "SIG" . defined_or($signal_map{$signum}, "_$signum");
    }
}

# Given a command, and an argument list, runs the command.
#
# The command and arguments are all objects; one bpath/cmd/intcmd, and a list
# of optstrings and optpaths. A few options are also accepted, given as scalar
# references:
# \ "nostderr"      Don't try to capture stderr, leaving it unredirected.
# \ "cwd:$aipath"   Use $aipath as the current working directory.
# \ "locale:$l"     Use $l as the locale for running the command.
# \ "relpaths"      Use relative paths. (By default, absolute paths are used.)
# \ "cmdline"       Return the command line, and take no other action.
# \ "debug_trace"   Print details about what's happening even at verbosity 0.
#
# Irrelevant objects can be given, and will simply be ignored. intcmd and cmd
# objects take precedence when determining which is a command; otherwise, we
# use an executable on the bpath. If there's more than one equally good option
# for the command, or no options, we throw an exception. The options will be
# passed to the command in the standard order (early optstrings, optpaths with
# a value, plain optpaths, late optstrings), maintaining order as a tiebreak.
#
# The return value is ($failreason, $stdout, $stderr). $failreason will be
# undef if everything worked fine, or otherwise a textual description of what
# went wrong. $stdout and $stderr are captures of the command's stdout and
# stderr (its stdin will remain unredirected), interpreted in text mode (so
# you'll get CRLF translation on Windows).
#
# With \ "cmdline" set, the return value is a single scalar, representing a
# human-readable command line. (It may be slightly ambiguous, such as via
# failing to escape filenames; this is intentional in order to produce the
# most readable path possible, but should not be run as a result.)
my %listtree_cache = ();
sub run_command {
    # Find options and executables.
    my @xuse = grep !ref $_, @_;
    my @execs = grep /^(?:cmd|intcmd):/, @xuse;
    my @opts = grep /^opt(?:string|path):/, @xuse;
    my %intopts = map {$$_ =~ /^(cwd|locale):(.*)$/s ? ($1 => $2) : ($$_ => 1)}
        grep ref $_, @_;
    if (scalar @execs == 0) {
        @execs = grep /^bpath:/, @xuse;
        @execs = grep {-x aipath2ospath($_)} @execs;
    }
    scalar @execs == 0 and die "Cannot find command in {" .
        (join ', ', map +(friendly_objname $_), @xuse) . "}";
    scalar @execs > 1 and die "Found too many commands: {" .
        (join ', ', map +(friendly_objname $_), @execs) . "}";

    # Move options into order.
    @opts = ((grep /^optstring:[^ ]/, @opts),
             (grep !/^optstring:./s && !/^optpath:[ :]/, @opts),
             (grep /^optpath::/, @opts),
             (grep /^optpath: /, @opts),
             (grep /^optstring: /, @opts));

    my $cmd = $execs[0];
    if ($cmd =~ /^intcmd:/ && !$intopts{'cmdline'}) {
        if ($cmd eq 'intcmd:nop') {
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:cat') {
            scalar @opts == 1 and $opts[0] =~ /^optpath: ?:(.*)$/s
                or return ("Invalid arguments", '', '');
            my $fn = aipath2ospath($1);
            # This has to round-trip with text_layers. So use text_layers.
            open my $fh, "<$text_layers", $fn or
                return ("Could not open '$fn' for reading: $!", '', '');
            local $/ = undef;
            my $stdout = <$fh>;
            close $fh;
            return (undef, $stdout, '');
        } elsif ($cmd eq 'intcmd:podformat') {
            scalar @opts == 1 and $opts[0] =~ /^optpath: ?:(.*)$/s
                or return ("Invalid arguments", '', '');
            my $aipath = $1;
            my $fn = aipath2ospath($aipath);
            open my $fh, "<$binary_layers", $fn or
                return ("Could not open '$fn' for reading: $!", '', '');
            local $/ = undef;
            my $pod = <$fh>;
            close $fh;

            my $formatter;
            my $ext;
            my $is_eula;
            my ($manualname, $manualsection);
            if ($pod =~ /^=for aimake eula\r?$/m) {
                if ($os_parsed ne 'MSWin32') {
                    # Just exit without doing anything.
                    return (undef, [], '');
                }
                # Convert the license to RTF.
                $ext = 'rtf';
                $is_eula = 1;

                require Pod::Simple::RTF;
                $formatter = Pod::Simple::RTF->new(errors => 'die');
            } else {
                $pod =~ /^=for aimake manualsection ([1-9][a-z]*)\r?$/m or
                    return ("no/malformed manualsection directive found",
                            '', '');
                $manualsection = $1;
                $pod =~ /^=for aimake manualname ([-a-zA-Z0-9._]+)\r?$/m or
                    return ("no/malformed manualname directive found", '', '');
                $manualname = $1;

                if ($os_parsed eq 'MSWin32') {
                    require Pod::Simple::HTML;
                    $formatter = Pod::Simple::HTML->new(errors => 'die');
                    $ext = ".html";
                } else {
                    require Pod::Man;
                    $formatter = Pod::Man->new(
                        errors => 'die',
                        center => $config->{options}{packagename_text} .
                        ' Manual',
                        name => $manualname,
                        release => $config->{options}{packageversion},
                        section => $manualsection);
                    $ext = "";
                }
            }

            my $formatted;
            $formatter->no_errata_section(1);
            $formatter->output_string(\$formatted);
            open my $save_stderr, '>&', STDERR
                or return ('could not redirect error output', undef, $!);
            close STDERR;
            open STDERR, '>', \my $stderr;
            my $ok = eval {
                $formatter->parse_string_document($pod);
                $formatter->any_errata_seen() ?
                    ($@='', 0) : 1;
            };
            close STDERR;
            if (!open STDERR, '>&', $save_stderr) {
                # no point in using the normal error mechanism: we don't have
                # a working stderr, send the error to stdout instead
                print "Could not restore STDERR: $!\n";
                die "cannot continue, no working STDERR";
            }
            $ok or return ($@ =~ s/ at .*// ? $@ : 'formatting failed',
                           '', $stderr);

            # Work around a bug in Pod::Man
            $formatter->isa('Pod::Man') and $formatted =~ s/^$/./gm;

            if ($is_eula) {
                $aipath = 'bpath:aimake/license.rtf';
            } else {
                my @aipath = parse_aipath $aipath;
                $aipath[-1] = "$manualname.$manualsection$ext";
                $aipath[0] = 'bpath';
                $aipath = deparse_aipath @aipath;
            }
            $fn = aipath2ospath $aipath;
            ensure_directory $aipath, 1;
            open my $fh2, ">$text_layers", $fn or
                return ("Could not open '$fn' for writing: $!", '', '');
            print $fh2 $formatted;
            close $fh2 or
                return ("Could not write '$fn': $!", '', '');
            return (undef, [$aipath], '');

        } elsif ($cmd eq 'intcmd:filetest') {
            @opts = sort @opts;
            scalar @opts == 2 and $opts[1] =~ /^optstring:-[fdlxzsTB]/
                and $opts[0] =~ /^optpath: ?:(.*)$/s
                or return ("Invalid arguments", '', '');
            my $fn = aipath2ospath($1);
            my ($ts, $expl);
            $opts[1] =~ s/^optstring:-//;
            $opts[1] eq 'f' and ($ts, $expl) = (-f $fn, 'present');
            $opts[1] eq 'd' and ($ts, $expl) = (-d $fn, 'a directory');
            $opts[1] eq 'l' and ($ts, $expl) = (-l $fn, 'a symlink');
            $opts[1] eq 'x' and ($ts, $expl) = (-x $fn, 'executable');
            $opts[1] eq 'z' and ($ts, $expl) = (-z $fn, 'empty');
            $opts[1] eq 's' and ($ts, $expl) = (-s $fn, 'nonempty');
            $opts[1] eq 'T' and ($ts, $expl) = (-T $fn, 'a text file');
            $opts[1] eq 'B' and ($ts, $expl) = (-B $fn, 'a binary file');
            !$ts and return ("$fn is not $expl", '', '');
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:echo') {
            map +(s/^optstring: ?// ||
                  s/^optpath: ?-w:// ||
                  s/^optpath: ?-t([^:]*):(.*)$/$1.((parse_objname $2)[0])/es ||
                  s/^optpath: ?-a([^:]*):(.*)$/$1.((parse_objname $2)[1])/es ||
                  s/^optpath: ?-i([^:]*):(.*)$/$1.((parse_objname $2)[2])/es ||
                  s/^optpath: ?-q([^:]*):(.*)$/$1.(quoted_ospath $2)/es ||
                  s{^optpath: ?-c([^:]*):(.*)$}{$1.do{
                      my $fn = $2;
                      $fn = resolve_extend $fn;
                      open my $fh, "<$text_layers", aipath2ospath $fn or
                          return ("Could not open '$fn' for reading: $!", '', '');
                      local $/ = undef;
                      my $file_contents = <$fh>;
                      close $fh;
                      $file_contents;
                  }}es ||
                  s/^optpath: ?([^:]*):/$1/), @opts;
            return (undef, (join ' ', @opts), '');
        } elsif ($cmd eq 'intcmd:writefile' ||
                 $cmd eq 'intcmd:testruncount') {
            my @paths = grep /^optpath: ?:/s, @opts;
            my @strings = grep /^(?:optstring:|optpath: ?-[wtaiqc])/s, @opts;
            my %okopts;
            $okopts{$_} = 1 for (@paths, @strings);
            my @bad = grep !$okopts{$_}, @opts;
            scalar @paths + scalar @strings == scalar @opts
                or return ("Invalid arguments (bad options)", '',
                           "Bad options are: [@bad]");
            scalar @paths == 1
                or return ("Invalid arguments (wrong number of filenames)",
                           '', '');
            $paths[0] =~ /^optpath: ?:(.*)$/s;
            my $fn = $1;
            $fn = resolve_extend($fn);
            $fn = aipath2ospath($fn);
            open my $fh, ">$text_layers", $fn or
                return ("Could not open '$fn' for writing: $!", '', '');
            s/^optstring: ?// for @strings;
            for my $i (0 .. $#strings) {
                $strings[$i] =~ s/^optpath: ?-w:// or
                    $strings[$i] =~ s{^optpath: ?-t([^:]*):(.*)$}{
                        $1.((parse_objname $2)[0])}es or
                    $strings[$i] =~ s{^optpath: ?-a([^:]*):(.*)$}{
                        $1.((parse_objname $2)[1])}es or
                    $strings[$i] =~ s{^optpath: ?-i([^:]*):(.*)$}{
                        $1.((parse_objname $2)[2])}es or
                    $strings[$i] =~ s{^optpath: ?-q([^:]*):(.*)$}{
                        $1.(quoted_ospath $2)}es or
                    $strings[$i] =~ s{^optpath: ?-c([^:]*):(.*)$}{$1.do{
                        my $fn2 = $2;
                        $fn2 = resolve_extend $fn2;
                        open my $fh2, "<$text_layers", aipath2ospath $fn2 or
                            return ("Could not open '$2' for reading: $!", '', '');
                        local $/ = undef;
                        my $file_contents = <$fh2>;
                        close $fh2;
                        $file_contents; }}es or
                    $strings[$i] =~ s{(\\.|_| )}{
                        $1 eq '_' ? ' ' :
                            $1 eq ' ' ? "\n" :
                            substr $1, 1, 1}ge;
            }
            if ($cmd eq 'intcmd:testruncount') {
                @strings = ($config_hashes{'sys:always_rebuild'});
            }
            print $fh "$_\n" or do {
                close $fh; return ("Could not write '$fn': $!", '', '');
            } for @strings;
            close $fh or return ("Could not flush '$fn': $!", '', '');
            return (undef, '', '');
        } elsif ($cmd eq 'intcmd:testcase') {
            progress_report 0, "intcmd:testcase argument: $_" for @opts;
            $opts[0] and $opts[0] =~ /failed/ and
                return ('Testcase failure', '', (join ' ', @opts));
            return (undef, '', (join ' ', @opts));
        } elsif ($cmd eq 'intcmd:assert_equal') {
            # If we have two identical arguments, they collapse to one
            # argument.
            scalar @opts == 1 and return(undef, '', '');
            scalar @opts == 2 or return ("Wrong number of arguments", '', '');
            return ("'opts[0]' does not equal '$opts[1]'", '', '');
        } elsif ($cmd eq 'intcmd:optionvalues') {
            my $stderr = '';
            my @stdout = ();
            my $failreason = undef;
            my $format = 'equals';
            my $escape = undef;
            for my $o (@opts) {
                $o eq 'optstring:--equals' and $format = 'equals';
                $o eq 'optstring:--struct' and $format = 'struct';
                $o eq 'optstring:--optstring-escape' and $escape = 'optstring';
            }
            for my $o (@opts) {
                $o =~ /^optstring:--/ and next;
                if ($o !~ /^optstring:(.*)$/s &&
                    $o !~ /^optpath: ?:config_option:(.*)$/s) {
                    $failreason = "Invalid arguments";
                    $stderr .= "'$o' is the wrong sort of object";
                } elsif (defined $config->{options}{$1}) {
                    my $k = $1;
                    my $o = $config->{options}{$k};
                    next if ref $o; # silently ignore, say, default_libraries
                    if ($format eq 'equals') {
                        $o =~ /^[bs]?path:/ and $o =
                            ($singledir ? File::Spec->curdir : aipath2ospath($o));
                        push @stdout, "$k=$o";
                    } elsif ($format eq 'struct') {
                        if ($o =~ /^[bs]?path:/ and $singledir) {
                            push @stdout, ("{\"$k\", " .
                                           quoted_ospath('bpath:', 'bpath:') .
                                           ", -1},");
                        } elsif (!$singledir && $os_parsed eq 'MSWin32' &&
                            $o =~ m=^spath:(CSIDL_[^/]*)=) {
                            my $csidl = $1;
                            push @stdout, ("{\"$k\", " .
                                           quoted_ospath($o, "spath:$csidl") .
                                           ", $csidl},");
                        } elsif ($o =~ /^[bs]?path:/) {
                            push @stdout, ("{\"$k\", " .
                                           quoted_ospath($o) .
                                           ", -1},");
                        } else {
                            push @stdout, ("{\"$k\", " .
                                           quoted_c_string($o) .
                                           ", -1},");
                        }
                    }
                } else {
                    $failreason = "Missing config options";
                    $stderr .= "'$1' is not a config option";
                }
            }
            # TODO: Because we're outputting OS paths, we need to use in-band
            # newlines to signal that fact. Of course, this fails for dirnames
            # with newlines in.
            my $stdout = (join "\n", @stdout);
            if ($escape && $escape eq 'optstring') {
                $stdout =~ s/\\/\\\\/g;
                $stdout =~ s/_/\\_/g;
                $stdout =~ s/ /_/g;
                $stdout =~ s/\n/ /g;
            }
            return ($failreason, $stdout, $stderr);
        } elsif ($cmd eq 'intcmd:xuse_statistics') {
            my @stdout = ();
            for my $required (grep /^optstring:-r/, @opts) {
                $required =~ /^optstring:-r(.*)/s;
                my $rx = $1;
                grep /$rx/, @xuse or return
                    ("No dependency matches $required", '', '');
            }
            my @flxuse = @xuse;
            for my $required (grep /^optstring:-s/, @opts) {
                $required =~ /^optstring:-s(.*)/s;
                my $rx = $1;
                @flxuse = grep /$rx/, @flxuse;
            }

            push @stdout, 'hash=' . sha256_hex(join ':', @flxuse);
            @flxuse = sort grep /^namehint:/, @xuse;
            my $stem = 'anonymous';
            my @version_max = ();
            if (@flxuse) {
                $stem = $flxuse[0];
                $stem =~ s/^namehint:[^:]*:[^:]+://;
                for my $flxuse (@flxuse) {
                    "${stem}::$flxuse" =~ /^(.*).*?::namehint:([^:]*):[^:]+:\1/;
                    $stem = $1;
                    my $version = $2;
                    $version =~ s/\s//g;
                    my @version = split /\./, $version;
                    for my $i (0..$#version) {
                        $#version_max < $i || $version[$i] > $version_max[$i]
                            and (@version_max = @version), last;
                        $version[$i] < $version_max[$i] and last;
                    }
                }
            }
            # We place the stem in the same directory as everything that's
            # being stemmed, source and all.
            #
            # TODO: This doesn't handle backslashes that aren't directory
            # separators properly.
            my $stemdir = $stem;
            $stemdir =~ s=/[^/]*$=/=;
            $stemdir =~ m=/= or $stemdir = '';
            $stem =~ s/\/$//;
            $stem =~ s/\.$//;
            # It's common to use "src" as an intermediate folder name, but we
            # don't want to go around creating libraries src.so.
            $stem =~ s/\/src//;
            $stem eq '' and $stem = 'contradictory_names';
            $stem =~ s/^.*\///;
            push @stdout, "stem=bpath:$stemdir$stem";
            push @stdout, "version=" . (join '.', '', @version_max);
            push @stdout, "dependency=$_" for @xuse;
            return (undef, \@stdout, '');
        } elsif ($cmd eq 'intcmd:listtree') {
            my %results = ();
            my $starttime = time;
            my $lastdir = '';
            my $depth = undef;
            my %dirs = ();
            my $fnfilter = undef;
            /^optpath: ?:([bs]?path:.*)$/s and $dirs{$1} = 1 for @opts;
            /^optpath: ?:searchfile:(.*)$/s and $fnfilter = $1 for @opts;
            /^optstring:(\d+)/s and $depth = $1 for @opts;
            keys %dirs or return ("No directory specified", '', '');
            for my $dir (keys %dirs) {
                my $osdir = aipath2ospath($dir);
                my $aidir = cleanup_aipath($dir);
                -d $osdir or return ("'$osdir' is not a directory", '', '');
                my $in_spath = $aidir =~ /^spath:/;
                !$listtree_cache{$dir} and finddepth({
                    no_chdir => 1,
                    wanted => sub {
                        my $aifile = ospath2aipath($File::Find::name);
                        return if $aifile =~ $config->{options}{ignore_files};
                        !-d $File::Find::name and
                            $listtree_cache{$dir}{$aifile} = 1;
                        # This can be a quick operation. It can also be very
                        # slow. If it's taken more than between 1 and 2
                        # seconds, start showing a progress bar.
                        if (time > $starttime + 1 && $lastdir
                            ne $File::Find::dir) {
                            $lastdir = $File::Find::dir;
                            if ($opt_verbose >= 0) {
                                progress_report($opt_verbose + 0.5,
                                                "Looking in $lastdir");
                            }
                        }
                    },
                    # We need to skip things like VCS directories. We don't
                    # bother checking for them in the spath in order to speed
                    # things up, because they're unlikely to be there.
                    preprocess => sub {
                        ospath2aipath($File::Find::dir) =~ /^bpath:/ and
                            $aidir !~ /^bpath:/ and return;
                        ospath2aipath($File::Find::dir) =~ /^\Q$aidir\E(.*)$/s
                            or die "'$File::Find::dir' escaped from '$osdir' ('"
                            . ospath2aipath($File::Find::dir) . "', '$aidir')";
                        # y=/=/= counts slashes, but only on a read-write
                        # scalar.
                        my $diff = $1;
                        return if defined $depth && $diff =~ y=/=/= > $depth;
                        return @_ if $in_spath;
                        return grep {
                            $_ !~ $config->{options}{ignore_directories}
                                and do {
                                    my $ok = 1;
                                    -e File::Spec->catfile($File::Find::dir, $_)
                                        and $ok = 0
                                        for @{$config->{options}
                                              {ignore_directories_with_files}};
                                    $ok;
                                }
                        } @_;
                    }
                }, $osdir);
                for my $aifile (keys %{$listtree_cache{$dir}}) {
                    !defined $fnfilter ||
                        $aifile =~ m{^[bs]?path:(?:[^\\]|\\.)+/
                            \Q$fnfilter\E$}xs
                            and $results{$aifile} = 1;
                }
            }
            return (undef, [sort keys %results], '');
        } elsif ($cmd eq 'intcmd:symlink') {
            my @targets;
            my @sources;
            /^optpath: ?:(.*)$/s and push @targets, $1 for @opts;
            /^optpath: ?-o:(.*)$/s and push @sources, $1 for @opts;
            @targets == 1 or return ("Wrong number of targets", '', '');
            for my $source (@sources) {
                my $ostarget = aipath2ospath($targets[0]);
                my $ossource = aipath2ospath($source);
                my ($ossourcevol, $ossourcedir, undef) =
                    File::Spec->splitpath($ossource);
                $ossourcedir = File::Spec->catpath(
                    $ossourcevol, $ossourcedir, '');
                $ostarget = File::Spec->abs2rel($ostarget, $ossourcedir);
                # -e returns false on broken symlinks
                -e $ossource || -l $ossource and unlink $ossource;
                $! = 0;
                # chdir to $ossourcedir so that the target is valid both as a
                # cwd-relative and a source-relative filename
                chdir $ossourcedir or
                    return ("Could not change directory", '',
                            "Changing directory: $!");
                ai_symlink $ostarget, $ossource or
                   (chdir $oscwd or die "Could not unchange directory: $!"),
                    return ("Could not create link", '',
                            "Linking '$ossource' to '$ostarget': $!");
                chdir $oscwd;
            }
            return (undef, '', '');
        }
        return ("No such internal command $cmd", '', '');
    } elsif ($cmd =~ /^bpath:/) {
        # When actually running the command, always use an absolute path.
        # When telling the user what we did, a relative path would be OK, but
        # we avoid that anyway (basically because of confusion over the value
        # of cwd, and partly because it wouldn't help for, say, /usr/bin/gcc,
        # which is not inside the cwd).
        $cmd = aipath2ospath($cmd);
    } elsif ($cmd =~ /^cmd:(.*)$/s) {
        my $cmd_name = $1;
        $cmd = locate_command($1);
        defined $cmd or return ("No such command '$cmd_name'", '', '');
    }

    # Convert options into a string representation (unless we were running an
    # internal command).
    local $cwd = $cwd;
    $intopts{'cwd'} and $cwd = $intopts{'cwd'};
    my $rel = $intopts{'relpaths'} ? $cwd : undef;
    if ($cmd !~ /^intcmd:/) {
        @opts = map {
            /^optstring: ?(.*)$/s ? split / /, $1 : do {
                my (undef, $objvalue, $objinner) = parse_objname $_;
                $objinner = resolve_extend $objinner;
                my $ospath = $objinner =~ /^searchlib:([^:]*):/s ? $1 :
                    $objinner =~ /^config_option:/ ? $objinner :
                    $objinner =~ /^symbolset:[^:]+:(.*)$/s ?
                    aipath2ospath($1, $rel) : aipath2ospath($objinner, $rel);
                $objvalue =~ s/^ //;
                $objvalue =~ /^(.*) $/s ? ($1, $ospath) : "$objvalue$ospath";
            }
        } @opts;
    }
    # If we're asked for the command line, just return it now. This doesn't
    # actually follow any quoting rules in existence, but it's pretty close to
    # what Windows uses and will be familiar on Unix too. (Less ambiguous
    # escaping would be less readable, especially because, say, Windows uses
    # backslash as a path separator.)
    my $cmdline = "$cmd " . join ' ', map {/ / ? "\"$_\"" : $_} @opts;
    $intopts{'cmdline'} and return $cmdline;

    # Change directory if necessary.
    my $oldoscwd = $oscwd;
    local $oscwd = aipath2ospath($cwd);
    unless (chdir $oscwd) {
        return ("Could not change directory to '" .
                aipath2ospath($intopts{cwd}, 'bpath:') .
                "': $!", undef, undef);
    }
    progress_report +($intopts{'debug_trace'} ? 0 : 2),
        "Running $cmdline (wd: '$oscwd')";

    # If we get information in the wrong encoding, treat that like a compile
    # error.
    local $PerlIO::encoding::fallback = FB_CROAK; # report errors with die()

    local $ENV{LC_ALL} = defined_or($intopts{locale},
        defined_or($ENV{LC_ALL}, defined_or($ENV{LANG}, 'C')));
    my $layers = $text_layers;
    $ENV{LC_ALL} eq 'C' and
        $layers = $ascii_layers; # locale 'C' probably implies ASCII

    # We capture stdout and stderr via redirecting files, which is the most
    # portable possible method.
    open my $save_stdout, ">&", \*STDOUT or die "Could not save stdout: $!";
    my $tmp_stdout = tempfile() or die "Could not create temp file: $!";
    binmode $tmp_stdout, $layers;
    open STDOUT, ">&", $tmp_stdout or die "Could not capture stdout: $!";
    my ($save_stderr, $tmp_stderr);
    unless ($intopts{nostderr}) {
        open $save_stderr, ">&", \*STDERR or die "Could not save stderr: $!";
        $tmp_stderr = tempfile() or die "Could not create temp file: $!";
        binmode $tmp_stderr, $layers;
        open STDERR, ">&", $tmp_stderr or die "Could not capture stderr: $!";
    }
    # Repeating $cmd like this forces shells to never be involved. This works
    # better than trying to allow for the escaping rules of every shell in
    # existence.
    my $sysreturn = system { $cmd } $cmd, @opts;
    my $err = $!;
    open STDOUT, ">&", $save_stdout or die "Could not restore stdout: $!";
    close $save_stdout;
    seek $tmp_stdout, 0, 0;
    unless ($intopts{nostderr}) {
        open STDERR, ">&", $save_stderr or die "Could not restore stderr: $!";
        close $save_stderr;
        seek $tmp_stderr, 0, 0;
    }

    # Slurp up the stdout/stderr from the temp files.
    my $failreason = undef;
    my ($stdout, $stderr);
    eval {
        $! = 0;
        {
            local $/;
            $stdout = <$tmp_stdout>;
            $stderr = <$tmp_stderr> unless $intopts{nostderr};
        }
        close $tmp_stdout;
        close $tmp_stderr unless $intopts{nostderr};
        1;
    } or do {
        $@ =~ /^(.*) does not map to Unicode/s;
        $failreason = "Invalid character found in command output: $1";
        close $tmp_stdout;
        close $tmp_stderr;
    };

    # Restore the changed directory. ($cwd, $oscwd will be reverted back
    # to their old values by local.)
    chdir $oldoscwd or die
        "Could not change back to the correct directory: $!";

    # Report the results.
    if ($sysreturn == -1) {$failreason = "Could not execute command: $err";}
    elsif ($sysreturn >> 8 != 0) {
        $failreason = "Command reported failure status " .
            ($sysreturn >> 8);
    } elsif ($sysreturn != 0) {
        signal_name($sysreturn & 127) eq 'SIGINT' and
            die "Interrupted."; # make control-C work as expected
        $failreason = "Command crashed with signal " .
            signal_name($sysreturn & 127);
    }
    progress_report +($intopts{'debug_trace'} ? 0 : 2),
        (defined_or($failreason, "Command succeeded") . ".");

    if ($intopts{'debug_trace'}) {
        print STDERR "stdout was:\n", defined_or($stdout, '(empty)');
        print STDERR "stderr was:\n", defined_or($stderr, '(empty)');
    }

    return ($failreason, $stdout, $stderr);
}

### OS metadata

sub atomic_read(&);

# Set the metadata of the given executable based on the given parameters.
# Returns undef on success, an error message on failure.
# Must not be called from inside atomically{} (it calls atomic_read{}
# itself).
sub set_exeparams {
    my $params = shift;
    my $osfile = shift;
    my $aifile_predestdir = shift;
    my $feature = shift;

    my (undef, undef, $basename) = File::Spec->splitpath($osfile);
    $basename =~ s/\..*?$//g;

    # Finding the icon files is OS-independent. (What we do with them once
    # we've found them is OS-dependent.)
    my (@png_images, @png_width, @png_height);

    if (defined $params->{icon}) {
        my @png_aipaths = ();

        atomic_read {
            for my $iobject (keys %{$state->{outdep_by_object}}) {
                my $object = unintern $iobject;
                if ((ref $params->{icon}) =~ /\bRegexp$/) {
                    $object =~ $params->{icon} and
                        push @png_aipaths, $object;
                } else {
                    $object eq $params->{icon} and
                        push @png_aipaths, $object;
                }
            }
        };

        if (!@png_aipaths) {
            return "no objects match '" . $params->{icon} . "'";
        }

        for my $png_aipath (@png_aipaths) {
            # Because the object exists, we expect the path to be readable.
            # If not, die rather than treating it as an error, this is
            # pretty bad.
            open my $fh, "<$binary_layers", aipath2ospath($png_aipath)
                or die "Couldn't open '$png_aipath': $1";
            my $image;
            { local $/; $image = <$fh>; }
            close $fh;

            my ($header, $width, $height) = unpack "a16NN", $image;
            my $errmsg;
            $header eq "\x89PNG\x0d\x0a\x1a\x0a\0\0\0\x0dIHDR"
                or return "incorrect PNG header on '$png_aipath'";

            push @png_images, $image;
            push @png_width, $width;
            push @png_height, $height;
        }
    }

    # We have an entirely different set of actions for each OS.

    if ($os_parsed eq 'MSWin32') {
        my $icofile = undef;

        if (!$win32_exe_available) {
            return "no Win32::Exe";
        }

        # Icon
        if (@png_images) {
            $icofile = File::Temp->new( SUFFIX => '.ico', TMPDIR => 1 );
            binmode $icofile, $binary_layers;

            # PNG-to-ICO conversion is relatively simple (for Vista onwards, at
            # least), because the ICO format uses PNG images directly as the
            # storage for the actual image. Thus all we need to do is wrap them
            # in appropriate ICO headers.

            my @imageindexes = grep
                $png_width[$_] >= 1 && $png_width[$_] <= 256 &&
                $png_height[$_] >= 1 && $png_height[$_] <= 256,
                0 .. $#png_images;

            @imageindexes or return "no icon image is appropriately sized";

            my @headers;
            my @images;

            my $headerlength = 6 + 16 * scalar @imageindexes;
            my $dataoffset = $headerlength;

            for my $i (@imageindexes) {
                push @headers, (pack "CCxxx2x2VV",
                                $png_width[$i] % 256, $png_height[$i] % 256,
                                (length $png_images[$i]), $dataoffset);
                push @images, $png_images[$i];
                $dataoffset += length $png_images[$i];
            }

            print $icofile join '', (pack 'x2vv', 1, scalar @images),
                @headers, @images;
            close $icofile; # get round Windows' automatic locking
        }

        # Win32::Exe has limits on how quickly it can expand the file;
        # if you want to expand it a long way, you need to call it
        # multiple times. Thus, we repeat until the file stops getting
        # larger.

        my $oldsize = 0;
        while ((my $newsize = (stat $osfile)[7]) != $oldsize) {
            $oldsize = $newsize;

            my $exe = Win32::Exe->new($osfile)
                or return "Win32::Exe reported an error";

            progress_report 1, "Setting executable parameters...";

            $exe = $exe->create_resource_section
                if $exe->can_create_resource_section;

            # Icon
            $exe->set_single_group_icon($icofile) if @png_images;

            # Version info
            my $vi = $exe->get_version_info;
            $vi->{LegalCopyright} = $params->{copyright}
                if $params->{copyright};
            $vi->{FileVersion} = pvtransform
                defined_or($params->{version},
                           $config->{options}{packageversion});
            $vi->{ProductVersion} = pvtransform
                $config->{options}{packageversion};
            my $pn = $config->{options}{packagename_text};
            $vi->{ProductName} = $pn if defined $pn;
            $vi->{FileDescription} = defined_or($params->{name}, $basename);
            $vi->{CompanyName} = $config->{options}{companyname};
            $exe->set_version_info($vi);

            # Subsystem
            if (defined $params->{terminal}) {
                $params->{terminal} and $exe->set_subsystem_console;
                $params->{terminal} or  $exe->set_subsystem_windows;
            }

            $exe->write or return "write failure";
        }
        # We'd also want to create a shortcut on the Start menu.  However, the
        # way shortcuts work in Windows is a mess (you can't have them
        # automatically update for known folder movement at the same time as
        # having them link to nonexistent files). Thus, we need to tell the
        # installer to do the shortcut creation.
        calculate_installation_path 'shortcutdir',
        defined_or($params->{name}, $basename), $feature,
        undef, undef, undef, $aifile_predestdir,
        $params->{description} if $params->{interactive};

    } elsif ($os_parsed eq 'linux') {

        # If it isn't interactive, we have nothing to do.
        $params->{interactive} or return;

        # We don't mess around with the executable itself.  However, we need to
        # create a .desktop file for it.

        my $desktopfile = calculate_installation_path
            'shortcutdir', "$basename.desktop", $feature;
        my $fdf = friendly_objname $desktopfile;
        ensure_directory $desktopfile, 1, 1, 1
            or return "could not create directory: $!";
        open my $fh, ">$utf8_layers", aipath2ospath($desktopfile) or
            return "could not write '$fdf': $!";

        progress_report 0, "Writing '$fdf'.";

        my $osfile_predestdir = aipath2ospath($aifile_predestdir);
        print $fh "[Desktop Entry]\n";
        print $fh "Type=Application\n";
        print $fh "Exec=$osfile_predestdir\n";
        print $fh "Name=", defined_or($params->{name}, $basename), "\n";
        defined $params->{description} and
            print $fh "Comment=", $params->{description}, "\n";
        print $fh "Version=", pvtransform
            (defined_or($params->{version}, $config->{options}{packageversion})),
            "\n";
        print $fh "Terminal=",
            (defined_or($params->{terminal}, 1) ? "true" : "false"), "\n";

        if (@png_images) {
            my %oksizes = (16 => 1, 24 => 1, 32 => 1, 48 => 1, 64 => 1,
                           72 => 1, 96 => 1, 128 => 1, 256 => 1);

            my @imageindexes = grep
                $png_width[$_] == $png_height[$_] && $oksizes{$png_width[$_]},
                0 .. $#png_images;

            @imageindexes or return "no icon image is appropriately sized";

            # For each image, copy it into the eventual location. We place the
            # image into the 'hicolor' icon theme, because that theme is used
            # as the fallback for all themes that don't override the icon (and
            # thus, is the appropriate theme to install the default icon into).
            my $written = 0;
            for my $i (@imageindexes) {
                my $iconfile = calculate_installation_path 'datarootdir',
                    "icons/hicolor/" .
                    "$png_width[$i]x$png_height[$i]/apps/$basename.png",
                        $feature;
                my $fif = friendly_objname($iconfile);

                ensure_directory $iconfile, 1, 1, 1
                    or return "could not create directory: $!";

                open my $fh2, ">$binary_layers", aipath2ospath($iconfile)
                    or return "couldn't write '$fif': $!";
                progress_report 0, "Writing '$fif'.";
                print $fh2 $png_images[$i];
                close $fh2;
            }

            print $fh "Icon=$basename\n";
        }

        close $fh;
    }

    return;
}

# This is sort-of like exeparams for directories, but much simpler because we
# just put links to them into docdir (on Linux) or shortcutdir (on Windows).
sub link_to_directory {
    my $aidir_predestdir = shift;
    my $linkname = shift;
    my $feature = shift;

    if ($os_parsed eq 'MSWin32') {
        calculate_installation_path 'shortcutdir',
            $config->{options}{packagename_ui} . " $linkname",
            $feature, undef, undef, undef, $aidir_predestdir;
    } elsif ($os_parsed eq 'linux') {
        my $link_from = calculate_installation_path 'docdir',
            $linkname, $feature;
        unlink $link_from;
        symlink aipath2ospath($aidir_predestdir), aipath2ospath($link_from);
    }
}


### Permissions

sub calculate_permissions {
    my $permission = shift;
    my $elevation = shift;
    my $readable = shift;
    my $executable = shift;      # 1 for executable, 2 for directory
    my $in_statedir = shift;

    my $user = 0;
    my $group = 0;
    my $octal = $executable ? 0755 : 0644;

    $permission and $permission ne 'ADMINISTRATOR' and
        $os_parsed eq 'MSWin32' and $permission = 'ANYONE';
    $elevation and $elevation ne 'ADMINISTRATOR' and
        $os_parsed eq 'MSWin32' and $elevation = 'ANYONE';

    if ($permission && $permission eq 'ANYONE') {
        if (($executable || 0) >= 2 && $in_statedir) {
            $octal = 0777;
        } elsif ($executable) {
            $octal = 0755;
        } elsif ($in_statedir) {
            $octal = 0666;
        } else {
            $octal = 0644;
        }
    } elsif ($permission && $permission eq 'ADMINISTRATOR') {
        if (($executable || 0) >= 2) {
            $octal = $readable ? 0755 : 0700;
        } elsif ($executable) {
            $octal = $readable ? 0744 : 0700;
        } else {
            $octal = $readable ? 0644 : 0600;
        }
    } elsif ($permission) {
        my $gid = getgrnam $permission;
        if (!$gid) {
            progress_report -1,
                "Cannot set nonexistent permission '$permission'";
        } else {
            $group = $gid;
            if (($executable || 0) >= 2) {
                $octal = $readable ? 0775 : 0770;
            } elsif ($executable) {
                $octal = $readable ? 0754 : 0750;
            } elsif ($in_statedir) {
                $octal = $readable ? 0664 : 0660;
            } else {
                $octal = $readable ? 0640 : 0644;
            }
        }
    }

    if ($elevation && ($executable || 0) != 1) {
        (progress_report -1, "Warning: " .
         "only executables can be granted permissions");
        $elevation = undef;
    }

    if ($elevation && $elevation eq 'ANYONE') {
        # nothing to do
    } elsif ($elevation && $elevation eq 'ADMINISTRATOR') {
        $octal |= 04000;
    } elsif ($elevation) {
        my $gid = getgrnam $elevation;
        if (!$gid) {
            progress_report -1,
                "Cannot set nonexistent permission '$permission'";
        } else {
            $group and
                progress_report -1,
                    "Cannot set distinct, nonempty permission and elevation";
            $group = $gid;
            $octal |= 02000;
        }
    }

    return ($octal, $user, $group);
}

sub set_permissions
{
    my $permission = shift;
    my $elevation = shift;
    my $aipath = shift;
    my $readable = shift;
    my $in_statedir = shift;

    my $ospath = aipath2ospath $aipath;

    $> == 0 or return 1; # if we're not elevated, don't bother changing perms
    $os_parsed eq 'MSWin32' and return 1;      # can't do this on Windows yet
    -l $ospath and return 1;                   # symlinks inherit permissions

    my $executable = -d $ospath ? 2 : -x $ospath ? 1 : 0;

    $! = 0;
    my ($octal, $user, $group) = calculate_permissions
        $permission, $elevation, $readable, $executable, $in_statedir;

    chown $user, $group, $ospath or return 0;
    return chmod $octal, $ospath;

}

##### Statefile handling
#
# We have a statefile on disk (bpath:aimake.objects), and a mirror of it in
# memory ($state). The statefile itself is protected via critical sections;
# all writing of the state file goes via atomically{}. This both leaves us in
# a sane state upon crash or signal, and makes it easier to implement parallel
# building in the future.
#
# For profiling to work correctly, all calls to atomically() must be preceded
# by a call to charge_profiled_time_to (otherwise time spent before the call
# might be charged to statefile writing).
{
    my $state_backup = {};
    my $write_on_crash = undef;
    my $last_clone_time = 0;

    sub write_statefile;

    sub atomically (&) {
        # The basic algorithm on a single-process system is to back up the
        # state in $state_backup, record the backup as the currently correct
        # version of the state, run the code block given, then record the
        # state as being currently correct. We only record one snapshot (even
        # to memory) every 10 seconds, in order to save on time spent in
        # dclone() (which otherwise accounts for 1/3 of all time spent in the
        # program); this means that only 10 seconds of progress will be lost
        # in a crash.
        if (time > $last_clone_time + 10) {
            $state_backup = dclone $state;
            $last_clone_time = time;
            write_statefile;
            charge_profiled_time_to('Backing up the statefile');
        }
        $write_on_crash = \$state_backup;
        $_[0]->();
        $write_on_crash = \$state;

        # This was saved in some early versions of 3.2; delete it if it
        # exists, it can be reconstructed from _intern.
        delete $state->{_unintern};
    }

    # Writes out the last consistent statefile (on error or exit).
    sub write_statefile {
        # We want to avoid dying to a signal while the statefile is being
        # written, so turn off signals temporarily. The FD is already held
        # open, so we write to the file, truncate it, and rewind it. On some
        # OSes, we can't turn off signals, so that's guarded via an eval.
        #
        # The truncate isn't completely critical; Storable will happily stop
        # reading early. So on systems without a working truncate, we don't
        # die, we just end up with a file that can't shrink. The rewind is
        # only important if the program doesn't immediately exit, so it's
        # outside the signals-disabled section.
        defined $write_on_crash or return;

        my ($allsigs, $oldsigs);

        eval {
            $allsigs = POSIX::SigSet->new;
            $allsigs->fillset;
            $oldsigs = POSIX::SigSet->new;
            sigprocmask(SIG_SETMASK, $allsigs, $oldsigs);
        };
        store_fd($$write_on_crash, $state_fh);
        eval { truncate $state_fh, tell $state_fh; };
        defined $oldsigs and eval {
            sigprocmask(SIG_SETMASK, $oldsigs);
        };
        seek $state_fh, 0, SEEK_SET;
    }
}

# Like atomically, but for reads.
sub atomic_read(&) {
    $_[0]->();
}

# Set up our crash handlers.
# A crash handler.
$SIG{__DIE__} = sub {
    die @_ if $^S;
    write_statefile;
    confess @_;
};
use sigtrap qw/die normal-signals/; # convert SIGINT etc. into die()

# Initializes the statefile at the start of the program.
# It doesn't make sense to atomically{} here, because the statefile doesn't
# exist in memory before the call its used.
#
# This also initializes the unintern cache; because the unintern hash is the
# exact reverse of the intern hash, we only need to save one in the save file.
#
# This also locks the statefile, to prevent two copies of aimake running
# simultaneously on the same build directory (which wouldn't work and which
# would likely be a mistake anyway).
sub read_statefile {
    $state = {};
    my $statefn = aipath2ospath(statefilename);

    # We want to open an already-existing file, or not clobber an already
    # existing file; this way, if two new builds are started simultaneously in
    # the same directory, we don't get one clobbering the other's state
    # (because one of the processes will fail the lock before it tries to do
    # any reading or writing).
    sysopen $state_fh, $statefn, O_RDWR | O_CREAT;
    binmode $state_fh, $binary_layers;
    flock $state_fh, (LOCK_EX | LOCK_NB)
        or die "Cannot lock statefile '$statefn': is aimake already running?";

    # This could theoretically go wrong if someone renames the state file
    # beneath us, but at that point, we can't really expect sane behaviour
    # anyway :)
    if (-z $statefn) {
        $state = {};
        store_fd($state, $state_fh) or die "Error writing statefile: $!";
    } else {
        $! = 0;
        # retrieve_fd can die; it can also merely set $! and return undef
        $state = fd_retrieve($state_fh);
        defined $state or die "Error reading statefile: $!";
    }

    $state->{_intern} and %unintern = reverse %{$state->{_intern}};

    seek $state_fh, 0, SEEK_SET; # rewind the file
}
END {
    defined $state_fh and flock $state_fh, LOCK_UN;
    defined $state_fh and close $state_fh;
}

##### Rule logic

sub rule_applies_to_object {
    my $rulename = shift;
    my $objname = shift;
    return unless $config->{rules}{$rulename};
    my $objpattern = $config->{rules}{$rulename}{object};
    defined $objpattern or die "Rule '$rulename' has no object";
    (ref $objpattern) =~ /\bRegexp$/ and return $objname =~ $objpattern;
    return $objname eq $objpattern;
}

sub rules_that_apply_to {
    my $objname = shift;
    my @rv = ();
    $objname =~ /^([a-z_]+):/;
    my $objprefix = $1;

    for my $rulename (keys %{$rule_object_prefixes{$objprefix}},
                      keys %{$rule_object_prefixes{any}}) {
        rule_applies_to_object $rulename, $objname or next;
        push @rv, $rulename;
    }
    return @rv;
}
memoize('rules_that_apply_to');

sub objects_for_rule {
    my $rulename = shift;
    my @rv = ();
    return unless $config->{rules}{$rulename};
    my $objpattern = $config->{rules}{$rulename}{object};
    my $objvalue = 'sys:no_object';
    (ref $objpattern) !~ /\bRegexp$/ and $objvalue = $objpattern;
    for my $iobject (keys %{$state->{outdep_by_object}}, intern $objvalue) {
        rule_applies_to_object $rulename, unintern $iobject or next;
        push @rv, unintern $iobject;
    }
    return @rv;
}

##### Pair heuristics
#
# Much of the performance of aimake depends on running the pairs in the right
# order. We record which pairs are likely to run soon (this only affects
# efficiency, not correctness); which pairs are unlikely to run soon (ditto);
# and cache which pairs aren't runnable right now (it's OK for that list to
# have false negatives but not false positives).
#
# %likely_runnable is populated by both the object logic, and the main loop,
# and depopulated by the main loop;
# %not_runnable_yet and %unlikely_runnable are both populated and depopulated
# by the main loop.
#
# The three lists are mutually exclusive.

my %likely_runnable = ();
my %not_runnable_yet = ();
my %unlikely_runnable = ();

sub prioritize_pair {
    my $pair = shift;

    return if $likely_runnable{$pair};

    if ($not_runnable_yet{$pair}) {
        progress_report 3, "Not prioritizing $pair because nothing " .
            "has changed since it last failed to run.";
    } else {
        $likely_runnable{$pair} = 1;
        delete $unlikely_runnable{$pair};
        progress_report 3, "Prioritizing $pair because another pair needs its output.";
    }
}

# Tries to find a pair that is likely to produce the given object, and
# prioritizes it. For now, this only works with dependencies: objects.  Note
# that these don't have to correspond to a pair, but nothing disastrous
# happens if they don't; they just hang around in %likely_runnable until the
# next iteration of the main loop, which deletes them for not being changed.
sub prioritize_object {
    my $obj = shift;
    my ($objtype, $objvalue, $objinner) = parse_objname $obj;

    if ($objtype eq 'dependencies') {
        return if $likely_runnable{"$objvalue $objinner"};
        progress_report 3, "Prioritizing '$obj' because another pair needs it.";
        prioritize_pair "$objvalue $objinner";
    }
}

##### Object logic
#
# This does most of the actual work of aimake.
#
# We use the following state to store information about rules, pairs, and
# objects:
#
# Each pair knows which objects are unsure via it; each object knows how many
# pairs have it as unsure (->{unsure_by_pair}, ->{unsure_count_by_object})
#
# Each pair knows which objects it proviced last time it ran (and with which
# output dependencies); each object knows which pairs proviced it
# (->{outdep_by_pair}, etc.)
#
# Each pair knows what errors or warnings it output last time it ran; that's
# in ->{errwarn_by_pair}. Warnings have 'W:' at the start; errors have 'E:'.
#
# Each pair knows the objects in its expanded use dependencies, and vice versa
# (->{xuse_by_pair} (an array, not a hash), ->{xuse_by_object}). If the pair
# is changed or blocked, then xuse_by_pair can be undef; in such a case,
# xuse_by_object doesn't contain that pair. The innermost keys of
# xuse_by_object list the objects originally responsible for including that
# xuse; this gives better error messages. There is also a hash
# ->{xuse_prevpair} that, for each pair and each object in its expanded use
# dependencies, specifies the object that created that object (if any); this
# is only meaningful when xuse_by_pair is not undef, and is used by unsureness
# checks to determine whether an unsure object would have an effect on a pair
# or not.
#
# There is a list of changed pairs, ->{changed_pairs}. The values of that hash
# list the reason the pair has not been marked as unchanged yet.
#
# A pair can be blocked, meaning that it has a nonexistent object in its
# command (that isn't its object): this gives (->{blocked_by_object},
# ->{blocked_by_pair}). If a rule would be marked as changed, it can be marked
# as blocked instead, and becomes marked as changed only when the object
# blocking it comes into existence. ->{blocked_by_pair}{$pair} is a scalar.
#
# Out of these various interesting statefile elements, some are read-only
# (i.e. you can change the value, but not change /within/ the value), and
# others cannot be shared. The read-only elements are output dependencies
# (i.e. $state->{outdep_by_$x}{$y}{$z}, and xuse_by_pair lists; everything
# else cannot share.

### Mutators
# In order to prevent things getting out of sync, we use mutators for all
# this. The mutators have to be contained in an appropriate atomically{}
# themselves; we don't add one because the atomicity often needs to expand
# to more than a single access.
#
# The mutators also call each other when necessary; e.g. marking a pair as
# changed will mark all objects it proviced on its last run as unsure.

# We cache sureness very aggressively, because it's the inner loop of the
# program. If the sureness calculation on pair $pair was based on facts about
# $pairobj2 (where $pairobj2 is a pair or an object), we set
# $pair_is_sure_because{$pair1}{$pairobj2} and
# $pair_is_sure_rindex{$pairobj2}{$pair1}; $pairobj2 is interned, $pair1
# isn't.
#
# Exception: $pair_is_sure_because, $pair_is_sure_rindex are left unset if
# they're implied by transitive closure (i.e. if pair 1 is sure because of
# pair 2, and pair 2 is sure because of pairobj 3, then it won't be recorded
# that pair 1 is sure because of pairobj 3). This is to avoid needing
# quadratic memory, which was definitely a problem for some people.
#
# The facts about $pairobj2 that could be relevant are:
#
# - For pairs:
#   - Whether it has an xuse, and what its xuse is;
#   - What its xuse_prevpair is (but this is only added to by pair_is_sure
#     itself, and is reset when the xuse is, so can never get out of date);
#
# - For objects:
#   - How many, and which, pairs provice it;
#   - Which pairs the object is sure via.
my %pair_is_sure_because; # hash to undef
my %pair_is_sure_rindex;  # hash to undef
my %sure_pair_cache;      # hash to undef
my %unsure_pair_cache;    # hash to unsureness list
sub invalidate_pair_or_object_sureness;
sub invalidate_pair_or_object_sureness {
    my $ipairobj2 = intern shift;
    for my $pair1 (keys %{$pair_is_sure_rindex{$ipairobj2}}) {
        delete $pair_is_sure_rindex{$_}{$pair1}
            for keys %{$pair_is_sure_because{$pair1}};
        delete $pair_is_sure_because{$pair1};
        delete $sure_pair_cache{$pair1};
        delete $unsure_pair_cache{$pair1};
        invalidate_pair_or_object_sureness $pair1;
    }
    delete $pair_is_sure_rindex{$ipairobj2};
}

sub mark_object_unsure {
    my $pair = shift;
    my $obj = shift;
    my $reason = shift;
    my $ipair = intern $pair;
    my $iobj = intern $obj;
    progress_report 4, "Want to mark $obj as unsure via $pair ($reason)...";
    $state->{unsure_by_pair}{$ipair}{$iobj} and return;
    progress_report 4, "Marking $obj as unsure via $pair.";
    $state->{unsure_by_pair}{$ipair}{$iobj} = 1;
    $state->{unsure_count_by_object}{$iobj} ||= 0;
    $state->{unsure_count_by_object}{$iobj}++;
    invalidate_pair_or_object_sureness $obj;
}
sub object_exists;
sub parse_objname;
sub mark_object_sure {
    my $pair = shift;
    my $obj = shift;
    my $reason = shift;
    my ($objtype, undef) = parse_objname $obj;
    my $ipair = intern $pair;
    my $iobj = intern $obj;
    progress_report 4, "Want to mark $obj as sure via $pair ($reason)...";
    unless ($state->{unsure_by_pair}{$ipair}{$iobj}) {
        delete $state->{unsure_by_pair}{$ipair} # undo autovivification
            unless keys %{$state->{unsure_by_pair}{$ipair}};
        return;
    }
    progress_report 4, "Marking $obj as sure via $pair.";
    delete $state->{unsure_by_pair}{$ipair}{$iobj};
    delete $state->{unsure_by_pair}{$ipair}
        unless keys %{$state->{unsure_by_pair}{$ipair}};
    $state->{unsure_count_by_object}{$iobj}--;
    delete $state->{unsure_count_by_object}{$iobj}
        unless $state->{unsure_count_by_object}{$iobj};

    # If the object is one we maintain on the filesystem, and it's marked as
    # sure and nonexistent (e.g. if it was previously output, but the pair
    # that previously output it stopped generating it), delete it. (Nothing
    # would go wrong with the object sitting around on the filesystem, but
    # it's a bit crufty to leave old object files around like that.)
    #
    # This also makes it possible to implement a "clean" mode via adding a
    # nonexistent object (like sys:clean) as a dependency of every pair.
    if ($objtype eq 'bpath' && !object_exists($obj)) {
        my $fn = aipath2ospath($obj);
        if (-e $fn && -f _) {
            progress_report 1, "Deleting no longer generated file '$fn'";
            unlink $fn or
                progress_report -1, "Could not delete old file '$fn': $!";
            # Also delete empty directories going upwards from fn. We know
            # that a rmdir will fail on the bpath itself, because we have
            # aimake.objects in there. verify_writable is complete paranoia
            # because programs that recursively remove directories are
            # historically a source of system-breaking issues.
            $obj = aipath_parent($obj);
            $obj = aipath_parent($obj) while
                (verify_writable $obj) && (rmdir aipath2ospath($obj));
        }
    }

    invalidate_pair_or_object_sureness $obj;
    %unsure_pair_cache = ();
}
sub mark_pair_xuse_unknown;
sub mark_pair_changed {
    my $pair = shift;
    my $reason = shift;
    my ($rulename, $objname) = parse_pairname $pair;
    my $ipair = intern $pair;
    progress_report 4, "Want to mark $pair as changed ($reason)...";
    return if $state->{changed_pairs}{$ipair};
    return if $state->{blocked_by_pair}{$ipair};
    progress_report 4, "Marking $pair as changed.";

    # Special case: If a pair currently has no outputs and at least one
    # nonexistent, sure xuse, there's no need to mark it as changed now
    # because it'll be marked as changed when that xuse starts existing. This
    # optimization is only safe when we actually know the xuse; otherwise, we
    # can end up with a pair with unknown xuse but not marked as changed,
    # which violates our invariants. This optimization is also unsafe if the
    # pair has a rule that doesn't apply to the object, or if the object does
    # not exist.
    if (!$state->{outdep_by_pair}{$ipair} && object_exists($objname) &&
        defined $state->{xuse_by_pair}{$ipair} &&
        rule_applies_to_object $rulename, $objname) {
        # $_ is an intern in this loop
        $state->{unsure_count_by_object}{$_} or object_exists(unintern $_)
            or return for @{$state->{xuse_by_pair}{$ipair}};
    }

    # Another special case: if the pair currently has no outputs and a missing
    # object in its command, we can mark it as blocked rather than changed
    # (which is a lot more efficient, because the main loop doesn't need to
    # calculate its xuse in order to know whether to run it or not. If we
    # already know the xuse, this is pointless, as we'll already have left
    # if it matters. Again, we require the object itself to exist and the rule
    # to match the object.
    elsif (!$state->{outdep_by_pair}{$ipair} && object_exists($objname) &&
           rule_applies_to_object $rulename, $objname) {
        my $cmd = $config->{rules}{$rulename}{command};
        if ($cmd) {
            my @cmd = @$cmd;
            complete_and_extend \$_, $objname for @cmd;
            for my $blocker (@cmd) {
                if (!$state->{unsure_count_by_object}{intern $blocker} &&
                    !object_exists($blocker)) {
                    $state->{blocked_by_object}{intern $blocker}{$ipair} = 1;
                    $state->{blocked_by_pair}{$ipair} = intern $blocker;
                    return;
                }
            }
        }
    }

    $state->{changed_pairs}{$ipair} = 'has not been checked yet';
    for my $iobj (keys %{$state->{outdep_by_pair}{$ipair}}) {
        mark_object_unsure $pair, unintern $iobj, "pair changed";
    }
    delete $state->{outdep_by_pair}{$ipair}
        unless keys %{$state->{outdep_by_pair}{$ipair}};
}
sub mark_pair_unchanged {
    my $pair = shift;
    my $reason = shift;
    progress_report 4, "Marking $pair as unchanged ($reason).";
    my $ipair = intern $pair;
    delete $state->{changed_pairs}{$ipair};
    if (exists $state->{blocked_by_pair}{$ipair}) {
        my $iblocker = $state->{blocked_by_pair}{$ipair};
        delete $state->{blocked_by_object}{$iblocker}{$ipair};
        delete $state->{blocked_by_object}{$iblocker}
            unless keys %{$state->{blocked_by_object}{$iblocker}};
        delete $state->{blocked_by_pair}{$ipair};
    }
}
sub inappropriate_prevpair;
sub set_proviced_outdeps {
    my $pair = shift;
    my $obj = shift;
    my $outdeps = shift; # interned, undef if no longer proviced by the rule
    my $outdepends_changed = 1;
    my $ipair = intern $pair;
    my $iobj = intern $obj;

    progress_report 4, "Want to set hash of $obj via $pair...";

    # We're now sure of what happens when the rule is run. However, we can't
    # call mark_object_sure until the hash is correct; mark_object_sure will
    # attempt to delete a bpath object that nothing claims to generate, and
    # that would happen for a new object because we haven't set its hash yet.

    # There's no need to change anything but the sureness flag if the hash
    # didn't change.
    my $old_outdeps = $state->{outdep_by_pair}{$ipair}{$iobj};
    delete $state->{outdep_by_pair}{$ipair}
        unless keys %{$state->{outdep_by_pair}{$ipair}};
    if (!defined $outdeps && !defined $old_outdeps) {
        mark_object_sure $pair, $obj, "outdeps stayed undef";
        return;
    }
    if (deepequals($outdeps, $old_outdeps)) {
        mark_object_sure $pair, $obj, "hash stayed the same";
        return;
    }

    if (deepequals($outdeps, $old_outdeps)) {
        $outdepends_changed = 0;
    }

    progress_report 4, "Setting hash of $obj via $pair.";

    invalidate_pair_or_object_sureness $obj;

    # Set outdep_by_pair, outdep_by_object.
    if (defined $outdeps) {
        $state->{outdep_by_pair}{$ipair}{$iobj} = $outdeps;
        $state->{outdep_by_object}{$iobj}{$ipair} = $outdeps;
    } else {
        delete $state->{outdep_by_pair}{$ipair}{$iobj};
        delete $state->{outdep_by_pair}{$ipair}
            unless keys %{$state->{outdep_by_pair}{$ipair}};
        delete $state->{outdep_by_object}{$iobj}{$ipair};
        delete $state->{outdep_by_object}{$iobj}
            unless keys %{$state->{outdep_by_object}{$iobj}};
    }

    mark_object_sure $pair, $obj, "hash changed";

    # If the object blocks any pairs, unblock them and mark them as changed
    # again.
    for my $icpair (keys %{$state->{blocked_by_object}{$iobj}}) {
        my $cpair = unintern $icpair;
        mark_pair_unchanged $cpair, "unblocked by changed hash";
        mark_pair_xuse_unknown $cpair, "unblocked by non-special object"
            if $obj !~ objtype_is_special_regex;
        mark_pair_changed $cpair, "unblocked but is still changed";
    }

    # Changing the object changes pairs that depend on it. Unless it's a
    # special object, it can also change the expanded use dependencies of
    # pairs that depend on it (although not with respect to that object, only
    # with respect to other objects). This must be done after outdep_by_object
    # is set, so that mark_pair_changed won't defer the changed setting until
    # this object comes into existence (falsely believing it not to exist).
    # However, we can (and should, for efficiency reasons) skip any pairs that
    # cannot possibly look at the object via $pair.
    #
    # Iterating over xuse_by_object may miss out some pairs, but only changed
    # pairs with unknown xuses (on which operating would be pointless anyway).
    for my $icpair (keys %{$state->{xuse_by_object}{$iobj}}) {
        my $cpair = unintern $icpair;
        # We need to mark the xuse unknown before marking the pair as changed,
        # in case the old xuse had a dependency on a nonexistent object (which
        # could cause mark_pair_changed to be a no-op) but the new xuse only
        # contains existing objects. (If the pair is not already changed, then
        # mark_pair_changed will recalculate the xuse and mark the xuse as
        # known again.)  Exception: if the outdepends stay the same, we know
        # the xuse calculation will too.
        mark_pair_xuse_unknown $cpair, "old xuse changed hash"
            if $outdepends_changed && $obj !~ objtype_is_special_regex;
        mark_pair_changed $cpair, "xuse changed hash";
    }

    # If an object comes into existence, we need to add pairs and recalculate
    # those.
    if (!defined $old_outdeps) {
        my @rules = rules_that_apply_to $obj;
        for my $rule (@rules) {
            my $cpair = "$rule $obj";
            mark_pair_xuse_unknown $cpair, "new pair because new object";
            mark_pair_changed $cpair, "new pair";
        }
    }

    # If a rule changes, we need to add pairs for objects it now applies to
    # (and used not to), and recalculate all pairs containing it (the command
    # may have changed, meaning that the xuses are different). Marking the
    # rules as changed will be a no-op in most cases, but it will matter if
    # the pair is brand new.  We also need to unblock any pairs that
    # previously depended on this rule, even if they don't any more.
    #
    # Additionally, if a dependency rule changes, we need to recalculate xuses
    # of anything that now depends on its object, and didn't before. (We don't
    # need to recalculate anything that depended on its object beforehand; if
    # it needs to be recalculated, it will observe the dependencies: object
    # that is already in its xuse being changed or deleted.)
    if ($obj =~ /^config_rule:/) {
        my (undef, $objvalue) = parse_objname $obj;
        progress_report 4, "Adding pairs from rule $objvalue";
        my @objects = objects_for_rule $objvalue;
        my $r = $config->{rules}{$objvalue};
        for my $o (@objects) {
            my $cpair = "$objvalue $o";
            mark_pair_xuse_unknown $cpair, "rule changed";
            mark_pair_unchanged $cpair, "unblocking a changed rule";
            mark_pair_changed $cpair, "rechecking a rule after it changed";
            if (defined $r && $r->{number_of_depend_actions}) {
                for my $idpair (keys %{$state->{xuse_by_object}{intern $o}}) {
                    my $dpair = unintern $idpair;
                    # If dependencies:$objvalue:$o is already an xuse of
                    # $dpair, we don't need to do anything. Otherwise, we need
                    # to recalculate the xuse, because that object needs to be
                    # added (and possibly others).
                    my $dep = "dependencies:$objvalue:$o";
                    my $idep = intern $dep;
                    unless (exists $state->{xuse_by_object}{$idep}{$idpair}) {
                        # Unautovifify $dep's xuse_by_object.
                        delete $state->{xuse_by_object}{$idep}
                            unless keys %{$state->{xuse_by_object}{$idep}};
                        mark_pair_xuse_unknown $dpair,
                            "object gained a new dependency via rule change";
                        mark_pair_changed $dpair,
                            "dependency rule change left xuse unknown";
                    }
                }
            }
        }
        for my $iblocked (keys %{$state->{blocked_by_pair}}) {
            my $blocked = unintern $iblocked;
            my ($blockedrule, undef) = parse_pairname $blocked;
            if ($blockedrule eq $objvalue) {
                mark_pair_xuse_unknown $blocked, "blocked rule changed";
                mark_pair_unchanged $blocked,
                    "unblocking a rule because it changed";
                mark_pair_changed $blocked,
                    "unblocked by rule change but is still changed";
            }
        }
    }

    # Remove any autovivified xuses, if the object isn't used at all.
    delete $state->{xuse_by_object}{$iobj}
        unless keys %{$state->{xuse_by_object}{$iobj}};
    delete $state->{blocked_by_object}{$iobj}
        unless keys %{$state->{blocked_by_object}{$iobj}};
}
# Marks a pair as sure, and sets all its outputs. Called after a pair is run
# successfully. Also set the pair's warning messages (if any).
sub record_pair_outputs {
    my $pair = shift;
    my %obj_to_outdeps = %{+shift}; # both keys and values interned
    my $warnings = shift;
    my $ipair = intern $pair;

    progress_report 4, "Setting hashes for successful run of $pair.";

    for my $ioldobj (keys %{$state->{outdep_by_pair}{$ipair}}) {
        # Force the keys to exist for any object that was there before.
        $obj_to_outdeps{$ioldobj} = undef
            unless exists $obj_to_outdeps{$ioldobj};
    }
    if (defined $state->{unsure_by_pair}{$ipair}) {
        for my $ioldobj (keys %{$state->{unsure_by_pair}{$ipair}}) {
            # Force the keys to exist for any objects unsure via the pair,
            # even if it isn't being output (this can happen when there was
            # previously a dependency loop).
            $obj_to_outdeps{$ioldobj} = undef
                unless exists $obj_to_outdeps{$ioldobj};
        }
    }
    set_proviced_outdeps $pair, unintern $_, $obj_to_outdeps{$_}
        for keys %obj_to_outdeps;
    mark_pair_unchanged $pair, "recording pair outputs";
    if (defined $warnings && $warnings ne '') {
        $state->{errwarn_by_pair}{$ipair} = "W:$warnings";
    } else {
        delete $state->{errwarn_by_pair}{$ipair};
    }
    delete $state->{outdep_by_pair}{$ipair}
        unless keys %{$state->{outdep_by_pair}{$ipair}};
}
# Called when a pair errors out. Marks all its old outputs as unsure, but the
# rule itself as unchanged (thus forcing all those outputs' indirect
# descendants into limbo).
sub record_pair_error {
    my $pair = shift;
    my $errmsg = shift;

    progress_report 4, "Setting hashes for unsuccessful run of $pair...";
    my $ipair = intern $pair;

    mark_pair_unchanged $pair, "recording pair error";
    for my $iobj (keys %{$state->{outdep_by_pair}{$ipair}}) {
        mark_object_unsure $pair, unintern $iobj, "unsure due to error";
    }
    delete $state->{outdep_by_pair}{$ipair}
        unless keys %{$state->{outdep_by_pair}{$ipair}};

    !defined $errmsg || $errmsg eq '' and
        croak "record_pair_error needs an error message";
    $state->{errwarn_by_pair}{$ipair} = "E:$errmsg";
}

### Resolving object contents

# Helper routine
sub not_empty_array {
    my $a = shift;
    return 1 unless ref $a eq 'ARRAY';
    return scalar @$a;
}

# Sometimes we'll have multiple possible versions of a provided object (this
# happens most often with symbol:main, but can happen for other provided
# objects, too). For produced objects, this is an error (they'd overwrite each
# other on the filesystem), but for provided objects, we work out which to use
# based on filename similarity. This takes two object names as arguments (the
# provided object, and the object that wants to use it), and the list of
# possible pairs, and returns a list of top-scoring pairs to use. (This will
# be empty if there are no usable pairs, a single element unless there is a
# tie, and all tied elements otherwise.)
#
# This routine is only called from recalculate_pair_xuse, but is placed in a
# separate subroutine for clarity.
sub appropriate_pairs_for_object {
    my $provided = shift;
    my $user = shift;
    my @providers = @_;

    scalar @providers == 0 and return ();
    scalar @providers == 1 and return ($providers[0]);

    my $iprovided = intern $provided;

    $provided =~ multiple_providers_ok_regex and return ('sys:fuse');

    my ($prvtype, undef) = parse_objname $provided;
    $objtype_provided{$prvtype} or
        croak "Object $provided is produced by multiple rules: @providers";

    progress_report 4, "Finding appropriate pair for $provided (user $user)...";

    my $best = undef;
    my $ibest = undef;
    my $bestscore = -1;
    my @tie = ();
    # We error out if we have two equally good providers.
    for my $provider (@providers) {
        my ($prule, $obj) = parse_pairname $provider;
        my ($objtype, $objvalue, $objinner) = parse_objname $obj;
        my $score = 0;
        if ($objtype eq 'spath' || $objtype eq 'standardlib') {
            # Avoid if possible. It's better than an entirely virtual
            # provider, though, and standardlibs are better than spath objects.
            $score = 1;
            $objtype eq 'standardlib' and $score = 2;

            my @aipath = parse_aipath $obj;
            # We add some bonuses based on the name. In particular, we prefer
            # to use libraries following the lib... naming convention, to
            # avoid linking against the dynamic loader explicitly for free()
            # or something silly like that, and libc is the best option when
            # available.
            $aipath[-1] =~ /^lib/ and $score += 0.1;
            $aipath[-1] =~ /^libc\b/ and $score += 0.4;
            $aipath[-1] =~ /^libmingw\b/ and $score += 0.4;
            $aipath[-1] =~ /^libmsvcrt\b/ and $score += 0.4;
        } elsif ($objtype =~ /^b?path/s) {
            # The score depends on how many characters match at the
            # start of the objvalue.
            my ($utype, $uvalue, $uinner) = parse_objname $user;
            ($utype, $uvalue, $uinner) = parse_objname $uinner
                while $utype eq 'symbolset';
            $score = 3;
            while ($uvalue ne '' && $objvalue ne '' &&
                   substr($uvalue, 0, 1, '') eq substr($objvalue, 0, 1, '')) {
                $score++;
            }
        }
        # Add a small bonus based on the rule that provided the object.
        # TODO: This should work out which action provided it.
        if (defined $config->{rules}{$prule}) {
            $score += $config->{rules}{$prule}{actions}[0]{preference}
                / 100000;
        }

        # A tie is benign if we have two rules with the same object, and it
        # isn't sys:no_object; it's also benign if both rules have an empty
        # outdepends (this is to make the placeholder symbols for reverse
        # imports work correctly). Otherwise, it's a problem.
        my $iprovider = intern $provider;
        if ($score == $bestscore &&
            ((parse_pairname $best)[1] ne $obj || $obj eq 'sys:no_object') &&
            (not_empty_array($state->{outdep_by_object}{$iprovided}{$iprovider}) ||
             not_empty_array($state->{outdep_by_object}{$iprovided}{$ibest}))) {
            push @tie, $provider;
        } elsif ($score > $bestscore) {
            @tie = ();
            ($ibest, $best, $bestscore) = ($iprovider, $provider, $score);
        }
        progress_report 4, "Score for $provider is $score";
    }
    if (@tie) {
        unshift @tie, $best;
        return @tie;
    }
    return $best if defined $best;
    return ();
}

# Determines which hash of an object we're supposed to be building from. This
# is used for produced bpath:,path:,spath:,standardlib: objects to determine
# whether the file has changed on disk.
sub find_hash_on_disk {
    my $obj = shift;
    my $iobj = intern $obj;
    return unless $state->{outdep_by_object}{$iobj};
    die "Produced object $obj produced by more than one rule"
        unless 1 == keys %{$state->{outdep_by_object}{$iobj}} ||
        $obj =~ multiple_providers_ok_regex;
    my @ioutdeps = @{(values %{$state->{outdep_by_object}{$iobj}})[0]};
    (unintern $_) =~ /^hash_on_disk:([^:]+):\Q$obj\E$/ and
        return $1 for @ioutdeps;
    die "Produced object $obj has no hash_on_disk: dependency";
}

### Dependency calculations

# We want to avoid allowing an object to be created in terms of itself. Rules
# cannot use their own output as a dependency, nor any output from rules or
# objects that are marked as avoided for it.
sub inappropriate_prevpair {
    my $pair = shift;
    my $pair2 = shift;
    my ($rule, $obj) = parse_pairname $pair;
    my ($rule2, $obj2) = parse_pairname $pair2;
    if (defined $config->{rules}{$rule}) {
        my $avoid_rules = $config->{rules}{$rule}{avoid_rules};
        defined $avoid_rules and $rule2 =~ $avoid_rules and
            progress_report 5, "($pair,$pair2) inappropriate: avoid_rules"
            and return 1;
        my $avoid_objects = $config->{rules}{$rule}{avoid_built_from};
        if (defined $avoid_objects) {
            complete_and_extend \$avoid_objects, $obj;
            progress_report 5, "($pair,$pair2) inappropriate: avoid_built_from",
            return 1 if $avoid_objects eq $obj2;
        }
    }
    return unless $state->{outdep_by_object}{intern $obj2};
    $state->{outdep_by_object}{intern $obj2}{intern $pair} and
        progress_report 5, "($pair,$pair2) inappropriate: output"
        and return 1;
    return;
}

# We calculate the xuse for a pair via looping over its command, adding in the
# following dependencies recursively:
#
# - The pair's object, if it's a provicion rule and if propagate_usedeps is
#   not set;
# - The pair's object but /not/ any of its xuses, otherwise;
# - The pair's command;
# - The pair's rule;
# - Any dependencies: object that could possibly refer to an object in the set
#   (this can be determined statically);
# - Any outdepends that were added by the pair that proviced an object in the
#   set (this is the hash of a provided object);
# - sys:clean, if there's a nonexistent proviced object in the set.
#
# In the case where there are multiple reasonable possible ancestors, we hold
# off on choosing an ancestor immediately, and then try again once the set of
# xuses is complete, preferring to choose one that's already in the set. We
# report a tie if there's still multiple ancestors with the same degree of
# reasonability. We also never choose any of the rule's outputs as an ancestor
# for the rule itself.
#
# We also preserve order in xuse_by_pair, because the order is sometimes
# sigificant. (xuse_by_object is unordered.)
sub recalculate_pair_xuse {
    my $pair = shift;
    my $report_ties = shift;
    my ($rule, $obj) = parse_pairname($pair);
    progress_report 4, "Calculating xuse of $pair";

    my $iobj = intern $obj;
    my $ipair = intern $pair;

    # If we aren't reporting ties, we reset the xuse, invalidating sureness
    # caches too. If we are, we can't reset the xuse, or the pair ends up
    # dropping off the face of the aimake.objects file altogether;
    # xuse_by_pair is meant to be set for all unchanged pairs.
    $report_ties or reset_pair_xuse($pair);

    my $r = $config->{rules}{$rule};
    # Add the pair's rule to the list.
    my %xuse = ("config_rule:$rule" => $obj);
    my @xuse = ("config_rule:$rule");
    if (!$r) {
        # The rule's meant to specify the dependencies, but the rule isn't
        # there, so we specify the rule itself and sys:clean as the xuse.
        progress_report 4, "Rule $rule is missing";
        $xuse{'sys:clean'} or push @xuse, 'sys:clean';
        $xuse{'sys:clean'} = "config_rule:$rule";
    } else {
        # Add the pair's command to the list.
        my @command = (defined_or($r->{command}, 'intcmd:nop'));
        scalar @command == 1 && ref $command[0] eq 'ARRAY'
            and @command = (@{$command[0]});
        # Add the pair's object to the list.
        if ($r->{object_dependency} eq 'auto' &&
            !$r->{number_of_depend_actions}) {
            push @command, '';
        }
        # We can't run the rule if the object was produced by a rule it
        # avoids.
        my ($objtype, undef, undef) = parse_objname $obj;
        if ($r->{avoid_rules} && !$objtype_provided{$obj} &&
            $state->{outdep_by_object}->{$iobj}) {
            my ($iproducer, undef) = keys %{
                $state->{outdep_by_object}->{$iobj}};
            my ($prodrule, undef) = parse_pairname unintern $iproducer;
            if ($prodrule =~ $r->{avoid_rules}) {
                $xuse{'sys:clean'} or push @xuse, 'sys:clean';
                $xuse{'sys:clean'} = "config_rule:$rule";
            }
        }

        # Complete and extend the object names in the command while we're
        # outside our main loop. This avoids having to do a no-op completion
        # and extension of all the use dependencies.
        complete_and_extend \$_, $obj for @command;

        # For install rules, add sys:installing to the list.
        $r->{number_of_install_actions} and push @command, 'sys:installing';

        my %xuse_reason = ();
        my $pass = 1;
        my @postponed = ();
        my %pass1_xuse_pairs = ();
        while (@command || ($pass == 1 && @postponed)) {
            if (!@command) {
                @command = @postponed;
                $pass = 2;
            }

            my $o = shift @command;
            next if $xuse{$o};
            my $io = intern $o;

            # Add the outdepends to the list, if any. (Or postpone it for
            # later if we have multiple reasonable possibilities and we're
            # still on the first pass.)  This is possible when the object is
            # provided or produced, but not if it's special (because it won't
            # have any outdep_by_object hash to check the outdepends from).
            if ($o !~ objtype_is_special_regex) {
                my @ancestors = sort map unintern $_,
                    keys %{$state->{outdep_by_object}{$io}};
                delete $state->{outdep_by_object}{$io} unless
                    keys %{$state->{outdep_by_object}{$io}};
                @ancestors = grep !inappropriate_prevpair($pair, $_),
                    @ancestors;
                if ($pass == 2 && $o !~ multiple_providers_ok_regex) {
                    # It would be slightly more accurate to check the use
                    # dependencies of the pairs we add to see if they're
                    # already there. But this method is faster and easier to
                    # read, and will produce the same results in pretty much
                    # all cases.
                    my @filtered_ancestors =
                        grep $pass1_xuse_pairs{$_}, @ancestors;
                    @filtered_ancestors and @ancestors = @filtered_ancestors;
                    @ancestors = appropriate_pairs_for_object $o, $obj,
                         @ancestors;
                }
                if (@ancestors > 1 && $o =~ multiple_providers_ok_regex) {
                    # Fuse the output from the various providers.
                    $report_ties or
                        $state->{xuse_prevpair}{$ipair}{$io} =
                        intern 'nonexistent sys:fuse';
                    my %udeps = ();
                    for my $ancestor (@ancestors) {
                        for my $iudep (@{$state->{outdep_by_pair}
                                        {intern $ancestor}{$io}}) {
                            my $udep = unintern $iudep;
                            $udep =~ /^hash_on_disk:/ and next;
                            push @command, $udep unless $udeps{$udep};
                            $udeps{$udep} = 1;
                        }
                    }
                    $xuse_reason{$_} = $o for keys %udeps;
                } elsif (@ancestors > 1 && $pass == 1) {
                    push @postponed, $o;
                    next;
                } elsif (@ancestors == 1) {
                    $pass == 1 and $pass1_xuse_pairs{$ancestors[0]} = 1;
                    my $iancestor = intern $ancestors[0];
                    $report_ties or
                        $state->{xuse_prevpair}{$ipair}{$io} = $iancestor;
                    my @iudeps = @{$state->{outdep_by_pair}{$iancestor}{$io}};
                    push @command, grep $_ !~ /^hash_on_disk:/,
                        map unintern $_, @iudeps;
                    $xuse_reason{unintern $_} = $o for @iudeps;
                } elsif (@ancestors > 1 && $pass == 2 && $report_ties) {
                    return (1, $o, $obj, \@ancestors);
                } elsif (!$report_ties) {
                    # Nothing provides the object, or there's an unresolvable
                    # tie; add sys:clean to the list in both cases.
                    $state->{xuse_prevpair}{$ipair}{$io} =
                        intern 'nonexistent sys:clean';
                    $xuse{'sys:clean'} or push @xuse, 'sys:clean';
                    $xuse{'sys:clean'} = $o; # nothing provides it
                }
            }

            # Add dependencies: objects to the list.
            # These are sorted for determinism.
            my @drules = rules_that_apply_to($o);
            @drules = grep $config->{rules}{$_}{number_of_depend_actions},
                sort @drules;
            # To avoid an infinite regress, don't add the dependencies from a
            # dependency rule that matches its own output.
            for my $drule (@drules) {
                my $depdep = "dependencies:$drule:$o";
                my $robj = $config->{rules}{$drule}{object};
                $drule = undef, next if
                    (ref $robj) =~ /\bRegexp$/ && $depdep =~ $robj;
                push @command, $depdep;
            }
            defined $_ and
                $xuse_reason{"dependencies:$_:$o"} = "config_rule:$_" for @drules;

            $xuse{$o} = defined_or($xuse_reason{$o}, $obj);
            push @xuse, $o;
        }
    }

    # If we're doing things rather than reporting, do them.
    if (!$report_ties) {
        unless ($xuse{$obj}) {
            $xuse{$obj} = "config_rule:$rule";
            push @xuse, $obj;
        }
        @xuse = map intern $_, @xuse;
        $state->{xuse_by_pair}{$ipair} = \@xuse;
        for my $xuse (keys %xuse) {
            $state->{xuse_by_object}{intern $xuse}{$ipair} =
                intern $xuse{$xuse};
        }
    }
    return 0;
}

# Resets the xuse of a pair. This is called for two reasons: either because
# we're about to recalculate the xuse and want to remove any old xuses on it,
# or because the pair's being deleted for good (either because it's a
# combination of a rule and a nonexistent object, or because it's a
# combination of a nonexistent rule and anything, or because it's a
# combination of a rule and an object that doesn't fit that rule; the former
# case happens most often when a file is deleted from the source tree or a
# symbol is removed from the program altogether, and the latter case only
# happens if a rule is deleted from the config file, or changed to apply to a
# different set of objects). (Calling reset_pair_xuse in such cases deletes
# the pair altogether; it's not mentioned in hash because it doesn't provice
# anything, and it's not mentioned in unsure because it's known that it
# doesn't provice anything.)
sub reset_pair_xuse {
    my $pair = shift;
    my $ipair = intern $pair;

    # This also invalidates sureness caches.
    mark_pair_xuse_unknown $pair, "xuse reset";
    progress_report 4, "Resetting xuse of $pair.";

    delete $state->{xuse_by_pair}{$ipair};
    delete $state->{xuse_prevpair}{$ipair};
}

sub mark_pair_xuse_unknown {
    my $pair = shift;
    my $reason = shift;
    my $ipair = intern $pair;

    progress_report 4, "Marking xuse of $pair as unknown ($reason).";

    if (defined $state->{xuse_by_pair}{$ipair}) {
        for my $iobj (@{$state->{xuse_by_pair}{$ipair}}) {
            delete $state->{xuse_by_object}{$iobj}{$ipair};
            delete $state->{xuse_by_object}{$iobj}
                unless keys %{$state->{xuse_by_object}{$iobj}};
        }
    }
    $state->{xuse_by_pair}{$ipair} = undef;
    delete $state->{xuse_prevpair}{$ipair};

    invalidate_pair_or_object_sureness $pair;
    %unsure_pair_cache = ();
}

sub ensure_pair_has_xuse {
    my $pair = shift;
    if (!defined $state->{xuse_by_pair}{intern $pair}) {
        recalculate_pair_xuse $pair, 0;
    }
}

sub check_xuse_ties {
    my $pair = shift;
    my $ipair = intern $pair;
    if (!defined $state->{xuse_by_pair}{$ipair}) {
        return recalculate_pair_xuse $pair, 1;
    } elsif (grep $_ eq intern 'sys:clean', @{$state->{xuse_by_pair}{$ipair}}) {
        # We need to recalculate the xuse to get at which objects were tied.
        return recalculate_pair_xuse $pair, 1;
    } else {
        # If there's no sys:clean present, there can't be a tie.
        return 0;
    }
}

### Sureness calculations

sub pair_is_definitely_deletable {
    my ($prule, $pobj) = parse_pairname shift;
    rule_applies_to_object $prule, $pobj or return 1;
    object_exists "config_rule:$prule" or return 1;
    return;
}
memoize('pair_is_definitely_deletable');

# A pair is sure if all its xuses, recursing back forever, are sure. This goes
# via xuse_prevpair in most cases. As an exception, for searchfile, searchlib
# and symbolset objects (which have an outdepends depending only on their
# name), the pair is sure if any of its ancestors are sure.
#
# Must be called in array context. The first return is whether the pair is
# sure; the second return is the interned reason that it's sure or unsure.
my %pair_is_sure_seen = (); # hash to undef
sub pair_is_sure;
sub pair_is_sure {
    my $pair = shift;

    # Caches. Check these even before completing argument passing, because
    # this function is called a /lot/ and bailing out early is helpful.
    # (Thanks, profiler!)
    exists $sure_pair_cache{$pair} and
        return (1, undef);
    exists $unsure_pair_cache{$pair} and
        return (0, [@{$unsure_pair_cache{$pair}}]);

    my $recursion_ok = shift;
    if (exists $pair_is_sure_seen{$pair}) {
        $recursion_ok and return (0, [intern "recursion"]);
        croak "Pair $pair seems to have been built in terms of itself";
    }

    # The pair is definitely deletable (i.e. we're sure what to do with it) if
    # the rule doesn't exist, or the rule doesn't apply to the object; both of
    # those cases cannot be resolved during the run.
    if (pair_is_definitely_deletable $pair) {
        $sure_pair_cache{$pair} = undef;
        return (1, undef);
    }

    # Base case.
    $pair eq 'parse_configuration sys:no_object' and return (1, []);

    # Recursive case.
    my $ipair = intern $pair;
    ensure_pair_has_xuse $pair;
    $pair_is_sure_seen{$pair} = undef; # avoid an infinite regress
    my @ixuses = @{$state->{xuse_by_pair}{$ipair}};
    # %isureness_list is a hash from elements that directly affect $pair's
    # sureness, to undef. (Indirect dependencies are determined via
    # $pair_is_sure_because.)
    my %isureness_list = ($ipair => undef); # interned keys, undef values
    @isureness_list{@ixuses} = ();
    for my $ixuse (@ixuses) {
        my @iproviders = ();
        my $phash = $state->{outdep_by_object}{$ixuse};
        next unless $phash; # if the object doesn't exist, it's sure
        my $xuse = unintern $ixuse;
        @iproviders = keys %$phash;

        # There are two basic ways an object type can work:
        # - Multiple providers not OK: we use xuse_prevpair to determine which
        #   provider to use, and only one provider is used, so we use its
        #   sureness value;
        # - Multiple providers OK: for each set of outdepends among the
        #   providers, at least one provider must generate it surely
        # We can simplify the calculations if there's only one provider,
        # because in that case, that must be the one we're using, thus there's
        # no need to work out what we'd do if there were more than one. (And
        # if there are no providers, we don't even reach this bit.)
        if (@iproviders == 1 || $xuse !~ multiple_providers_ok_regex) {
            # Make sure that the object's prevpair is sure, and that the
            # object is sure via its prevpair.
            my $iprevpair = @iproviders == 1 ? $iproviders[0] :
                $state->{xuse_prevpair}{$ipair}{$ixuse};
            my $prevpair = unintern $iprevpair;
            if (!defined $iprevpair) {
                croak "No xuse_prevpair from $pair for an object $xuse " .
                    "with multiple prevpairs " .
                    (join ', ', map unintern $_,
                     keys %{$state->{outdep_by_object}{$ixuse}});
            }
            next if $prevpair eq 'nonexistent sys:clean';
            if ($state->{unsure_by_pair}{$iprevpair} &&
                $state->{unsure_by_pair}{$iprevpair}{$ixuse}) {
                exists $state->{changed_pairs}{$ipair} and
                    $state->{changed_pairs}{$ipair} = "xuse $xuse is unsure";
                my $iunsure_list = [$ixuse, $iprevpair];
                $unsure_pair_cache{$pair} = [@$iunsure_list];
                delete $pair_is_sure_seen{$pair};
                progress_report 4,
                    "pair_is_sure: $pair is unsure due to " .
                        "unsure $xuse via $prevpair";
                return (0, $iunsure_list);
            }
            # If the chosen prevpair is unsure, we're unsure.
            my ($sure, $iunsure_list) =
                pair_is_sure $prevpair, $recursion_ok;
            if (!$sure) {
                exists $state->{changed_pairs}{$ipair} and
                    $state->{changed_pairs}{$ipair} =
                    "xuse ${xuse}'s pair $prevpair is unsure";
                unshift @$iunsure_list, $ixuse, $iprevpair;
                $recursion_ok or
                    $unsure_pair_cache{$pair} = [@$iunsure_list];
                delete $pair_is_sure_seen{$pair};
                progress_report 4,
                    "pair_is_sure: $pair is unsure due to ".
                        "unsure $prevpair needed for $xuse";
                return (0, $iunsure_list);
            } else {
                $isureness_list{$prevpair} = undef;
            }
        } else {
            @iproviders = sort @iproviders;
            # For each provider, we require that that provider's outdepends
            # are identical to a sure provider's outdepends (the same
            # provider, or a different provider, it doesn't matter).
            my %outdepends_seen = ();
            my %outdepends_because = ();
            my %outdepends_unsurelist = ();
            for my $iprovider (@iproviders) {
                my $provider = unintern $iprovider;
                my $outdepends = $state->{outdep_by_object}{$ixuse}{$iprovider};
                $outdepends = serialize_sv($outdepends);
                next if $outdepends_seen{$outdepends};

                my ($sure, $iunsure_list);
                if ($state->{unsure_by_pair}{$iprovider} &&
                    $state->{unsure_by_pair}{$iprovider}{$ixuse}) {
                    $sure = 0;
                    $iunsure_list = [$ixuse, $iprovider];
                } else {
                    if ($recursion_ok) {
                        ($sure, $iunsure_list) = (pair_is_sure $provider, 1);
                    } else {
                        my %prerecursive_pair_is_sure_seen =
                            %pair_is_sure_seen;
                        %pair_is_sure_seen = ();
                        ($sure, $iunsure_list) = (pair_is_sure $provider, 1);
                        %pair_is_sure_seen = %prerecursive_pair_is_sure_seen;
                    }
                    $isureness_list{$iprovider} = undef;
                }
                $outdepends_seen{$outdepends} = $sure;
                $outdepends_because{$outdepends} = $provider;
                $outdepends_unsurelist{$outdepends} = $iunsure_list;
            }
            $outdepends_seen{$_} and delete $outdepends_seen{$_} for
                keys %outdepends_seen;
            if (keys %outdepends_seen) {
                my ($outdepends, undef) = keys %outdepends_seen;
                my $problem = $outdepends_because{$outdepends};
                my $iunsure_list = $outdepends_unsurelist{$outdepends};
                unshift @$iunsure_list, $ixuse, intern $problem;
                exists $state->{changed_pairs}{$ipair} and
                    $state->{changed_pairs}{$ipair} =
                    "outdepends of unsure pair $problem is not provided by a sure pair";
                $recursion_ok or
                    $unsure_pair_cache{$pair} = [@$iunsure_list];
                delete $pair_is_sure_seen{$pair};
                progress_report 4, "pair_is_sure: $pair is unsure " .
                    "because unsure pair ${problem}'s outdepends are not " .
                    "generated surely for $xuse";
                return (0, $iunsure_list);
            }
        }
    }

    progress_report 5, "pair_is_sure: $pair is sure";
    $sure_pair_cache{$pair} = undef;
    for my $isure_because (keys %isureness_list) {
        $pair_is_sure_because{$pair}{$isure_because} = undef;
        $pair_is_sure_rindex{$isure_because}{$pair} = undef;
    }
    delete $pair_is_sure_seen{$pair};
    return (1, undef);
}

### Object existence and contents
#
# Ideally, we'd treat objects as existing only if some rule produced them (and
# thus be able to check entirely via outdep_by_object), but this doesn't work in
# practice, most obviously because the regress has to start somewhere. Object
# existence mustn't change without aimake being informed of it; in most cases,
# special objects are considered to always exist. The main exception here is
# for sys:clean, which always doesn't exist.
#
# Special handling is needed for config_rule and config_option; these are
# assumed to be produced from 'sys:no_object' via the rule
# 'parse_configuration', but the rule does not physically exist. Rather, the
# effects that it would have if it did exist are simulated. This means that
# rule hashes work just fine (they have a matching rule to check), and so
# object_exists can work on them the same way it would work on, say, the
# spath.
sub object_exists {
    my $obj = shift;
    return $state->{outdep_by_object}{intern $obj}
        unless $obj =~ objtype_is_special_regex;
    return 0 if $obj eq 'sys:clean';
    return 1;
}

####### Rule schema validation
#
# The following format is used in hashes in order to specify the allowed
# values and default value for a rule field:
#
# 'string'    Allowed values are strings, default 'string'
# \ 'string'  Allowed values are strings and regexes, default 'string'
# ['string']  Allowed values are string+regex lists, default 'string'
#             (a single string or regex is treated as a 1-element list)
# []          Allowed values are string+regex lists, default is an empty list
# undef       Allowed values are strings and undef, default undef
# \ undef     Allowed values are strings, regexes and undef, default undef
# 0           Allowed values are ints, default 0
# \ 0         Allowed values are ints and undef, default undef
# {...}       Allowed values and default are given explicitly
# \ {...}     Allowed values are dictionaries, recursively verified
#
# Here's the function that verifies that.
sub verify_hash_field;
sub verify_hash_field {
    my $hash = shift;
    my $field = shift;
    my $spec = shift;
    my $errloc = shift;

    my $hf = $hash->{$field};
    my $is_undef = !defined $hf;
    my $refhf = $is_undef ? 'undef' : ref $hf;
    my $is_regex = $refhf =~ /\bRegexp$/;
    my $is_list = $refhf eq 'ARRAY';
    my $is_int = !$refhf && $hf =~ /^\-?\d+$/;
    my $refspec = defined $spec ? ref $spec : 'undef';
    my $ref0 = $refspec eq 'SCALAR' && defined $$spec && $$spec eq '0';

    # Recursive verification is a special case.
    if ($refspec eq 'REF' && ref $$spec eq 'HASH') {
        $is_undef and $hf = {};
        ref $hf eq 'HASH' or die
            "Field '$field' of $errloc must be a dictionary";
        for my $k (keys %$$spec) {
            verify_hash_field $hf, $k, $$spec->{$k}, "field '$field' of $errloc";
        }
        $hash->{$field} = $hf;
        return;
    }

    # Replace undef with a default value (which may also be undef).
    if ($is_undef) {
        $hf = ${dclone \$spec};
        $refspec eq 'SCALAR' and $hf = $ref0 ? undef : $$hf;
        $refspec eq 'HASH' and $hf = $hf->{'default'};
    } else {
        # A list in the spec always becomes a list in the rule.
        $refspec eq 'ARRAY' and !$is_list and $hf = [$hf];
    }

    # Regexes are only allowed in certain contexts.
    if ($is_regex && $refspec ne 'ARRAY' && ($refspec ne 'SCALAR' || $ref0)) {
        die "Field '$field' of $errloc must not be a regex";
    }

    # Some contexts require integers.
    if (($ref0 || (!$refspec && $spec =~ /^\-?\d+$/)) &&
        !$is_undef && !$is_int) {
        die "Field '$field' of $errloc, if present, must be an integer";
    }

    # Some contexts have an explicit list of legal values.
    if ($refspec eq 'HASH') {
        my $ok = 0;
        deepequals $hf, $_ and $ok = 1 for @{$spec->{'values'}};
        !$ok and die "Field '$field' of $errloc has an illegal value";
    }

    # At this point, the only ways in which $hf could be illegal are if it's
    # not a scalar and a scalar is required, or if it's a list and it has
    # invalid contents.
    if (ref $hf && $refspec ne 'ARRAY' && ref $hf !~ /\bRegexp$/) {
        die "Field '$field' of $errloc must have a single value";
    }
    if (ref $hf ne 'ARRAY' && $refspec eq 'ARRAY') {
        die "Field '$field' of $errloc must be a list (or a single element ".
            "interpreted as a list)";
    }
    if (ref $hf eq 'ARRAY') {
        for my $hfel (@$hf) {
            ref $hf && ref $hf !~ /\bRegexp$/ and
                die "Field '$field' of $errloc must be a list of strings and ".
                "regular expressions";
        }
    }

    $hash->{$field} = $hf;
}

# And here's the schema itself.
my %rulekeys = (
    'object' => \ 'sys:no_object',
    'command' => ['intcmd:nop'],
    'object_dependency' => {values => [qw/auto outdepends nowhere/],
                            default => 'auto'},
    'in_subdir' => undef,
    'avoid_rules' => \ undef,
    'avoid_built_from' => \ undef,
    'force_locale' => undef,
    'require_match' => 0,
    'low_message_priority' => 0,
    'debug_trace' => 0,
    'ignore_warnings' => 0,
    'hide_errors' => undef,
    'verb' => undef,
    'filter' => \ undef,
    'linesep' => \ "\n",
    'lineskip' => 0,
    'linemax' => \ 0,
    'unescape' => {values => [undef, 'backslash', 'backslash_whitespace'],
                   default => undef},
    'also_match_stderr' => 0,
);
my %actionkeys = (
    'actiontype' => '',
    'output' => [],
    'output_from_optpath' => [],
    'information_only' => 0,
    'outdepends' => [],
    'depends' => [],
    'exeparams' => \ {
        'icon' => \ undef,
        'copyright' => undef,
        'version' => undef,
        'name' => undef,
        'description' => undef,
        'terminal' => \ 0,
        'interactive' => 1,
    },
    'install_dir' => {values => [qw/bindir libdir specificlibdir includedir
                                    specificincdir configdir datadir mandir
                                    infodir statedir rootbindir gamesbindir
                                    gamesdatadir gamesstatedir logdir lockdir
                                    specificlockdir docdir sourcecodedir
                                    shortcutdir/],
                      default => undef},
    'install_name' => undef,
    'install_permission' => undef,
    'install_readable' => 0,
    'install_elevation' => undef,
    'install_feature' => undef,
    'copy_structure' => 0,
    'link_to_directory' => undef,
    'inner' => [''],
    'outputarg' => [''],
    'dependsarg' => [''],
    'command_line_override' => undef,
    'on_failure' => {values => [qw/auto fail inapplicable alternative
                                   empty conditional parse/],
                     default => 'auto'},
    'alternative' => [],
    'preference' => 0,
    'output_as_searchfile' => 0,
    'output_as_standardlib' => 0,
    'filter_absolute' => 0,
    'filter_spath' => 0,
    'filter_nonexistent_files' => 0,
    'filter_text_files' => 0,
);
my %actiontypes = (
    'actiontype' => [qw/provide produce depend install/],
    'output' => [qw/provide produce/],
    'output_from_optpath' => [qw/produce/],
    'information_only' => [qw/produce/],
    'outdepends' => [qw/provide produce/],
    'depends' => [qw/depend/],
    'exeparams' => [qw/install/],
    'install_dir' => [qw/install/],
    'install_name' => [qw/install/],
    'install_permission' => [qw/install/],
    'install_readable' => [qw/install/],
    'install_elevation' => [qw/install/],
    'install_feature' => [qw/install/],
    'copy_structure' => [qw/install/],
    'link_to_directory' => [qw/install/],
    'inner' => [qw/provide produce depend/],
    'outputarg' => [qw/provide produce/],
    'dependsarg' => [qw/provide produce depend/],
    'command_line_override' => [qw/provide/],
    'on_failure' => [qw/provide produce depend/],
    'alternative' => [qw/provide produce depend/],
    'preference' => [qw/provide/],
    'output_as_searchfile' => [qw/provide/],
    'output_as_standardlib' => [qw/produce/],
    'filter_absolute' => [qw/provide produce depend/],
    'filter_spath' => [qw/provide produce depend/],
    'filter_nonexistent_files' => [qw/provide produce depend/],
    'filter_text_files' => [qw/provide produce depend/],
);

# Populate a version of %actionkeys for each type of action.
my %actionkeys_per_type = ();
for my $actiontype (qw/provide produce depend install/) {
    my $h = {};
    $actionkeys_per_type{$actiontype} = $h;
    for my $k (keys %actiontypes) {
        $_ eq $actiontype and $h->{$k} = $actionkeys{$k}
            for @{$actiontypes{$k}};
    }
}

####### Encoding calculations
#
# Some platforms don't support langinfo, so we need to import it by hand
# This also contains a fallback for if langinfo isn't there

$codeset = 'latin1'; # a guess
eval {
    require I18N::Langinfo;
    I18N::Langinfo->import(qw/langinfo CODESET/);
    $codeset = langinfo(CODESET());
} or do {
    my $locale = $ENV{LC_ALL};
    defined $locale or $locale = $ENV{LANG};
    defined $locale and $locale =~ /\.([^.]+)$/ and $codeset = $1;
};

# We support two types of file: text and binary.
#
# Binary files are easy: we want to turn off any sort of translation and read
# into a bytestring, and this can always be achieved using :raw :bytes.
#
# Text files are harder: we want to read into a character string, which means
# that we need to respect the encoding used by the command that created the
# file. This is impossible to know in general; however, most of the text files
# we're dealing with are dumps of stdout/stderr from shell commands, and those
# typically respect the system locale nowadays. So we assume that text files
# are encoded in $codeset (apart from our own config file, which is definitely
# encoded in UTF-8). The other problem is to determine what the layers for
# text files on the platform actually are; :crlf is likely on Windows, but
# incorrect for UNIX, for instance. So we check for :crlf in the layers from
# the (text file) stdin in order to learn what a text file looks like.
{
    my @layers = PerlIO::get_layers(\*STDIN);
    my $crlf = scalar grep $_ eq 'crlf', @layers;
    $binary_layers = ":raw:bytes";
    $text_layers = $utf8_layers = $ascii_layers = $crlf ? ':crlf' : '';
    $text_layers  .= ":encoding($codeset)";
    $utf8_layers  .= ":encoding(UTF-8)";
    $ascii_layers .= ":encoding(ASCII)";
}

####### Options and configuration

##### Command-line options
#
# We use the stock option parser Getopt::Long to parse the command
# line arguments.

$::VERSION = '3.4';
Getopt::Long::Configure('bundling', 'permute', 'auto_help');
$opt_verbose = 0;
$opt_install = undef;
$opt_prefix = undef;
$opt_dump = undef;
$opt_profile = 0;
$opt_install_only = 0;
$opt_config_only = 0;
$opt_elevate_permissions = undef;
$opt_ignore_builtin_config = 0;
@opt_local_config = ();
$opt_specific_exit_status = 0;
@opt_warnings = (); # TODO: unimplemented
$opt_nocr = 0;
@opt_rebuild = ();
$opt_documentation = 0;
$opt_dlayout = undef;
$opt_filelist = undef;
$opt_gen_installer = undef;
$opt_noperms = 0;
$opt_license = 0;
$opt_version = 0;
$opt_nonempty_directory = 0;
%opt_var = ();
%opt_directory_overrides = ();
@opt_with = ();
@opt_without = ();
@opt_with_default = ();
GetOptions('verbose|v:+' => \$opt_verbose,
           'install|i:s' => \$opt_install,
           'with=s' => \@opt_with,
           'without=s' => \@opt_without,
           'with-default=s' => \@opt_with_default,
           'elevate-permissions|S=s' => \$opt_elevate_permissions,
           'install-only' => \$opt_install_only,
           'config-only' => \$opt_config_only,
           'destdir=s' => \$opt_prefix,
           'filelist=s' => \$opt_filelist,
           'gen-installer=s' => \$opt_gen_installer,
           'no-sanity-checks' => \$opt_no_sanity_checks,
           'natural-permissions' => \$opt_noperms,
           'profile' => \$opt_profile,
           'dump-status:s' => \$opt_dump,
           'show-warnings|W=s' => \@opt_warnings,
           'absent-terminal' => \$opt_nocr,
           'nonempty-directory' => \$opt_nonempty_directory,
           'documentation' => \$opt_documentation,
           'directory-layout=s' => \$opt_dlayout,
           'override-directory=s' => \%opt_directory_overrides,
           'var=s' => \%opt_var,
           'ignore-builtin-config' => \$opt_ignore_builtin_config,
           'local-config=s' => \@opt_local_config,
           'specific-exit-status' => \$opt_specific_exit_status,
           'license' => \$opt_license,
           'version' => \$opt_version,
           'rebuild|B=s' => \@opt_rebuild) or pod2usage(2);
$opt_documentation and pod2usage('-exitval' => 0, '-verbose' => 2);
$opt_license and pod2usage('-exitval' => 0, '-verbose' => 99,
                           '-sections' => ['COPYRIGHT']);
if ($opt_version) {
    print <<EOF;
aimake version $::VERSION, running under Perl version $^V.
Copyright (C) 2013, 2014, 2015 Alex Smith.

This program is licensed under version 3 of the GNU General Public License;
you are welcome to redistribute it under certain conditions, but it comes with
ABSOLUTELY NO WARRANTY.

For details on the license and lack of warranty, run this program with the
'--license' option.
EOF
    exit 0;
}
$opt_verbose = defined_or($opt_verbose, 0);

# If generating an installer, set up the other options appropriately.
if (defined $opt_gen_installer) {
    $opt_elevate_permissions and die
        "Generating an installer does not need elevated permissions";
    if ($opt_gen_installer eq 'msi') {
        $opt_filelist = 'wix';
        $opt_dlayout = 'windows';
        $opt_prefix = File::Spec->catfile(File::Spec->curdir,
                                          'aimake_wix_input');
    } else {
        die "Unknown --gen-installer argument '$opt_gen_installer'";
    }
}

$opt_prefix and $opt_prefix = File::Spec->rel2abs($opt_prefix);

# Don't create an aimake.objects in the source directory, it leads to
# problems. We need to do this check before establishing the lock, because the
# lock requires aimake.objects to exist.
if (-f 'aimake') {
    die ("You cannot run aimake with the build directory as the source " .
         "directory.\nCreate a build directory elsewhere, then " .
         "run aimake from there.");
}

read_statefile;
atomic_read {
    $path = $state->{_srcdir};
    # A nonexistent statefile was created by us, so it's format $::VERSION.
    # An existent statefile came from version 3.0 if no version is
    # present; versions pre-3 used a different filename, versions post-3.0
    # stored the version in the statefile.
    my $version = defined_or($state->{_version},
                             keys %$state ? "3.0" : $::VERSION);
    $version eq $::VERSION or
        die "This is version $::VERSION of aimake, but the existing statefile " .
        "comes from version $version of aimake; please use a clean build " .
        "directory (or empty this one).";
    $state->{_version} = $version; # in case it's a new statefile
};

if (defined $opt_dump) {
    atomic_read {
        $Data::Dumper::Indent = 1;   # to help keep it on the screen
        $Data::Dumper::Sortkeys = 1; # make it easier to find things in it
        $Data::Dumper::Useqq = 1;    # make it more readable
        $Data::Dumper::Deepcopy = 1; # don't use cross-references
        $Data::Dumper::Terse = 1;    # don't prefix '$VAR1 = '
        my @path = split /,/, $opt_dump;

        # So as to make the dump easier (i.e. possible) to read, undo all
        # the string interning; note that recursive_unintern changes the
        # arrayrefs and hashrefs that make up its argument directly, so we
        # need to dclone first
        my $subset = dclone $state;
        recursive_unintern $subset;
        delete $subset->{_intern};

        for my $key (@path) {
            if (defined_or(ref $subset, 'undef') eq 'HASH') {
                if (exists $subset->{$key}) {
                    $subset = $subset->{$key};
                } else {
                    $subset = '!exists';
                }
            } else {
                defined_or($subset, 'undef') ne '!exists' and
                    $subset = 'not a HASH ref';
            }
        }
        print ref $subset || !defined $subset ? Dumper($subset) : "$subset\n";
    };
    exit 0;
}


##### Locating the source directory
#
# If no source directory was specified, assume that aimake itself is in the
# source directory, and find it that way.
my $argpath = $ARGV[0];
defined $argpath or $argpath = $RealBin;
$argpath = ospath2aipath $argpath, undef, 2; # $path is not set yet

defined $path and scalar @ARGV == 1 and $path ne $argpath and
    die "This build directory is already being used to build '".
    aipath2ospath($path) . "' (you wanted to build '".
    aipath2ospath($argpath) . "')";

if (scalar @ARGV > 1) {
    die "Don't know what to do with multiple non-option arguments.";
}

if (!defined $path) {
    # Start a new build. We first want to verify that the
    # directory is empty.
    opendir my $dh, File::Spec->curdir or die "Cannot open '.': $!";
    my @offending_files = File::Spec->no_upwards(readdir($dh));
    # nytprof.out is a special case; it's produced as a side effect of
    # running a Perl program when profiling, and thus can exist even
    # if the directory was empty. (Other special cases may exist; the
    # user can indicate these with $opt_nonempty_directory.)
    @offending_files = grep ospath2aipath($_) ne statefilename &&
        ospath2aipath($_) ne 'bpath:nytprof.out',
        @offending_files;
    closedir $dh;
    if (@offending_files && !$opt_nonempty_directory) {
        # We created a mostly empty statefile as a lockfile.
        # In our build directory, that wouldn't matter, but we've been run
        # from the wrong directory, so clean up after ourselves.
        unlink aipath2ospath(statefilename);
        die "Please use an empty directory for starting new builds.";
    }
    # Should be OK to start, then.
    $path = $argpath;
}

-d aipath2ospath('path:') or die "Source directory '" .
    aipath2ospath('path:') . "' is not a directory.";

charge_profiled_time_to('Early initialization');

atomically {
    $state->{_srcdir} = $path;
};

##### Configuration parsing

# We use Perl notation (Data::Dumper-style) for the config file, which leads
# to a bit of a problem reading it. The solution: use Perl's parser, and the
# Safe module to allow only specification of constants. (rv2sv is there so
# that variables can be used to avoid repetition. rv2gv seems to be needed on
# recent Perl versions. Probably it's to do with different optimizers.)
my $configsafe = new Safe;
$configsafe->permit_only(qw/null stub scalar pushmark const undef list qr
                            negate lineseq leaveeval anonlist anonhash rv2sv
                            sassign nextstate padany regcreset concat
                            stringify quotemeta rv2gv/);

# These are global, not lexical, so we can share them with the config file
our $libext = $Config{_a};
our $objext = $Config{_o};
our $exeext = $Config{_exe};
our $pointerbits = $Config{ptrsize} * 8;
# Make sure that exeext is non-null, to reduce porting mistakes
$exeext eq '' and $exeext = '.bin';
our $dllext =       {MSWin32 => '.dll',
                     linux   => '.so',
                     freebsd => '.so',
                     darwin  => '.dylib'}->{$os_parsed};
our $impext =       {MSWin32 => '.dll.a', # MinGW uses this
                     linux   => '.so',
                     freebsd => '.so',
                     darwin  => '.dylib'}->{$os_parsed};
our $symbolprefix = {MSWin32 => '',
                     linux   => '',
                     freebsd => '_',
                     darwin  => '_'}->{$os_parsed};
$configsafe->share('$libext', '$objext', '$exeext', '$dllext', '$impext',
                   '$symbolprefix', '$pointerbits', '$longrandomstring',
                   '$os_parsed');

# Parse the global config file, from our <DATA>
$! = 0;
undef $@;
my $configdata;
{
    local $/;
    $configdata = <DATA>;
}
$config = $configsafe->reval($configdata, 0);
$@ or ($! and $@ = $!);
$@ or $@ = "bad configuration file format";
defined $config or
    die "Could not load global config file: $@";
undef $@;
ref $config eq 'HASH' or die "Invalid type in global config file";

if ($opt_ignore_builtin_config) {
    $config->{options} = {};
    $config->{rules} = {};
    $config->{tests} = {};
    $config->{libraries} = {};
}

# Parse the local config files (path:aimake.rules, path:aimake.local, and
# any files specified on the command line)
for my $localconfigfile (aipath2ospath(configfilename),
                         aipath2ospath(localconfigfilename),
                         @opt_local_config) {
    if (-f $localconfigfile) {
        local $/;
        open my $fh, '<', $localconfigfile
            or die "Could not open config file $localconfigfile: $!";
        $configdata = <$fh>;
    } else { $configdata = '{}'; }
    my $localconfig;
    if ($] >= 5.009) {
        $localconfig = $configsafe->reval($configdata, 0);
    } else {
        $localconfig = eval $configdata;
    }
    $@ or ($! and $@ = $!);
    $@ or $@ = "bad configuration file format";
    defined $localconfig or
        die "Could not load config file $localconfigfile: $@";
    undef $@;
    ref $localconfig eq 'HASH'
        or die "Invalid type in project-specific config file";
    for my $t (qw/rules options tests libraries features directories/) {
        if (exists $localconfig->{$t}) {
            $config->{$t}{$_} = $localconfig->{$t}{$_}
            for keys %{$localconfig->{$t}};
        }
    }
}

# Ensure all the mandatory options are set.
$path =~ m=/([^/]+)$=;
defined($config->{options}{packagename}) or
    $config->{options}{packagename} = $1;
$config->{options}{packagename} =~ /^[-a-z0-9_]+$/ or die
    "'packagename' option is missing or has an illegal value";
defined($config->{options}{packagename_text}) or
    $config->{options}{packagename_text} = $config->{options}{packagename};
defined($config->{options}{packagename_ui}) or
    $config->{options}{packagename_ui} =
    $config->{options}{
        $config->{options}{packagename_text} =~ /^[-a-zA-Z0-9_ ,.]+$/ ?
            'packagename_text' : 'packagename'};
$config->{options}{packagename_ui} =~ /^[-a-zA-Z0-9_ ,.]+$/ or die
    "'packagename_ui' option is missing or has an illegal value";
defined($config->{options}{packageversion}) or
    $config->{options}{packageversion} = '0.1';
$config->{options}{packageversion} =~
    /^[0-9]{1,4}(\.(?:alpha|beta)?[0-9]{1,4})*$/ or die
    "'packageversion' option is missing or has an illegal value";
defined($config->{options}{companyname}) or
    $config->{options}{companyname} =
    $config->{options}{packagename_text} . " developers";

# Work out where and whether we're installing.
$installing = defined $opt_gen_installer || defined $opt_install;
$ipath = undef;
$opt_install and $ipath = ospath2aipath($opt_install);

# Complain if someone tries to build as root.
# Exception: everyone has a UID of 0 on Windows, so this check
# will have false positives.
#
# Check effective UID for this, so that root can run a setuid-something-else
# install program, and so that we complain if someone installs aimake suid root
# (note: do not install aimake suid root).
if ($os_parsed ne 'MSWin32' && $> == 0 && !$opt_install_only &&
    !$opt_no_sanity_checks) {
    die ("Please do not run aimake as root.\n" .
         "To install as root, use '-S su' or '-S sudo' as appropriate.");
}

# If a directory does not already exist, it must be specified as an absolute
# path. Basically, because otherwise we can't do relative path resolution
# correctly.
if (defined $opt_install && $opt_install ne '' && !-e $opt_install) {
    File::Spec->file_name_is_absolute($opt_install) or die
        "Install path '$opt_install' is not an absolute path and does not exist";
}

# Work out which features we want.
sub onoff {
    return +(shift) ? "on" : "off";
}
sub feature_error {
    my $feature = shift;
    $feature eq '?' or
        print "Unknown feature '$feature'\n";
    if (!keys %{$config->{features}}) {
        print "This project supports no features.\n";
    } else {
        print "Valid features:\n";
        for my $f (sort keys %{$config->{features}}) {
            print "  $f: $config->{features}{$f}{description} ";
            if (exists $state->{_feature}{$f}) {
                print "(currently " . onoff($state->{_feature}{$f}) .
                    ", default " . onoff($config->{features}{$f}{default}) .
                    ")\n";
            } else {
                print "(at default of " .
                    onoff($config->{features}{$f}{default}) . ")\n";
            }
            my $longdesc = $config->{features}{$f}{long_description};
            if (defined $longdesc) {
                format =
~~    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      $longdesc
.
                write;
            }
        }
    }
    exit ($feature eq '?' ? 0 : 1);
}

# Work around a bug in Emacs. This function is never called, but is necessary
# for indentation to work from this point onwards.
sub fix_syntax_highlighting {
}

charge_profiled_time_to('Mid initialization');

$singledir = 0;

atomically {
    for my $feature (@opt_with) {
        exists $config->{features}{$feature} or feature_error $feature;
        $state->{_feature}{$feature} = 1;
    }
    for my $feature (@opt_without) {
        exists $config->{features}{$feature} or feature_error $feature;
        $state->{_feature}{$feature} = 0;
    }
    for my $feature (@opt_with_default) {
        exists $config->{features}{$feature} or feature_error $feature;
        delete $state->{_feature}{$feature};
    }

    $ipath ||= $state->{_installdir};

    # Work out the install directory layout.
    my $dlayout = $opt_dlayout || $config->{options}{directory_layout};
    if ($dlayout eq 'autodetect') {
        $dlayout = $config->{options}{directory_layout_fallback};
        if (defined $ipath) {
            for my $layout (sort keys %{$config->{directories}}) {
                $ipath =~ $config->{directories}{$layout}{autodetect} and
                    $dlayout = $layout;
            }
        }
    }
    defined $config->{directories}{$dlayout} or
        die "Nonexistent directory layout '$dlayout'";
    $config->{options}{directory_layout} = $dlayout;

    # When generating an installer, override the ipath. Exception: if we were
    # given an install path explicitly on the command line.
    $opt_gen_installer and !$opt_install and $ipath = undef;
    # We use the preferred installdir if overriding the ipath, or if we can't
    # find one any other way.
    $ipath ||= $config->{directories}{$dlayout}{preferred_installdir};

    # single_directory is special-cased.
    $dlayout eq 'single_directory' and $singledir = 1;

    # Fill in any directory options that weren't overriden by config options
    # or the command line.
    for my $dir (keys %{$config->{directories}{$dlayout}}) {
        next unless $dir =~ /dir$/;
        $config->{options}{$dir} ||=
            $config->{directories}{$dlayout}{$dir};
        defined $opt_directory_overrides{$dir}
            and $config->{options}{$dir} =
                ospath2aipath $opt_directory_overrides{$dir};
    }

    $config->{options}{installdir} = $ipath;
    $opt_gen_installer or $state->{_installdir} = $ipath;
};

# -i does not mean "install" if an unwritable directory is given, and
# -S is not also given. However, if we can create the directory, it isn't
# unwritable. (And if it is writable, it clearly already exists.) This creates
# the install directory early, but that's not a problem if we're installing.
my $transformed_ipath = destdir_transform $ipath;
if ($installing && !defined $opt_elevate_permissions &&
    !-w (aipath2ospath $ipath)) {
    ensure_directory $transformed_ipath, 0, 1, 1 or $installing = 0;
}

# Complain and exit if -S or --install-only were specified, but we're
# nonetheless failing to install.
if ((defined $opt_elevate_permissions || $opt_install_only) &&
    !$installing) {
    die "Cannot obey the requested install options: -S and --install-only " .
        "are useful only when installing, but the install path '" .
        (aipath2ospath $transformed_ipath) .
        "' is not writable and cannot be created " .
        "(a combination which normally causes aimake to skip the install)";
}

# Directory options need substitutions.
for my $option (keys %{$config->{options}}) {
    if ($option =~ /dir$/) {
        1 while $config->{options}{$option} =~
            s/\$([a-z_]+)/$config->{options}{$1} or die
                          "No config directory '$1'"/ge;
    }
}

##### Desugar the 'libraries' key into a rule.

my $default_libraries_rule = {
    output => [],
    outdepends => [],
    verb => 'determined',
    low_message_priority => 1,
};
for my $lib (keys %{$config->{libraries}}) {
    my $symbol = $config->{libraries}{$lib};
    push @{$default_libraries_rule->{output}},
        "searchlib:$lib:symbol:$symbol";
}

$config->{rules}{default_libraries} = $default_libraries_rule
    unless $opt_install_only;

##### Desugar the tests into rules.
#
# Basic pattern: for each possibility, create a rule that tests that
# possibility, and provides the appropriate optionset based on that
# possibility if it passes, or based on the optionset for the next possibility
# if it fails.
#
# TODO: sanity/schema check the input tests.

for my $test (keys %{$config->{tests}}) {
    my $td = $config->{tests}{$test};
    my $tf = $td->{source};
    $tf =~ s/([\\_])/\\$1/g;
    $tf =~ y/ \n/_ /;
    my $tffn = "bpath:aimake/test_$test" . $td->{source_extension};
    $config->{rules}{"test_generate_file_$test"} = {
        command => ['intcmd:writefile', "optpath::$tffn", "optstring:$tf"],
        output => $tffn,
        verb => 'generated',
        low_message_priority => 1,
    };
    for my $i (0 .. $#{$td->{possibilities}}) {
        $config->{rules}{"test_run_${i}_$test"} = {
            object => $tffn,
            command => [@{$td->{command}}, @{$td->{possibilities}[$i]}],
            output => $i ? "optionset:test_${i}_$test" : "optionset:$test",
            outdepends => $td->{possibilities}[$i],
            ($i < $#{$td->{possibilities}} ?
             (on_failure => 'alternative',
              alternative => "optionset:test_" . ($i+1) . "_$test") :
             (on_failure => 'fail', hide_errors => 0)),
            verb => 'test ran',
            low_message_priority => 1,
        };
    }
}

progress_report 4, Dumper($config->{options});

####### Main program

$SIG{INT} = sub {die "Interrupted.";};
progress_report 3, "Starting main program.";

##### Initialization

### Rule schema enforcenement
#
# We sanity-check the rules during initialization because a sufficiently
# insane rule might never run (e.g. if the user writes "object" rather than
# "output"). In general, we're simply trying to catch as many typos as
# possible here. The other things we do here are to delete rules that were
# overriden using "undef", to give fields their default values (rather than
# relying on a defined_or everywhere the fields are used; this is marginally
# faster, but more importantly, much less error-prone), and to ensure that all
# the actions make sense and convert them to a consistent format (together
# with tagging them with an action_type).

for my $rulename (keys %{$config->{rules}}) {
    my $rule = $config->{rules}{$rulename};
    defined $rule or delete $config->{rules}{$rulename}, next;

    # Check the rule for sanity.
    croak "Rule '$rulename' is not a hash reference"
        unless ref $rule eq 'HASH';

    # If the rule doesn't have an explicit ->{actions}, create one from the
    # implicit ->{actions}.
    if (!exists $rule->{actions}) {
        $rule->{actions} = [{}];
        for my $k (keys %$rule) {
            if (exists $actionkeys{$k}) {
                $rule->{actions}[0]{$k} = $rule->{$k};
                delete $rule->{$k};
            }
        }
    }

    # Check all the general-purpose fields.
    for my $k (keys %$rule) {
        next if $k eq 'actions';
        if (!exists $rulekeys{$k}) {
            die "Rule '$rulename' has nonexistent field '$k'";
        }
    }
    for my $k (keys %rulekeys) {
        verify_hash_field $rule, $k, $rulekeys{$k}, "rule '$rulename'";
    }

    # Add the rule to the rule_object_prefixes cache.  This basically involves
    # looking at the {object} field to see what sort of object it's looking
    # for.  This is complicated by the fact that it might be a regex, and a
    # regex can contain a | to match more than one object prefix.
    #
    # We work around this via looking for a | that isn't enclosed in
    # parentheses.  If we find one, we place the rule into the "any" bucket.
    # Likewise if the rule doesn't have the most common form.
    my $ruleobject = $rule->{object};
    my $bucket = 'any';
    if (!ref $ruleobject) {
        $ruleobject =~ /^([a-z_]+):/ and $bucket = $1;
    } else {
        $ruleobject = "$ruleobject";
        $ruleobject =~ s/^\(\?\^[-a-z]*:\^// and
            $ruleobject =~ s/\)$// and
            $ruleobject =~ /^ (?: [^\\()|]
                                | \\.
                                | (?'bparens' \( (?: [^\\()]
                                                   | \\.
                                                   | (?&bparens))*
                                              \))
                              )* $/x and
            $ruleobject =~ /^([a-z_]+):/ and $bucket = $1;
    }
    $rule_object_prefixes{$bucket}{$rulename} = undef;

    # Check each action.
    my $anum = 0;
    for my $a (@{$rule->{actions}}) {
        $anum++;
        # Work out what type of action it is.
        my $actiontype =
            defined $a->{outdepends} ? 'provide' :
            defined $a->{depends} ? 'depend' :
            defined $a->{install_dir} ? 'install' :
            (defined $a->{output} || defined $a->{output_from_optpath}) ?
            'produce' : die "Action $anum of rule '$rulename' has no ".
            "output, depends, or install directory";
        $a->{actiontype} and $actiontype = $a->{actiontype};

        # Check that there are no extra or inappropriate fields given.
        for my $k (keys %$a) {
            if (!exists $actionkeys_per_type{$actiontype}{$k}) {
                die "Action $anum of rule '$rulename' specifies field '$k' ".
                    (exists $actionkeys{$k} ?
                     "which is inappropriate for this type of action" :
                     "which is not legal inside an action");
            }
        }
        # Check that all the fields fit the schema, and set defaults.
        for my $k (keys %{$actionkeys_per_type{$actiontype}}) {
            verify_hash_field $a, $k, $actionkeys_per_type{$actiontype}{$k},
                "action $anum of rule '$rulename'";
        }
        # Two special cases that aren't caught by the generic validation.
        die "Action $anum of rule '$rulename' has both ".
            "install permission and elevation"
            if defined $a->{install_permission} &&
            defined $a->{install_elevation};
        die "Action $anum of rule '$rulename' has both ".
            "output_from_optpath and outputarg defined"
            if defined $a->{output_from_optpath} &&
            scalar @{$a->{output_from_optpath}} &&
            (!deepequals $a->{outputarg}, ['']);

        # Record some values in the rule and its actions to save having to
        # recalculate them.
        $a->{actiontype} = $actiontype;
        $rule->{"number_of_${actiontype}_actions"} =
            defined_or($rule->{"number_of_${actiontype}_actions"}, 0) + 1;

        # Handle command_line_override, and related sugar.
        if (defined $a->{command_line_override}) {
            my $clostring = undef;
            my $envname = $a->{command_line_override};

            $a->{outdepends} or die "Action $anum of rule '$rulename' ".
                "has a command_line_override but no outdepends";
            ref $a->{outdepends} eq 'ARRAY' or die
                "Action $anum of rule '$rulename' has a ".
                "command_line_override, but not a hardcoded outdepends";

            defined $clostring or $clostring = $opt_var{$envname};
            defined $clostring or $clostring = $ENV{$envname};

            if (defined $clostring) {
                $clostring =~ s/^ +//;
                $clostring =~ s/ +$//;
                $clostring =~ s/  +/ /g;
            }

            defined $clostring or $clostring = $config->{options}{$envname};

            if (defined $clostring) {
                # We want to interpret $clostring as an optstring, cmd,
                # or spath, depending on context. We look for tool or cmd
                # objects in the existing outdepends to distinguish.
                my @new_outdepends;
                if (grep /^(?:tool|cmd):/, @{$a->{outdepends}}) {
                    $clostring =~ /^(.*?) (.*)$/s or
                        $clostring =~ /^(.*)()$/;
                    my $cmdname = $1;
                    $clostring = $2;
                    if (-f $cmdname) {
                        # TODO: We need to imply an spath: object for this case
                        # to work correctly, otherwise we'll fail to build due
                        # to a missing dependency on it
                        push @new_outdepends, ospath2aipath $cmdname;
                    } else {
                        # If it's not an existing file, assume that we're
                        # meant to be looking for it on the PATH
                        push @new_outdepends, "cmd:$cmdname";
                    }
                }
                $clostring eq '' or push @new_outdepends, "optstring:$clostring";
                $a->{outdepends} = \@new_outdepends;
            }
        }
    }
    if ($anum > 1 && $rule->{number_of_install_actions}) {
        die "Rule '$rulename' has more than one action and includes an ".
        "install action";
    }
    if (defined_or($rule->{number_of_depend_actions}, 0) > 1) {
        die "Rule '$rulename' has more than one dependency action";
    }
}

### Rules as objects
#
# Before we can enter the main loop, we have to add the rules as objects;
# specifically, we need to allow for new rules, rules being deleted, and rules
# having their hash changed. This is done via a fake pair 'parse_configuration
# sys:no_object', that always runs even though there's no change in either the
# rule or the object. The same thing is done for config options; and we also
# update sys:always_rebuild's hash.
#
# To hash a rule, we need to serialize it. Storable doesn't work (both because
# it doesn't like regexps, and because it's not stable as to whether it uses
# e.g. '2' or 2 for number-like strings), so we serialize by hand.
#
# record_pair_outputs will automatically do all the changed/unsure marking
# we'd want when a rule becomes changed, including notifying aimake of new
# rules, etc.

charge_profiled_time_to('Late initialization');

$config_hashes{"config_rule:$_"} = sv_hash $config->{rules}{$_}
    for keys %{$config->{rules}};
$config_hashes{"config_option:$_"} = sv_hash $config->{options}{$_}
    for keys %{$config->{options}};
atomically {
    my $runcount = find_hash_on_disk('sys:always_rebuild');
    my $installcount = find_hash_on_disk('sys:installing');
    $runcount ||= 0;
    $installcount ||= $runcount;
    $runcount++ unless $opt_install_only;
    $installcount++;
    $config_hashes{'sys:always_rebuild'} = $runcount;
    $config_hashes{'sys:rebuild_late'} = $runcount;
    $config_hashes{'sys:installing'} = $installcount;
    my %config_hash_on_disk = (); # intern => intern
    $config_hash_on_disk{intern $_} =
        [intern "hash_on_disk:$config_hashes{$_}:$_"] for keys %config_hashes;
    record_pair_outputs 'parse_configuration sys:no_object',
        \%config_hash_on_disk
        unless $opt_install_only; # happens when CFLAGS changes, etc.
    mark_object_unsure 'parse_configuration sys:no_object',
        'sys:rebuild_late', 'initial config'
        unless $opt_install_only;
    mark_object_unsure 'parse_configuration sys:no_object',
        'sys:installing', 'initial config';
};


##### Main loop.
#
# We look for changed pairs that are runnable (i.e. have no unsure objects in
# its use dependencies and their recursive build dependencies). To save
# repeated slow unsureness calculations, we go through the entire list and
# then start again, rather than trying to find the first runnable pair. If the
# pair is runnable, then we have three possibilities: run the pair (no
# nonexistent objects in the use deps and the rule applies to the object);
# clean the pair's output (any nonexistent objects in the use deps, but the
# object exists and the rule applies to it); delete the pair altogether
# (nonexistent object or rule, or the rule does not apply to the object). The
# last two operations always count as successfully running the pair; the first
# operation can fail (or produce warnings).

my $active_features = "";
my %active_features = ();
sub feature_set;
sub feature_set {
    my $feature = shift;
    defined_or($state->{_feature}{$feature},
               $config->{features}{$feature}{default}) or return 0;
    my $parent = $config->{features}{$feature}{depends};
    defined $parent and return feature_set $parent;
    return 1;
}
for my $feature (sort keys %{$config->{features}}) {
    next unless feature_set $feature;
    $active_features .= " $feature";
    $active_features{$feature} = 1;
}

$opt_config_only and write_statefile, exit 0;

charge_profiled_time_to('Late initialization');

atomically {
    for my $obj (@opt_rebuild) {
        for my $iprovicer (keys %{$state->{outdep_by_object}{intern $obj}}) {
            record_pair_outputs unintern $iprovicer, {};
            mark_pair_changed unintern $iprovicer, '-B command line option';
        }
    }
};

if ($active_features eq "") {
    progress_report 0, "Starting build (no features selected)";
} else {
    progress_report 0, "Starting build, with features:$active_features";
}

my %pairs_currently_running = (); # used for parallel builds
my @last_changedpairs = (); # optimization
my $rebuild_late_locked = 1;
my $installing_locked = 1;

my %installed_location = ();

charge_profiled_time_to('Late initialization');

MAINLOOP: while (1) {
    my $curpair = undef;
    my $icurpair = undef;
    my $find_another;
    my $no_rules_since_timestamp = time;
    my $lastbuild;
    my @xuse;

    # Note: we always have a charge_profiled_time_to call just before this
    # atomically{}, because there's one just before the loop and one at the
    # end of the loop.

    atomically {
      FIND_ANOTHER_RULE:
        $find_another = 0;
        $curpair = undef;

        # Try to find an appropriate current pair.
        #
        # We check the following lists in order:
        # 0 keys %likely_runnable
        # 1 @last_changedpairs
        # 2 @last_changedpairs, refilled from %{$state->{changed_pairs}}
        # 3 keys %unlikely_runnable
        # We don't make any assumptions about what sort of pairs are on each
        # of these lists (except for the tautology that any pairs on list 2
        # are changed).
        my $current_list = [sort keys %likely_runnable];
        my $whichlist = 0;
        FIND_CURRENT_PAIR: {
            if (!@$current_list) {
                $whichlist++;
                if ($whichlist == 3) {
                    $current_list = [sort keys %unlikely_runnable];
                    %unlikely_runnable = ();
                } elsif ($whichlist > 3) {
                    $curpair = undef;
                    last FIND_CURRENT_PAIR;
                } else {
                    $current_list = \@last_changedpairs;
                    $whichlist == 2 and @last_changedpairs =
                        sort map unintern $_, keys %{$state->{changed_pairs}};
                }
                redo FIND_CURRENT_PAIR;
            }
            $curpair = shift @$current_list;
            $whichlist == 2 or $state->{changed_pairs}{intern $curpair} or
                redo FIND_CURRENT_PAIR;
            $not_runnable_yet{$curpair} and redo FIND_CURRENT_PAIR;
            $unlikely_runnable{$curpair} and redo FIND_CURRENT_PAIR;
            $pairs_currently_running{$curpair} and redo FIND_CURRENT_PAIR;
        }

        if (!defined $curpair) {
            # It could be that no pairs are runnable. In that case, unlock
            # features if we can.
            if ($rebuild_late_locked) {
                $rebuild_late_locked = 0;
                mark_object_sure 'parse_configuration sys:no_object',
                    'sys:rebuild_late', 'unlocking rebuild_late';
                progress_report 3, "Moving to rebuild_late phase...";
                $find_another = 1;
                %unlikely_runnable = (%unlikely_runnable, %not_runnable_yet);
                %not_runnable_yet = ();
            } elsif ($installing_locked && $installing) {
                $installing_locked = 0;
                mark_object_sure 'parse_configuration sys:no_object',
                    'sys:installing', 'unlocking install';
                progress_report 3, "Moving to install phase...";
                $find_another = 1;
                %unlikely_runnable = (%unlikely_runnable, %not_runnable_yet);
                %not_runnable_yet = ();
            }

            # We can't find a pair. Either we'll get one later, in which case
            # we should relinquish the critical section so that other threads
            # have a chance to give us one later, or we won't, in which case
            # we still need to relinquish the critical section so that we can
            # exit the main loop.
        } else {
            $icurpair = intern $curpair;
            my ($rulename, $objname) = parse_pairname $curpair;
            progress_report +(time > $no_rules_since_timestamp + 2 ?
                              $opt_verbose + 0.5 : 4),
                "Looking for a rule to run (checking '$rulename'" .
                (defined $objname ? " on object '" .
                 (friendly_objname $objname) . "')" : ')');
            time > $no_rules_since_timestamp + 2 and
                $no_rules_since_timestamp ++;
            # Check for unsureness.
            progress_report 3, "Checking pair '$curpair' for sureness.";

            if ($config->{rules}{$rulename} &&
                $config->{rules}{$rulename}{number_of_install_actions} &&
                $installing_locked) {
                # No need to do a complex sureness calculation on an install
                # rule while installing is locked; it isn't.
                $not_runnable_yet{$curpair} = 1;
                delete $likely_runnable{$curpair};
                $find_another = 1;
                progress_report 3,
                    "Pair '$curpair' is unsure: not installing yet.";
            } else {
                charge_profiled_time_to('Looking for a rule to run');
                if (!$state->{outdep_by_pair}{$icurpair} &&
                    !exists $sure_pair_cache{$curpair} &&
                    !exists $unsure_pair_cache{$curpair}) {
                    # If a pair currently has no outputs, and it has at least
                    # one nonexistent, sure xuse, we can mark it as unchanged
                    # safely. This optimization requires us to know the xuse,
                    # but pair_is_sure will recalculate it anyway, so...
                    ensure_pair_has_xuse $curpair;
                    if (object_exists($objname) &&
                        rule_applies_to_object $rulename, $objname) {
                        my @failure = ();
                        for my $io (@{$state->{xuse_by_pair}{$icurpair}}) {
                            my $o = unintern $io;
                            unless ($state->{unsure_count_by_object}{$io} ||
                                    object_exists($o)) {
                                prioritize_object $o;
                                $find_another = 1;
                                push @failure, $o;
                            }
                        }

                        if ($find_another) {
                            progress_report 3, "Pair '$curpair' can't be " .
                                "run because it is missing objects: @failure.";

                            # record_pair_outputs marks it as unchanged
                            record_pair_outputs $curpair, {};
                            # In case it immediately becomes changed again, we
                            # want to postpone it. There's no restriction on
                            # what sort of pairs can be in unlikely_runnable.
                            $unlikely_runnable{$curpair} = 1;
                            charge_profiled_time_to(
                                "Rule '$rulename': sureness");
                            goto FIND_ANOTHER_RULE;
                        }

                    }
                }
                my ($sure, $iunsure_list) = pair_is_sure $curpair;
                $find_another = !$sure;
                if ($sure) {
                    %unlikely_runnable =
                        (%unlikely_runnable, %not_runnable_yet);
                    %not_runnable_yet = ();
                    progress_report 3, "Pair '$curpair' is sure.";
                } else {
                    $not_runnable_yet{$curpair} = 1;
                    delete $likely_runnable{$curpair};

                    # In most (but not all) cases, pair_is_sure can determine
                    # which pair is responsible for the unsureness. So we can
                    # just try that one next, if it happens to be a changed
                    # pair.
                    my $ilikely_pair = $iunsure_list->[-1];
                    if ($state->{changed_pairs}{$ilikely_pair}) {
                        my $likely_pair = unintern $ilikely_pair;
                        progress_report 3, "Pair '$curpair' is unsure: " .
                            "blocked by '$likely_pair'";
                        prioritize_pair $likely_pair;
                    } else {
                        progress_report 3, "Pair '$curpair' is unsure, ".
                            "for an unknown reason.";
                    }
                }
                charge_profiled_time_to("Rule '$rulename': sureness");
            }
        }
        $find_another and goto FIND_ANOTHER_RULE;

        charge_profiled_time_to('Looking for a rule to run');

        if (defined $curpair) {
            progress_report 3,
                "Pair '$curpair' is sure, checking whether to run or delete it...";
            # Now, if any pairs are runnable, curpair holds some runnable pair.
            # Work out whether we're running, cleaning, or deleting it.
            my ($rule, $object) = parse_pairname $curpair;
            my $runnable = 1;

            if ($opt_install_only && defined $config->{rules}{$rule} &&
                !($config->{rules}{$rule}{number_of_install_actions})) {
                # We can't run the rule because we're in install only mode and
                # it isn't an install rule, perhaps because we have elevated
                # permissions.
                $runnable = 0;
            }

            if (!(rule_applies_to_object $rule, $object) ||
                !(object_exists $object) ||
                !(object_exists "config_rule:$rule")) {
                # We're deleting it.
                # Clean it.
                record_pair_outputs $curpair, {};
                # Delete it. Cleaning it removed the pair from all the following
                # lists:
                # err_warn: report_pair_outputs sets/clears it
                # changed_pairs: record_pair_outputs marks unchanged
                # unsure: set_proviced_outdeps marks sure
                # outdeps: record_pair_outputs handles this
                # The remaining list is xuse, which we need to clean up ourself.
                reset_pair_xuse $curpair;
                # And now, the pair isn't mentioned anywhere at all, so we can
                # move onto the next one.
                progress_report 1,
                "Deleting outdated rule+object pair '$curpair'...";
                $runnable = 0;
            } else {
                # Check the rule's xuse for objects that don't exist, or that
                # have the wrong hash on disk.
                my ($currule, $curobject) = parse_pairname $curpair;
                ensure_pair_has_xuse $curpair;
                for my $iobj (@{$state->{xuse_by_pair}{$icurpair}}) {
                    my $obj = unintern $iobj;
                    progress_report 5, "Checking xuse $obj";
                    if (!object_exists $obj) {
                        # We're definitely sure that this rule cannot be built
                        # from right now (and cannot be built from at all this
                        # compile unless we find a new file that provides its
                        # output). Clean it.
                        if (exists $state->{outdep_by_pair}{$icurpair}) {
                            # If the pair was already outputting nothing, the
                            # clean is a no-op. This situation happens when a
                            # rule is created for the first time.
                            progress_report 1, "Cleaning rule+object pair " .
                                "'$curpair' because '$obj' was deleted...";
                        }
                        record_pair_outputs $curpair, {};
                        $runnable = 0;
                        last;
                    }
                    # The object always has the right hash unless it's on disk.
                    # This check makes sense for path: objects ("somebody edited
                    # the source tree while we were running"), and bpath:
                    # objects ("somebody edited the build tree, including
                    # between runs"); for spath:, it means "somebody edited
                    # system files we rely on between runs". For edited bpath:
                    # objects we regenerate them, for edited spath: objects we
                    # should probably rebuild other pairs that use them (as well
                    # as this pair), and for path: objects we should error out
                    # (because it almost certainly indicates that a build rule
                    # has got its inputs and outputs muddled up).
                    my ($objtype, undef) = parse_objname($obj);
                    if ($objtype =~ /^(?:[bs]?path|standardlib)$/) {
                        my $hash_on_disk = file_hash($obj);
                        my $desired_hash = find_hash_on_disk($obj);
                        if (defined_or($hash_on_disk,'') ne $desired_hash) {
                            $objtype eq 'path' and croak
                                "Source file '" . friendly_objname($obj) .
                                "' was overwritten during the build, make sure " .
                                "your build rules are correct";
                            $objtype eq 'bpath' and
                                progress_report -1, "Warning! Someone seems to " .
                                "have tampered with the build directory (" .
                                friendly_objname($obj) . ")";
                            $objtype eq 'spath' || $objtype eq 'standardlib' and
                                progress_report 1, "Regenerating files built " .
                                "via changed system file " .
                                friendly_objname($obj);
                            # We need to mark all pairs producing the object in
                            # question as changed (and thus the object itself as
                            # unsure).
                            mark_pair_changed unintern $_,
                                'hash change on disk' for
                                keys %{$state->{outdep_by_object}{$iobj}};
                            # And we can't continue, due to having an unsure
                            # ancestor.
                            $runnable = 0;
                            last;
                        }
                    }
                }
            }
            if ($runnable) {
                # We can run the rule!
                ensure_pair_has_xuse $curpair;
                @xuse = map unintern $_, @{$state->{xuse_by_pair}{$icurpair}};
            } else {
                # Find another rule.
                $find_another = 1;
            }
            charge_profiled_time_to("Rule '$rule': runnability");
        }
        $find_another and goto FIND_ANOTHER_RULE;

        # Let other threads know we're processing this pair.
        $curpair and $pairs_currently_running{$curpair} = 1;
    };
    if (!$curpair) {
        # End of the run.
        last;
    }

    my ($rulename, $objname) = parse_pairname $curpair;
    my $rule = $config->{rules}{$rulename};

    if ($rule->{number_of_install_actions} && $opt_elevate_permissions) {
        # We have to elevate permissions at this point, and that can only be
        # done by exiting the process and restarting it with higher
        # permissions. To accomplish this, we exec the permission elevation
        # program, splitting its name on spaces (in case the user needs to
        # nest elevation programs); then we get it to re-exec aimake with
        # different arguments.

        # Record the current state of the program.
        write_statefile;
        defined $state_fh and flock $state_fh, LOCK_UN;
        defined $state_fh and close $state_fh;
        $state_fh = undef;

        # Work out the arguments we need:
        # - The command the user asked us to run.
        my @eprog = split ' ', $opt_elevate_permissions;
        # - The path to Perl itself. (Algorithm from the Perl manual.)
        my $rprog = $Config{perlpath};
        $rprog .= $Config{_exe} unless
            $rprog =~ m/$Config{_exe}$/i || $os_parsed eq 'VMS';
        push @eprog, '--';
        push @eprog, $rprog;
        # - The path to aimake.
        push @eprog, File::Spec->rel2abs($RealScript, $RealBin);
        # - The arguments:
        #   - Preserve message-related arguments.
        push @eprog, "--verbose=$opt_verbose";
        push @eprog, "--no-carriage-return" if $opt_nocr;
        #   - Preserve config files.
        push @eprog, "--ignore-builtin-config"
            if $opt_ignore_builtin_config;
        #   - Preserve install locations (which may have been calculated rather
        #     than specified on the command line).
        push @eprog, "--install=" . aipath2ospath($ipath);
        push @eprog, "--destdir=$opt_prefix" if $opt_prefix;
        push @eprog, "--directory-layout=$opt_dlayout" if $opt_dlayout;
        #   - Always specify --install-only; we don't want to build with
        #     elevated permissions, only install.
        push @eprog, "--install-only";
        #   - Source directory.
        push @eprog, "--";
        push @eprog, aipath2ospath('path:');
        #   We do /not/ preserve: help options (--documentation, etc.), because
        #   we don't even reach this point if they're specified; rebuild
        #   options, because installs are always done in full; and
        #   --elevate-permissions itself (else we'd go into an infinite loop of
        #   permission elevation).

        # There are two styles of passing arguments to our elevation program.
        # Most of them want them as separate arguments, preceded by --. A few
        # (notably su) want them as one argument preceded by -c, which is
        # annoying because we have to shell-escape them manually. We assume
        # that if su exists at all, it wants to use sh-style escaping (because
        # it's hard to make a guess about what su does to its arguments on
        # platforms where sh doesn't exist.)
        if ($eprog[0] eq 'su') {
            # Change "su ... -- ..." to "su ... -c '...'".
            my @eprog2 = ();
            push @eprog2, (shift @eprog)
                while $eprog2[-1] ne '--';
            $eprog2[-1] = '-c';
            map s/'/'\\''/g, @eprog;
            @eprog = map "'$_'", @eprog;
            @eprog = (@eprog2, join ' ', @eprog);
        }
        my $eprog_as_string = join ' ', map {/ / ? "\"$_\"" : $_} @eprog;
        progress_report 0,
            "Elevating permissions... (if this fails, the program will exit)";
        progress_report 2, "Using command: $eprog_as_string";
        exec {$eprog[0]} @eprog;
        die "Could not elevate permissions using command: $eprog_as_string";
    }

    # Give an appropriate progress message.
    my $shortobject = friendly_objname($objname);
    my $level;
    my $verb = 'built';
    my $whatmsg;
    if ($rule->{number_of_install_actions}) {
        $whatmsg = "Installing $shortobject (rule $rulename)";
        $verb = 'installed';
        $level = 0;
    } elsif ($rule->{number_of_depend_actions}) {
        $whatmsg = "Finding dependencies of $shortobject (rule $rulename)";
        $verb = 'found';
        $level = 1;
    } elsif (!$rule->{number_of_produce_actions}) {
        if ($objname eq 'sys:no_object') {
            $whatmsg = "Finding objects (rule $rulename)";
            $verb = 'found';
            $level = 1;
        } else {
            $whatmsg = "Finding contents of $shortobject (rule $rulename)";
            $verb = 'found';
            $level = 1;
        }
    } elsif ($objname eq 'sys:no_object') {
        $whatmsg = "Running build rule $rulename";
        $level = 0;
    } else {
        $whatmsg = "Building from $shortobject (rule $rulename)";
        $level = 0;
    }
    $rule->{low_message_priority} and $level = 1;
    $rule->{debug_trace} and $level = 0;
    $rule->{verb} and $verb = $rule->{verb};

    progress_report +($level == 1 ? 0.5 : 0), "$whatmsg...";

    # Construct a desugared version of the actions.  In particular, dependency
    # action become provision actions, install actions gain an output, and
    # production actions are expressed entirely in terms of output, not in
    # terms of output_from_optpath.  This also expands the inner via appending
    # the object if necessary, so that the code can work entirely in terms of
    # the inner, and not have to worry about the object.

    # We can't use dclone() here because it doesn't work on regexes. Instead,
    # we use our own substitute deepclone(), which copies arrays and hashes
    # only, and doesn't try to preserve blessedness.
    my @actions_desugared = @{deepclone $rule->{actions}};
    for my $a (@actions_desugared) {
        if ($a->{actiontype} eq 'produce') {
            for my $stem (@{$a->{output_from_optpath}}) {
                /^optpath:\Q$stem\E:(.*)$/s
                    and push @{$a->{output}}, $1 for @xuse;
            }
            delete $a->{output_from_optpath};
        } elsif ($a->{actiontype} eq 'depend') {
            $a->{output} = ["dependencies:$rulename:$objname"];
            $a->{outputarg} = [''];
            # don't change inner; it might be used by the ->{depends}, and it
            # isn't used by the ->{output} because we gave a complete object
            # name
            $a->{outdepends} = $a->{depends};
            delete $a->{depends};
        } elsif ($a->{actiontype} eq 'install') {
            my ($objtype, undef) = parse_objname $objname;
            my @components = $objtype eq 'sys' ? $objname :
                parse_aipath $objname;
            my $install_name = defined_or($a->{install_name},
                                          $components[-1]);
            if (!$a->{install_name} && $a->{copy_structure}) {
                shift @components unless @components == 1;
                $install_name = join '/', @components;
            }
            $install_name =~ s/\Q$exeext\E$/$Config{_exe}/es;
            $a->{output_basename} = $install_name;
            $a->{outputarg} = [''];
            $a->{inner} = [''];
            # Leave the dependencies missing, so that the code will complain
            # if the install location isn't a path
        } elsif ($a->{actiontype} eq 'provide') {
            # nothing to do
        } else {
            # an easy way to make sure we didn't typo an action type
            die "Unknown action type " . $a->{actiontype};
        }

        $_ = complete_objname $_, $objname for @{$a->{inner}};
    }

    # If our output location is known in advance (rather than discovered as
    # it's proviced), create a directory for it.
    my @known_output_locations;

    for my $a (@actions_desugared) {
        for my $ostem (@{$a->{output}}) {
            (ref $ostem) =~ /\bRegexp$/ and next;
            for my $oarg (@{$a->{outputarg}}) {
                (ref $oarg) =~ /\bRegexp$/ and next;
                for my $oinner (@{$a->{inner}}) {
                    (ref $oinner) =~ /\bRegexp$/ and next;
                    my $will_output_in = $ostem . $oarg;
                    complete_and_extend \$will_output_in, $oinner;

                    ensure_directory $will_output_in, 1;

                    push @known_output_locations, $will_output_in;
                }
            }
        }
    }

    charge_profiled_time_to("Rule '$rulename': prepare to run");

    # If we're installing, install now.
    my $inapplicable = 0;
    if ($rule->{number_of_install_actions}) {
        my $a = $actions_desugared[0];

        if ($a->{install_feature} &&
            !$active_features{$a->{install_feature}}) {
            $inapplicable = 1;
        } else {
            my ($output_location, $orig_output) =
                (calculate_installation_path $a->{install_dir},
                 $a->{output_basename}, $a->{install_feature},
                 $a->{install_permission}, $a->{install_elevation},
                 $a->{install_readable}, undef, undef,
                 $objname eq 'sys:create_subdir' ? 2 : undef);

            @known_output_locations = ($output_location);

            my ($objtype, undef) = parse_objname $objname;
            my $fon = friendly_objname $output_location;

            my $executable_installed_to = undef;

            if ($objtype ne 'sys') {
                my $ospathfrom = aipath2ospath $objname;
                my $ospathto = aipath2ospath $output_location;

                # Delete the target file/link before installing over it, so
                # that we can replace executables on UNIXy systems, and so
                # that we don't end up following symlinks and making a mess.
                -e $ospathto and (unlink $ospathto or die
                                  "Could not unlink '$ospathto': $!");

                if (-l $ospathfrom) {
                    # To install a symlink, we need to create a new symlink
                    # with the same target.
                    my $ltarget = readlink $ospathfrom or die
                        "Could not read symlink '$ospathfrom': $!";
                    $ltarget =~ s/\Q$exeext\E$/$Config{_exe}/es;
                    -e $ospathto || -l $ospathto and unlink $ospathto;
                    ai_symlink $ltarget, $ospathto or die
                        "Could not symlink '$ospathto' to '$ltarget': $!";

                    # If we're installing an executable, the target should
                    # also be executable. The target of the new symlink might
                    # not be in place yet, so we check the target of the old
                    # symlink.

                    -x (final_symlink_target $ospathfrom) and
                        $executable_installed_to = $ospathto;
                } else {
                    open my $fhfrom, "<$binary_layers", $ospathfrom
                        or die "Could not open '$ospathfrom' for read: $!";
                    open my $fhto, ">$binary_layers", $ospathto
                        or die "Could not open '$ospathto' for write: $!";
                    print $fhto $_ for <$fhfrom>;
                    close $fhfrom; close $fhto;

                    # If we're installing an executable, the target should
                    # also be executable.
                    -x $ospathfrom and chmod 0755, $ospathto and
                        $executable_installed_to = $ospathto;
                }

            } elsif ($objname eq 'sys:touch_only') {
                # nothing to do; we already created the directory
            } elsif ($objname eq 'sys:create_subdir') {
                ensure_directory $output_location, 0, 1;
            } elsif ($objname eq 'sys:empty_file') {
                my $ospathto = aipath2ospath $output_location;
                open my $fhto, ">$binary_layers", $ospathto
                    or die "Could not open '$ospathto' for write: $!";
                close $fhto;
            } elsif ($objname eq 'sys:ensure_exists') {
                my $ospathto = aipath2ospath $output_location;
                if (!-e $ospathto) {
                    open my $fhto, ">$binary_layers", $ospathto
                        or die "Could not open '$ospathto' for write: $!";
                    close $fhto;
                }
            } else {
                die "System object '$objname' cannot be installed";
            }

            # If we installed an executable, set its parameters.
            if (defined $executable_installed_to &&
                $objname =~ /\Q$exeext\E$/) {
                my $exefail = set_exeparams $a->{exeparams},
                $executable_installed_to, $orig_output, $a->{install_feature};
                $exefail and
                    progress_report -1, "Could not set metadata of $fon: " .
                    $exefail;
            }

            # Ditto for directories.
            if ($objname eq 'sys:touch_only' && $a->{link_to_directory}) {
                link_to_directory $orig_output, $a->{link_to_directory},
                $a->{install_feature};
            }

            # If necessary, elevate or restrict permissions.
            $a->{install_permission} || $a->{install_elevation} and
                (set_permissions $a->{install_permission},
                 $a->{install_elevation},
                 $output_location, $a->{install_readable},
                 scalar ($a->{install_dir} =~ /(?:state|lock|log)dir$/)
                 or progress_report -1,
                 "Could not alter permissions of $fon: $!");

        }
        # The rule does no further outputting.
        $actions_desugared[0]{output} = [];
    }

    # Calculate the command line.
    my @rcargs = @xuse;
    defined $rule->{in_subdir} and push @rcargs,
        \ ("cwd:" . $rule->{in_subdir}), \ "relpaths";
    defined $rule->{force_locale} and push @rcargs,
        \ ("locale:" . $rule->{force_locale});
    $rule->{debug_trace} and push @rcargs, \ "debug_trace";

    # Run the command.
    my ($failreason, $stdout, $stderr) = run_command(@rcargs);
    $inapplicable and $failreason = 'not installing this feature';

    charge_profiled_time_to("Rule '$rulename': run_command");

    $rule->{also_match_stderr} and ($stdout, $stderr) = ($stdout.$stderr, '');

    my $hide_stderr = defined $failreason ?
        $rule->{hide_errors} : $rule->{ignore_warnings};
    my $shortfailreason;
    if (defined $failreason) {
        $shortfailreason = $failreason;
        # Construct a verbose explanation of what went wrong. We might or
        # might not show it, depending on the value of hide_errors.
        $failreason .= ", with the following command line:\n";
        $failreason .= run_command(@rcargs, \ "cmdline");
        if (defined $stderr and $stderr ne '') {
            $failreason .= "\nand the following messages:\n$stderr";
        }
        chomp $failreason;

        $stderr =~ /\!AIMAKE_FAIL_SILENTLY\!/ and $inapplicable = 1;
    }

    # Split the output on lines, unless an internal command did that for us.
    my $parsed_output = $stdout;
    if (ref $parsed_output) {
        $parsed_output = dclone $parsed_output;
    } else {
        # Remove the very last newline from $out.
        chomp $parsed_output;
        my $linesep = $rule->{linesep};
        (ref $linesep) !~ /\bRegexp$/ and $linesep = qr/\Q$linesep\E/;

        if (defined $rule->{unescape}) {
            my @out = ();
            (push @out, $1) while
                $parsed_output =~ m/((?:[^\\]|\\.)*?)(?:$linesep | $ )/gsx;
            $parsed_output = \@out;
        } else {
            $parsed_output = [split /$linesep/, $parsed_output];
        }

        if (defined $rule->{unescape} && $rule->{unescape} eq 'backslash') {
            s/\\\n//g for @$parsed_output;
            s{\\(.)}{do{my $x = $1;
                        $x =~ y/abfnrt/\a\b\f\n\r\t/; $x}}ge
                 for @$parsed_output;
            @$parsed_output = grep $_ ne '', @$parsed_output;
        } elsif (defined $rule->{unescape} &&
                 $rule->{unescape} eq 'backslash_whitespace') {
            s/\\\n//g for @$parsed_output;
            s/\\([\s\\])/$1/ge for @$parsed_output;
            $parsed_output = [grep $_ ne '', @$parsed_output];
        }
    }

    # Filter and splice the lines of the output.
    my $filter = $rule->{filter};
    $filter and $parsed_output = [grep /$filter/, @$parsed_output];
    $rule->{lineskip} and splice @$parsed_output, 0, $rule->{lineskip};
    $rule->{linemax} and splice @$parsed_output, $rule->{linemax};

    my $acount = 0;
    my %outhashes = (); # interned keys and values
    for my $a (@actions_desugared) {
        ++$acount;
        progress_report 4, "Running action $acount...";

        # Work out the effects of failure, if any.
        my $out = $parsed_output;
        my $on_failure = $a->{on_failure};
        $on_failure or $on_failure = 'auto';
        defined $failreason or $on_failure = 'success';
        # Resolve any 'auto' on_failure specification.
        $inapplicable and $on_failure eq 'auto' and
            $on_failure = 'inapplicable';
        $on_failure eq 'auto' and $on_failure = 'fail';
        # If we didn't succeed, and aren't parsing the output even on failure,
        # we just empty the output.
        $on_failure eq 'parse' or $on_failure eq 'success' or $out = [];
        # If the command fails but the action doesn't, change the default for
        # hide_stderr.
        if (!defined $hide_stderr) {
            $on_failure eq 'fail' or $hide_stderr = 1;
        }
        # "fail"/"inapplicable" give us no output; "conditional" gives us no
        # dependencies.
        $on_failure eq 'fail' and $a->{output} = [];
        $on_failure eq 'inapplicable' and
            $a->{$a->{actiontype} eq 'depend' ? 'outdepends' : 'output'} = [];
        $on_failure eq 'conditional' and $a->{outdepends} = [];
        $on_failure eq 'alternative' and $a->{outdepends} =
            deepclone($a->{alternative});

        # Replace all regular expressions in the desugared action with
        # matches from $parsed_output.
        for my $field (qw/output outputarg outdepends dependsarg inner/) {
            next unless $a->{$field};
            my @newfield = ();
            for my $el (@{$a->{$field}}) {
                unless ((ref $el) =~ /\bRegexp$/) {
                    push @newfield, $el;
                    next;
                }
                # Work out whether we need an ospath2aipath on matches.
                my $aify = (!ref $stdout && $field !~ /arg$/);
                my $matched = 0;
                # The actual matching comes here.
                for my $line (@$parsed_output) {
                    while ($line =~ m/$el/g) {
                        $matched = 1;
                        my $n = $1;
                        if ($aify) {
                            my $old_n = $n;
                            $n = ospath2aipath($n, 1);
                            $n eq 'file:' and
                                die "ospath2aipath could not parse '$old_n' ".
                                "(pair $curpair)";
                        }
                        $n =~ /^file:/ and $a->{output_as_searchfile}
                        and $n = "search$n";
                        $n =~ /^spath:/ and $a->{output_as_standardlib}
                        and $n =~ s/^spath:/standardlib:/;
                        push @newfield, $n unless
                            ($n =~ /^spath:/ && $a->{filter_spath}) ||
                            ($n !~ /^(search)?file:/ &&
                             $a->{filter_absolute}) ||
                             ($a->{filter_nonexistent_files} &&
                              $n =~ /^(?:[bs]?path|standardlib):/ &&
                              (!-e aipath2ospath($n) || (!-f _ && !-l _))) ||
                              ($a->{filter_text_files} &&
                               $n =~ /^(?:[bs]?path|standardlib):/ &&
                               -T aipath2ospath($n));
                    }
                }
                $matched or !$rule->{require_match} or
                    die "Rule '$rulename' on object '$objname' failed to ".
                    "match output $el";
            }
            $a->{$field} = \@newfield;
        }

        # Construct an output and an outdepends.
        $a->{outdepends} or $a->{outdepends} = [];

        my @output = ();
        my @outdepends = ();
        for my $ostem (@{$a->{output}}) {
            for my $oarg (@{$a->{outputarg}}) {
                my $x = $ostem . $oarg;
                if (objname_needs_completion $x) {
                    for my $oinner (@{$a->{inner}}) {
                        my $y = complete_objname $x, $oinner;
                        push @output, resolve_extend $y;
                    }
                } else {
                    push @output, resolve_extend $x;
                }
            }
        }
        for my $dstem (@{$a->{outdepends}}) {
            for my $darg (@{$a->{dependsarg}}) {
                my $x = $dstem . $darg;
                if (objname_needs_completion $x) {
                    for my $dinner (@{$a->{inner}}) {
                        my $y = complete_objname $x, $dinner;
                        push @outdepends, resolve_extend $y;
                    }
                } else {
                    push @outdepends, resolve_extend $x;
                }
            }
        }

        $rule->{object_dependency} eq 'outdepends' and
            push @outdepends, $objname;
        @output = grep {$_ ne $objname} @output;

        # Check for insane output.
        for my $o (@output) {
            my ($otype, undef) = parse_objname $o;
            if ($otype eq 'dependencies') {
                croak "Production action $acount of rule '$rulename' output $o"
                    unless $a->{actiontype} eq 'provide' ||
                    $a->{actiontype} eq 'depend';
            } elsif ($objtype_provided{$otype}) {
                croak "Non-provision action $acount of rule '$rulename' output ".
                    "provided object $o" unless $a->{actiontype} eq 'provide';
            } elsif ($otype eq 'bpath') {
                croak "Non-production action $acount of rule '$rulename' output ".
                    "produced object $o" unless $a->{actiontype} eq 'produce';
            } elsif (!exists $a->{information_only}) {
                croak "Rule $rulename output unprovicable object $o";
            }
        }
        for my $o (@outdepends) {
            parse_objname $o; # check it's a well-formed object name
        }

        # Some rules may produce lots of duplicate output dependencies.
        # This has the same meaning as non-duplicate dependencies, so we can
        # just remove the copies. Make sure to keep them in the same order.
        #
        # We also intern the @outdepends array in this loop (it's previously
        # an array of object names).
        my @outdepends_duplicates = @outdepends;
        @outdepends = ();
        my %outdepends_seen = ();
        for my $outdependency (@outdepends_duplicates) {
            if (!$outdepends_seen{$outdependency}) {
                $outdepends_seen{$outdependency} = 1;
                push @outdepends, intern $outdependency;
            }
        }

        # Record the outputs.
        $outhashes{intern $_} = \@outdepends for @output;
    }

    # If we would produce an object that matches this rule's "object =>"
    # regex, error out due to the likely infinite regress. Exception: if
    # the rule avoids itself.
    if ((ref $rule->{object}) =~ /\bRegexp$/) {
        for my $ioutobj (keys %outhashes) {
            my $outobj = unintern $ioutobj;
            if ($outobj =~ $rule->{object} &&
                (!$rule->{avoid_rules} || $rulename !~ $rule->{avoid_rules})) {
                $failreason = <<EOF;
rule can take its own output as input
The rule's 'object', $rule->{object},
matches its own output object, '$outobj'.
This usually causes an infinite regress, so is not allowed.
Did you forget to anchor a regular expression?
e.g. object => qr/path:.../ is usually wrong, you probably meant qr/^path:.../
Alternatively, consider adding the rule to its own avoid_rules, so that it
will refuse to take its own output as input.
EOF
                # ' # this line fixes syntax highlighting in Emacs
                $errorexit = 3;
                $shortfailreason = 'rule can take its own output as input';
                $hide_stderr = 0;
                %outhashes = ();
            }
        }
    }

    # For each output object that matches a feature that's turned off, delete
    # it.
    for my $feature (keys %{$config->{features}}) {
        next if $active_features{$feature};
        for my $ioutobj (keys %outhashes) {
            (unintern $ioutobj) =~ $config->{features}{$feature}{object} and
                delete $outhashes{$ioutobj};
        }
    }

    # Work out which objects we want to tell the user about. To match the
    # progress message printed earlier, we list dependencies: objects as
    # their outdepends if there's a depend action involved. For an install
    # action, we list the known output location.
    my %shortened;
    for my $ioutobj (keys %outhashes) {
        my $outobj = unintern $ioutobj;
        if ($outobj =~ /^dependencies:/ &&
            $rule->{number_of_depend_actions}) {
            $shortened{friendly_objname(unintern $_)} = 1
                for @{$outhashes{$ioutobj}};
        } else {
            $shortened{friendly_objname($outobj)} = 1;
        }
    }

    $rule->{number_of_install_actions} and !$inapplicable
        and $shortened{friendly_objname($known_output_locations[0])} = 1;

    # Record where we installed things.
    $rule->{number_of_install_actions} and $installed_location{$objname} =
        $known_output_locations[0];
    my $msg;
    if (!$failreason || $hide_stderr) {
        if (keys %shortened == 0) {
            $msg = "Succeeded but $verb no objects";
            # Install rules output no objects, but still do something.
            # We can look at @known_output_locations to find the actual
            # installed object.
            $rule->{install_dir} and $msg = "Installed into " .
                friendly_objname($known_output_locations[0]);
            # If there are no objects found /and/ the rule failed, it must be
            # because the actions had an on_failure set (most likely
            # inapplicable). TODO: This message could be better in the case of
            # all actions set to 'empty' and no output produced as a result.
            $failreason and $msg =
                "Skipped the rule because it is disabled in this configuration.";
        } elsif (scalar keys %shortened <= 4) {
            $msg = ucfirst $verb . " " . join ', ', sort keys %shortened;
        } else {
            my @shortened = sort keys %shortened;
            $msg = ucfirst $verb . " " . $shortened[0] . ", " .
                $shortened[1] . ", ". $shortened[2] . ", and " .
                (scalar @shortened - 3) . " other objects";
        }
        $msg .= (defined $stderr && $stderr ne '' ?
                 " (with warnings)." : ".") unless $failreason;
    } else {
        if ($objname eq 'sys:no_object') {
            $msg = "Couldn't run rule $rulename: $shortfailreason";
        } else {
            $msg = "Couldn't run rule $rulename on $objname: $shortfailreason";
        }
    }
    progress_report +($failreason && !$hide_stderr ? -1 : $level), $msg;

    charge_profiled_time_to("Rule '$rulename': parse output");

    atomically {
        if ($failreason && !$hide_stderr) {
            record_pair_error $curpair, "$whatmsg failed: $failreason";
        } else {
            # Calculate the hashes of all produced objects. The only produced
            # objects that normal rules are allowed to produce are path,
            # bpath, spath, standardlib. (And extend, but that's been replaced
            # by now.)  This is done here because file_hash needs atomically()
            # protection.
            for my $io (keys %outhashes) {
                my ($otype, undef) = parse_objname unintern $io;
                my $o = unintern $io;
                if ($objtype_provided{$otype}) {
                    # do nothing, the hash is already correct
                } elsif ($otype =~ /^(?:[bs]?path|standardlib)/) {
                    $outhashes{$io} = deepclone($outhashes{$io});
                    unshift @{$outhashes{$io}}, intern
                        ("hash_on_disk:" . defined_or((file_hash $o), "") . ":$o");
                } else {
                    croak "Rule $rulename output the wrong " .
                        "type of object: $o";
                }
            }
            !defined $stderr || $stderr eq '' || $hide_stderr
                and $stderr = undef;
            defined $stderr and
                $stderr = "$whatmsg produced warnings, with the following ".
                "command line:\n" . run_command(@rcargs, \ "cmdline") .
                "\n" .$stderr;
            record_pair_outputs $curpair, \%outhashes, $stderr;
        }

        delete $pairs_currently_running{$curpair};

        charge_profiled_time_to("Rule '$rulename': record output");
    };
}

##### Cleanup
#
# We don't make any state changes during cleanup; this is because the compile
# process is designed to work even when interrupted at any point (reverting to
# the start of the atomically{} block if it's interrupted inside one of
# those). As such, this is pretty much entirely about printing messages.
#
# As one exception, the actual file writing is postponed until the end of the
# program, or a death/error. As such, we need to finish off with
# write_statefile.


### File lists
my $flerr;
$installing and $flerr = write_filelist;
$flerr and progress_report -1, "Could not write file list: $flerr\n";

### Installer generation
#
# This needs to come after the install (thus it's in cleanup), and after the
# file list is written.

if ($opt_gen_installer && $opt_gen_installer eq 'msi') {{

    # Installer compile

    progress_report 0, "Compiling installer...";

    my $arch = $pointerbits == 64 ? 'x64' : 'x86';
    my $pname = $config->{options}{packagename};
    my $aifilelist = destdir_transform "spath:$pname.wxs";
    my $aidir = destdir_transform "spath:";

    my ($failreason, $stdout, $stderr) = run_command
        \ "cwd:$aidir", \ "relpaths", "cmd:candle", "optstring:-arch $arch",
        "optstring:-nologo", "optpath::$aifilelist";

    # WiX mixes up its error output and informational output, all on stdout.
    # So we merge stderr and stdout, then remove the informational output
    # we expect.
    $stdout and $stderr .= $stdout;
    $stderr =~ s/^$pname\.wxs\n*//m;

    $failreason and progress_report -1,
        "Could not generate installer: install compile failed: $failreason";
    !$failreason and $stderr and progress_report -1,
        "Compiling the installer generated warnings:";
    $stderr and progress_report -1, $stderr;
    $failreason and last;

    # Installer link

    # There are a /ton/ of false positives in the error/warning checks, most
    # of which are all due to the same bug, and the fact that aimake's
    # workarounds from the bug are different from the official ones because
    # the official ones make no sense.

    progress_report 0, "Linking installer...";

    my @false_positive_ice = qw/38 43 57 64 90/;
    @false_positive_ice = map "optstring:-sice:ICE$_", @false_positive_ice;
    my $license = $installed_location{'bpath:aimake/license.rtf'};

    if (!$license) {
        progress_report -1, "Could not generate installer: no EULA";
        last;
    }

    $aifilelist =~ s/\.wxs$/.wixobj/;
    ($failreason, $stdout, $stderr) = run_command
        \ "cwd:$aidir", \ "relpaths", "cmd:light", "optstring:-nologo",
        "optstring:-ext WixUIExtension", @false_positive_ice,
        "optpath:-dWixUILicenseRtf=:$license", "optpath::$aifilelist";
    $stdout and $stderr .= $stdout;

    $failreason and progress_report -1,
        "Could not generate installer: install link failed: $failreason";
    !$failreason and $stderr and progress_report -1,
        "Linking the installer generated warnings:";
    $stderr and progress_report -1, $stderr;
    $failreason and last;

    # Move the generated install file into the root of the build dir.
    $aifilelist =~ s/\.wixobj$/.msi/;
    if (File::Copy::move +(aipath2ospath $aifilelist),
        +(aipath2ospath "bpath:$pname.msi")) {
        progress_report 0, "Generated an installer at: " .
            aipath2ospath "bpath:$pname.msi", "bpath:";
    } else {
        progress_report -1, "Could not write installer file '" .
            (aipath2ospath "bpath:$pname.msi", "bpath:") . "': $!"
    }

    charge_profiled_time_to('Generate installer');
}}

my $anyproblems = 0;

### Errors and warnings during compile
#
# We need to report any warning/error messages to the user. These are stored
# in $state->{errwarn_by_pair}; we output the object, the rule, and the
# message. The object/rule were added earlier, so this is a pretty simple
# loop.

atomic_read {
    my $ewprinted = 0;
    for my $ipair (sort keys %{$state->{errwarn_by_pair}}) {
        if (!$ewprinted) {
            progress_report -1,
                "\nThe following warnings/errors were reported:\n";
        }
        my $msg = $state->{errwarn_by_pair}{$ipair};
        $msg =~ /^E:/ and $anyproblems++;
        $msg =~ s/^[EW]://s;
        progress_report -1, "$msg\n";
        $ewprinted++;
    }
};

charge_profiled_time_to('Errors/warnings');

### Dependency problems
#
# A pair has dependency problems if it's non-changed, all objects in its command
# exist, and at least one object in its xuse doesn't exist. (There are a few
# more things true about such pairs, e.g. they don't appear in outdep_by_pair,
# but we don't need to worry about that when presenting our output.)

my $any_system_header_warning = 0;

atomically {
    my $ewprinted = 0;
    my %bad_rule_deps;
    # Note that pairs with unknown xuse still have an xuse_by_pair key, just
    # an undef value.
  DEPCHECK: for my $ipair (sort keys %{$state->{xuse_by_pair}}) {
        my $pair = unintern $ipair;
        my ($rulename, $objname) = parse_pairname $pair;
        $rulename eq 'parse_configuration' and next; # special case
        $config->{rules}{$rulename} or next;
        keys %{$config->{rules}{$rulename}} or next;
        my $command = $config->{rules}{$rulename}{command};
        $command = [@$command];
        complete_and_extend \$_, $objname for @$command;
        object_exists $_ or next DEPCHECK for @$command;
        $state->{blocked_by_pair}{$ipair} and
            croak "Pair '$pair' is blocked by '" .
            (unintern $state->{blocked_by_pair}{$ipair}) . "', existence '" .
            ((object_exists unintern $state->{blocked_by_pair}{$ipair}) ?
             'yes' : 'no') . "', command [@$command]";
        my ($is_tied, $wanted, $user, $objects_in_tie) = check_xuse_ties $pair;
        my @missing_deps;
        my $verb = 'missing';
        my $system_header_warning = 0;
        if (!$is_tied) {
            defined $state->{xuse_by_pair}{$ipair} and
                @missing_deps = sort grep +((!object_exists $_) &&
                                            $_ ne 'sys:clean'),
                map unintern $_, @{$state->{xuse_by_pair}{$ipair}};
            $_ = (friendly_objname($objname) ne
                  friendly_objname(unintern
                                   $state->{xuse_by_object}{intern $_}{$ipair}) ?
                  friendly_objname($_) . '(' .
                  friendly_objname(unintern
                                   $state->{xuse_by_object}{intern $_}{$ipair})
                  . ')' : friendly_objname($_))
                for @missing_deps;
        } else {
            @missing_deps = @$objects_in_tie;
            $verb = "multiple possibilities for " .
                friendly_objname($wanted) . ':';
            $_ = extract_interesting_pair_component $_ for @missing_deps;
            for my $dep (@missing_deps) {
                $dep =~ m(^spath:.*\b[^\/]*\.h$) and $system_header_warning = 1;
            }
            m/:/ and $_ = friendly_objname($_) for @missing_deps;
        }
        (scalar @missing_deps) or next;

        $anyproblems++; # this sort of missing dependency is a problem

        if (!$ewprinted) {
            progress_report -1,
                "\nThe following rules did not run due to dependency issues:\n";
        }

        if ((scalar @missing_deps) > 4) {
            $missing_deps[3] = 'and ' . ((scalar @missing_deps) - 3) .
                " more objects";
            $#missing_deps = 3;
        }
        my $missing_deps = join ', ', @missing_deps;

        $system_header_warning and !$any_system_header_warning and
            $errorexit = 2, $missing_deps .= <<'EOF';

Were you trying to include a system header file? If you want to use the system's
normal include order rather than potentially looking for the file in your own
project (perhaps causing ambiguity when it isn't found), say so: write, e.g.,
'#include <stdio.h>' rather than '#include "stdio.h"'.
EOF
        # ' # fix syntax highlighting for Emacs
        $any_system_header_warning ||= $system_header_warning;

        if ($objname eq 'sys:no_object') {
            $bad_rule_deps{"$rulename: $verb $missing_deps"} = {};
        } else {
            $bad_rule_deps{"$rulename on #OBJECT#: $verb $missing_deps"}->
                          {$objname} = 1;
        }
        $ewprinted++;
    }
    for my $msg (sort keys %bad_rule_deps) {
        my @objs = keys %{$bad_rule_deps{$msg}};
        if (0 == scalar @objs) {
            progress_report -1, $msg;
        } elsif (scalar @objs <= 3) {
            $msg =~ s/#OBJECT#/
                join(', ', map friendly_objname($_), @objs)/e;
            progress_report -1, $msg;
        } else {
            $msg =~ s/#OBJECT#/(scalar @objs).' objects'/e;
            progress_report -1, $msg;
        }
    }
};

charge_profiled_time_to('Report dependency issues');

### Dependency loops
#
# One thing that's definitely a problem is loops in the dependencies. There
# are a few possible ways this can manifest:
# - None of the objects in the loop were pre-existing, and the loop goes
#   through depends or outdepends fields. This will have been warned about as
#   a missing dependency already (although aimake won't realise why the
#   dependency is missing).
# - None of the objects in the loop were pre-existing, and the loop goes
#   entirely through command and output fields. This won't have been warned
#   about yet (because every rule in the loop will be blocked).
# - At least one of the objects in the loop was pre-existing, causing the
#   loop to go most of the way round (and then fail due to unsureness).
# The third case is pretty easy to detect; it gives us an object that's unsure
# with respect to a changed pair (as opposed to a pair that previously
# succeeded now failing, which gives us an object that's unsure with respect
# to an unchanged pair). In general, the first two cases cannot be detected;
# the object name that's output by a rule may depend on the contents of the
# objects that are input.

atomically {
    my $ewprinted = 0;
    my %loop_objects = ();
    for my $ipair (keys %{$state->{unsure_by_pair}}) {
        $state->{changed_pairs}{$ipair} or next;
        for my $iobj (keys %{$state->{unsure_by_pair}{$ipair}}) {
            $loop_objects{unintern $iobj} = 1;
        }
    }
    for my $ipair (keys %{$state->{unsure_by_pair}}) {
        $state->{changed_pairs}{$ipair} or next;
        my $pair = unintern $ipair;
        for my $iobj (keys %{$state->{unsure_by_pair}{$ipair}}) {
            my $obj = unintern $iobj;
            my $fobj1 = friendly_objname $obj;
            my ($sure, $iunsure_list) = pair_is_sure $pair, 0;
            $sure and croak "Pair $pair is changed yet sure at program end";

            $iunsure_list->[0] == intern 'tie' and next;
            $iunsure_list->[0] == intern 'recursion' and next;

            # If a rule errored out, we can get a changed, unsure rule that
            # isn't involve in a dependency loop. Discover if it's in a loop
            # via actually looking for the object that's in the loop.
            my $last_obj = unintern $iunsure_list->[-2];
            $loop_objects{$last_obj} or next;

            $anyproblems++;

            if (!$ewprinted) {
                progress_report -1,
                    "\nThe following dependency loops were detected:\n";
                $ewprinted++;
            }

            # The list alternates between xuses and pairs, with an xuse at
            # the start and a pair at the end.
            unshift @$iunsure_list, intern $obj, intern $pair;
            pop @$iunsure_list;
            my $ir = "";
            my $mr = "is output by";
            while (@$iunsure_list > 1) {
                my $x = unintern shift @$iunsure_list;
                my $p = unintern shift @$iunsure_list;
                my ($rule, $pobj) = parse_pairname $p;
                my $fx = friendly_objname $x;
                my $fo = friendly_objname $pobj;
                if ($pobj eq 'sys:no_object') {
                    progress_report -1, "$ir$fx $mr rule $rule,";
                } else {
                    progress_report -1, "$ir$fx $mr rule $rule on $fo,";
                }
                $ir = "  which depends on ";
                $mr = "which is output by";
            }
            # Complete the loop. It either loops back on itself, or joins onto
            # another loop; either way, there's enough information for the
            # user to calculate the entire loop.
            my $fl = friendly_objname $last_obj;
            progress_report -1, "  which depends on $fl.\n";
        }
    }
};

charge_profiled_time_to('Report dependency loops');

### Garbage collection

atomically {
    # clobbers %unintern
    garbage_collect_statefile;
};

charge_profiled_time_to('Garbage collection');

write_statefile;
progress_report 3, "Main program is ending.";

charge_profiled_time_to('Final statefile write');

### Reporting profiling data
#
# This must be done last, because anything that happens after it can't be
# profiled.

flush STDERR;
if ($opt_profile) {
    print "\nProfiling information: \n";
    for my $k (sort {$profile_intervals{$b} <=> $profile_intervals{$a}}
               keys %profile_intervals) {
        printf "%12.6f %s\n", $profile_intervals{$k}, $k;
    }
}

$anyproblems and exit ($opt_specific_exit_status ? $errorexit : 1);

####### Configuration files
#
# The default configuration file is appended to this script, in order to keep
# the aimake distribution as just one file.
__DATA__
# aimake config file. This is written in a very limited dialect of Perl (which
# only allows scalar, regex, array, and hash constants, and assigning to and
# using scalar variables), and determines the behaviour on different sorts of
# files.
#
# This file is the global file that specifies default behaviour for aimake,
# and is designed to work on a wide range of projects (and hopefully,
# eventually, operating systems). Projects can use their own specific
# aimake.rules file to override the config in this file.
#
# See `perldoc -F aimake` (or equivalently `aimake --documentation`) for the
# format of this file.

{
    options => {
        ignore_directories =>
            qr/^(?:\.svn|\.git|\.hg|\.bzr|_darcs)$/i,
        ignore_directories_with_files => [
            'aimake.state',       # old versions of aimake
            'aimake2.state',      # old versions of aimake
            'aimake.objects',     # this version of aimake
            'config.status',      # autoconf
            'CMakeCache.txt',     # CMake
            'aimake-ignore-this', # so that other directories can be ignored
        ],
        ignore_files =>
            qr/(?:[:\/](?:aimake\.local\ |
                          \.emacs\.desktop(?:\.lock)? |
                          cscope[^\/]* |
                          tags |
                          #[^\/]*#
                        ) |
                   \.swp | \.kate-swp |
                   \.gitignore |
                   \.orig | \.rej |
                   \~ | \.bak
               )$/ix,
        directory_layout => 'autodetect',
        directory_layout_fallback => 'single_user',
    },

    features => {
        sourcecode => {
            description => "Source code",
            long_description => "Installs the source code from which this ".
                                "package was built. This information enables ".
                                "developers to debug, make modifications to, ".
                                "and write patches for this package.",
            object => qr=(?!)=,
            default => 0,
        },
    },

    # Directories. One of these directory sets is used for the install,
    # based on the command line options or the install directory; they
    # become normal options early in the compile process.
    directories => {

        # FHS layout: used for installed programs on UNIX/Linux systems. This
        # layout uses a wide variety of directories, and typically has
        # $installdir = spath:/usr. (In fact, the only other directory it
        # really makes sense with is the root directory, which is why it
        # specifies /usr explicitly sometimes. It'll only be used in /usr,
        # the root directory, or if the user specifically requests it.)
        fhs => {
            autodetect => qr=^spath:/(?:usr)?$=,
            preferred_installdir => 'spath:/usr',

            # Relative to the root directory.
            configdir => 'spath:/etc',
            staterootdir => 'spath:/var',

            # Relative to -i on the command line, or to /usr, depending on
            # whether there are one or two copies of the directory.
            bindir => '$installdir/bin',
            rootbindir => '$installdir/sbin',
            gamesbindir => 'spath:/usr/games',
            libdir => '$installdir/lib',
            specificlibdir => '$installdir/lib/$packagename',
            includedir => 'spath:/usr/include',
            specificincdir => 'spath:/usr/include/$packagename',
            datarootdir => 'spath:/usr/share',
            sourcecodedir => 'spath:/usr/src',

            # Relative to datarootdir.
            datadir => '$datarootdir/$packagename',
            gamesdatadir => '$datarootdir/games/$packagename',
            shortcutdir => '$datarootdir/applications',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc/$packagename',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/usr is a read-only tree (except during install).
            statedir => '$staterootdir/lib/$packagename',
            gamesstatedir => '$staterootdir/games/$packagename',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/run/lock',
            specificlockdir => '$staterootdir/run/lock/$packagename',
        },

        # FHS layout, non-package-manager version. There's a set of
        # directories set aside for package manager use; this avoids them as
        # far as possible, using a set of directories that the package manager
        # has been told not to touch.
        fhs_unmanaged => {
            autodetect => qr=^spath:/usr/local$=,
            preferred_installdir => 'spath:/usr/local',

            # Relative to the root directory.
            # Package managers can mess with /etc, but they're not allowed to
            # mess with files there that they don't recognise, so just using
            # /etc would be theoretically OK. However, the FHS suggests using
            # /usr/local/etc in install programs (the user can make that a
            # symlink to /etc/local if they'd prefer things in the /etc
            # hierarchy).
            configdir => '$installdir/etc',
            staterootdir => 'spath:/var',

            # Relative to -i on the command line.
            bindir => '$installdir/bin',
            rootbindir => '$installdir/sbin',
            gamesbindir => '$installdir/games',
            libdir => '$installdir/lib',
            specificlibdir => '$installdir/lib/$packagename',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include/$packagename',
            datarootdir => '$installdir/share',
            sourcecodedir => '$installdir/src',

            # Relative to datarootdir.
            datadir => '$datarootdir/$packagename',
            gamesdatadir => '$datarootdir/games/$packagename',
            shortcutdir => '$datarootdir/applications',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc/$packagename',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/usr is a read-only tree (except during install).
            statedir => '$staterootdir/local/$packagename',
            # The FHS is silent on the correct name for gamesstatedir
            # for an unpackaged directory. This seems like a decent
            # guess though...
            gamesstatedir => '$staterootdir/local/games/$packagename',
            # Logs likely need rotation. I'm not 100% sure this is correct.
            logdir => '$staterootdir/log',
            # lockdir needs to be /var/run/lock because it's probably a
            # symlink to /run/lock (and being a transient directory anyway, a
            # package manager can't meaningfully manage it).
            lockdir => '$staterootdir/run/lock',
            specificlockdir => '$staterootdir/run/lock/$packagename',
        },

        # Add-on package layout on FHS systems. This puts most things in an
        # entirely separate hierarchy of their own; it can be seen as the
        # system-wide version of installing in /home. Note that we could
        # actually use any layout we like here for the files in /opt; the
        # only requirement is the /var/opt, /etc/opt, /opt split. However,
        # we try to keep things in an FHS-like order because that's what the
        # program may be expecting.
        fhs_package => {
            autodetect => qr=^spath:/opt/=,
            preferred_installdir => 'spath:/opt/$packagename',

            # Relative to the root directory.
            configdir => 'spath:/etc/opt/$packagename',
            staterootdir => 'spath:/var/opt/$packagename',

            # Relative to -i on the command line.
            bindir => '$installdir/bin',
            rootbindir => '$installdir/bin',
            gamesbindir => '$installdir/bin',
            libdir => '$installdir/lib',
            # Because we're already in a package-specific directory, the
            # libdir and specificlibdir are the same.
            specificlibdir => '$installdir/lib',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include',
            datarootdir => '$installdir/share',
            sourcecodedir => '$installdir/src',

            # Relative to datarootdir.
            datadir => '$datarootdir',
            gamesdatadir => '$datarootdir',
            shortcutdir => '$datarootdir/applications',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc',

            # Relative to staterootdir.
            # Note that these have to be outside $installdir, because
            # spath:/opt is a read-only tree (except during install).
            statedir => '$staterootdir',
            gamesstatedir => '$staterootdir',
            logdir => '$staterootdir/log',

            # Relative to /var/run/lock. (On many systems, it's /run/lock
            # nowadays, but the /var name has a longer history and is likely
            # to be a symlink for the forseeable future.)
            lockdir => 'spath:/var/run/lock',
            specificlockdir => 'spath:/var/run/lock/$packagename',
        },

        # Installing for just one user. (The /Users/ autodetect is for Mac OS
        # X.) As such, care must be taken to avoid any FHS-specific paths. We
        # still use a vaguely FHS-like layout to keep things neat, but with
        # more generic names, and all the directories are arbitrary. (One big
        # difference is the use of $installdir, not $installdir/bin, for
        # binaries; this makes them easier to find.)
        single_user => {
            autodetect => qr=^spath:(?:/home/|/Users/)=,
            preferred_installdir => 'bpath:aimake_install',

            # Everything is relative to -i on the command line.
            configdir => '$installdir/config',
            staterootdir => '$installdir',
            bindir => '$installdir',
            rootbindir => '$installdir',
            gamesbindir => '$installdir',
            libdir => '$installdir/lib',
            # Because we're already in a package-specific directory, the
            # libdir and specificlibdir are the same.
            specificlibdir => '$installdir/lib',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include',
            datarootdir => '$installdir',
            sourcecodedir => '$installdir/source',

            # Relative to datarootdir.
            datadir => '$datarootdir/data',
            gamesdatadir => '$datarootdir/data',
            shortcutdir => '$datarootdir/applications',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc',

            # Relative to staterootdir.
            statedir => '$staterootdir/data-rw',
            gamesstatedir => '$staterootdir/save',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/lock',
            specificlockdir => '$staterootdir/lock',
        },

        # Basically the above, except with libdir=bindir, so that it
        # works on Windows.
        single_user_windows => {
            autodetect => qr=^spath:CSIDL_PERSONAL/=,
            preferred_installdir => 'bpath:aimake_install',

            # Everything is relative to -i on the command line.
            configdir => '$installdir/config',
            staterootdir => '$installdir',
            bindir => '$installdir',
            rootbindir => '$installdir',
            gamesbindir => '$installdir',
            libdir => '$installdir',
            specificlibdir => '$installdir',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include',
            datarootdir => '$installdir',
            sourcecodedir => '$installdir/source',

            # Relative to datarootdir.
            datadir => '$datarootdir/data',
            gamesdatadir => '$datarootdir/data',
            mandir => '$datarootdir/man',
            shortcutdir => '$datarootdir/shortcuts',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc',

            # Relative to staterootdir.
            statedir => '$staterootdir/data-rw',
            gamesstatedir => '$staterootdir/save',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/lock',
            specificlockdir => '$staterootdir/lock',
        },

        # Standard layout for files that are installed under Windows.
        windows => {
            autodetect => qr=^spath:CSIDL_PROGRAM_FILES(?:/|$)=,
            preferred_installdir => 'spath:CSIDL_PROGRAM_FILES',

            # We use a subdirectory of the given directory, which should be
            # Program Files itself or a vendor subdir.
            exerootdir => '$installdir/$packagename_ui',

            # This is somewhat different from Linux, because files are sorted
            # by vendor (i.e. $installdir) rather than by purpose. A side
            # effect is that we have a lot of freedom to arrange files within
            # the $exerootdir; "fhs_package" is probably the closest Linux
            # equivalent. However, we need libdir == specificlibdir == bindir
            # for DLLs to be found correctly, at least until I figure out how
            # an RPATH works on Windows.
            #
            # Windows has less of a culture than Linux of installing things
            # like development headers, so includedir is pretty
            # arbitrary. datarootdir matching libdir is correct; Windows
            # doesn't expect any multiarch stuff to be going on. We could use
            # a location in CSIDL_PROGRAM_FILES_COMMON, but only if we got
            # the entire world to cooperate, which seems unlikely.
            #
            # Technically speaking, libdir should be CSIDL_SYSTEM in order
            # to get behaviour as close as possible to Linux's, but I have
            # a strong suspicion that that's a bad idea.
            configdir => '$exerootdir/config',
            bindir => '$exerootdir',
            rootbindir => '$exerootdir',
            gamesbindir => '$exerootdir',
            libdir => '$exerootdir',
            specificlibdir => '$exerootdir',
            includedir => '$exerootdir/include',
            specificincdir => '$exerootdir/include/$packagename',
            datarootdir => '$exerootdir/data',
            staterootdir => 'spath:CSIDL_COMMON_APPDATA/$packagename_ui',
            sourcecodedir => '$exerootdir/source',

            docdir => '$exerootdir/doc',
            mandir => '$docdir/manuals',

            shortcutdir => 'spath:CSIDL_COMMON_PROGRAMS/$packagename_ui',

            # Relative to datarootdir.
            datadir => '$datarootdir',
            gamesdatadir => '$datarootdir',
            # Dubious on Windows, but...
            infodir => '$datarootdir/info',

            # Relative to staterootdir.
            statedir => '$staterootdir/data-rw',
            gamesstatedir => '$staterootdir/save',
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/lock',
            specificlockdir => '$staterootdir/lock',
        },

        # Traditional behaviour of --prefix under most other build systems.
        # Packaging systems normally assume that something like this is
        # available.
        prefix => {
            autodetect => qr=(?!)=,
            preferred_installdir => 'spath:/',

            configdir => '$installdir/etc',
            staterootdir => '$installdir/var',
            bindir => '$installdir/bin',
            rootbindir => '$installdir/sbin',
            gamesbindir => '$installdir/bin',
            libdir => '$installdir/lib',
            specificlibdir => '$installdir/lib/$packagename',
            includedir => '$installdir/include',
            specificincdir => '$installdir/include/$packagename',
            datarootdir => '$installdir/share',
            sourcecodedir => '$installdir/src',

            # Relative to datarootdir.
            datadir => '$datarootdir/$packagename',
            gamesdatadir => '$datarootdir/games/$packagename',
            shortcutdir => '$datarootdir/applications',
            mandir => '$datarootdir/man',
            infodir => '$datarootdir/info',
            docdir => '$datarootdir/doc/$packagename',

            # Relative to staterootdir.
            # For the first two, it's unclear which directory we should
            # be using. This currently assumes the same layout as /var;
            # automake uses $staterootdir raw but that seems very liable
            # to break things. This feature is rarely used anyway, which
            # makes it hard to work out what correct behaviour is.
            statedir => '$staterootdir/lib/$packagename',        # ???
            gamesstatedir => '$staterootdir/games/$packagename', # ???
            logdir => '$staterootdir/log',
            lockdir => '$staterootdir/run/lock',
            specificlockdir => '$staterootdir/run/lock/$packagename',
        },

        # An install that just dumps everything in the same directory; useful
        # for home directory installs if there aren't many files being
        # installed. We never autodetect this, and it works better if the
        # application ignores $statedir and instead finds a user-specific
        # place to store its state (dotfiles, etc.). intcmd:optionvalues is
        # special-cased to return all directory options as relative paths
        # when this is used.
        single_directory => {
            autodetect => qr=(?!)=, # more version-portable (*FAIL)
            preferred_installdir => 'bpath:aimake_install',

            configdir => '$installdir',
            staterootdir => '$installdir',
            bindir => '$installdir',
            rootbindir => '$installdir',
            gamesbindir => '$installdir',
            libdir => '$installdir',
            specificlibdir => '$installdir',
            includedir => '$installdir',
            specificincdir => '$installdir',
            datarootdir => '$installdir',
            sourcecodedir => '$installdir',
            datadir => '$datarootdir',
            gamesdatadir => '$datarootdir',
            shortcutdir => '$datarootdir',
            mandir => '$datarootdir',
            infodir => '$datarootdir',
            docdir => '$datarootdir',
            statedir => '$staterootdir',
            gamesstatedir => '$staterootdir',
            logdir => '$staterootdir',
            lockdir => '$staterootdir',
            specificlockdir => '$staterootdir',
        },
    },

    tests => {
        'c11_option' => {
            source_extension => '.c',
            source => <<'EOF',
/* We want to make a best effort to compile C11 on old compilers, so write
   some source which is valid C11 and also valid C89-with-extensions as our
   test (so that we can fall back to C89-with-extensions if no better
   compatibility mode is available).

   For now, we just check anonymous unions. */
struct test1 {
  union { int test2; int *test3; };
};
int main(void) { return 0; }
EOF
            command => ['tool:c_toolchain', 'optstring:-c', 'optpath::',
                        "optpath:-o :bpath:aimake/junk$objext"],
            possibilities => [['optstring:--std=c11'], ['optstring:-std=c11'],
                              ['optstring:--std=gnu99'], []],
        },
        'c99_option' => {
            source_extension => '.c',
            source => <<'EOF',
/* We want to make a best effort to compile C99 on old compilers, so write
   some source which is valid C99 and also valid C89-with-extensions as our
   test (so that we can fall back to C89-with-extensions if no better
   compatibility mode is available).

   We check designated initializers and single-line comments. */
struct c { int a; int b; };
struct c d = {.a = 1, .b = 2};
// test
int main(void) { return 0; }
EOF
            command => ['tool:c_toolchain', 'optstring:-c', 'optpath::',
                        "optpath:-o :bpath:aimake/junk$objext"],
            possibilities => [['optstring:--std=c99'], ['optstring:-std=c99'], []],
        },
        'define_noreturn' => {
            source_extension => '.c',
            source => <<'EOF',
/* Define AIMAKE_NORETURN to an appropriate string for the compiler.

   We could use a second test, which is intended-fail, to ensure that we're
   actually getting noreturn semantics, but there isn't much point; leaving
   out noreturn gives warnings, which is better than failing outright.

   Because we always try all possibilities (including the fallback), we
   want a program that won't warn if the noreturn's missing. */
extern void exit(int);
AIMAKE_NORETURN int foo(void) { exit(0); }
void bar(void) { foo(); }
int main(int argc, char **argv) { if (argc) bar(); return 0; }
EOF
            command => ['tool:c_toolchain', 'optstring:-c', 'optpath::',
                        "optpath:-o :bpath:aimake/junk$objext"],
            possibilities => [
                ['optstring:-DAIMAKE_NORETURN=_Noreturn'],
                ['optstring:-DAIMAKE_NORETURN=__declspec(noreturn)'],
                ['optstring:-DAIMAKE_NORETURN=__attribute__((noreturn))'],
                ['optstring:-DAIMAKE_NORETURN=']],
        },
    },

    libraries => {
        # some likely guesses, not including the system libc
        'm'       => 'sin',             # maths library
        'pthread' => 'pthread_create',  # threading library on UNIX-likes
        'dl'      => 'dlopen',          # used to load plugins on UNIX-likes
        'Ole32'   => 'CoInitialize',    # needed for much Windows functionality
    },

    rules => {
        # Option sets.
        #
        # To simplify things, these have the same names as in autoconf /
        # automake: most are user settings, the equivalents with an AM_ prefix
        # are packager settings (and thus used by flags aimake needs).
        #
        # autoconf / automake have one variable per language, plus CPPFLAGS and
        # LFLAGS. (Note that this is inconsistent with GNU's own recommendations
        # for flags variables - they recommend LDFLAGS - but it's more important
        # to match what they do than what they say, because we're only trying to
        # comply with GNU naming in order to make life easier for users.) We use
        # the same convention here.
        #
        default_cflags => {
            output => 'optionset:CFLAGS',
            outdepends => ['optstring:-g',
                           'optstring:-O2',
                           'optstring:-Wall'],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'CFLAGS',
        },
        default_am_cflags => {
            output => 'optionset:AM_CFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_CFLAGS',
        },
        inclusions_into_cflags => {
            object => 'optionset:CFLAGS',
            # -fno-common enforces that "extern" is added when appropriate,
            # which is important because aimake doesn't work otherwise, and
            # nor do OS X shared libraries.
            depends => ['optionset:AM_CFLAGS', 'optstring:-fno-common'],
            verb => 'determined',
        },

        default_cxxflags => {
            output => 'optionset:CXXFLAGS',
            outdepends => ['optstring:-g',
                           'optstring:-O2',
                           'optstring:-Wall'],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'CXXFLAGS',
        },
        default_am_cxxflags => {
            output => 'optionset:AM_CXXFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_CXXFLAGS',
        },
        cxxflags_includes_am_cxxflags => {
            object => 'optionset:CXXFLAGS',
            depends => 'optionset:AM_CXXFLAGS',
            verb => 'determined',
        },

        default_cppflags => {
            output => 'optionset:CPPFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'CPPFLAGS',
        },
        default_am_cppflags => {
            output => 'optionset:AM_CPPFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_CPPFLAGS',
        },
        inclusions_into_cppflags => {
            object => 'optionset:CPPFLAGS',
            depends => ['optionset:AM_CPPFLAGS',
                        'optpath:-include :bpath:aimake/aimake_1.h',
                        'bpath:aimake/aimake_1.h'],
            verb => 'determined',
        },

        default_lflags => {
            output => 'optionset:LFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'LFLAGS',
        },
        default_am_lflags => {
            output => 'optionset:AM_LFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_LFLAGS',
        },
        lflags_includes_am_lflags => {
            object => 'optionset:LFLAGS',
            depends => 'optionset:AM_LFLAGS',
            verb => 'determined',
        },

        default_yflags => {
            output => 'optionset:YFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'YFLAGS',
        },
        default_am_yflags => {
            output => 'optionset:AM_YFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_YFLAGS',
        },
        yflags_includes_am_yflags => {
            object => 'optionset:YFLAGS',
            depends => 'optionset:AM_YFLAGS',
            verb => 'determined',
        },

        default_lexflags => {
            output => 'optionset:LEXFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'LEXFLAGS',
        },
        default_am_lexflags => {
            output => 'optionset:AM_LEXFLAGS',
            outdepends => [],
            verb => 'determined',
            low_message_priority => 1,
            command_line_override => 'AM_LEXFLAGS',
        },
        lexflags_includes_am_lexflags => {
            object => 'optionset:LEXFLAGS',
            depends => 'optionset:AM_LEXFLAGS',
            verb => 'determined',
        },

        cflags_includes_cppflags => {
            object => 'optionset:CFLAGS',
            depends => 'optionset:CPPFLAGS',
            verb => 'determined',
        },
        cxxflags_includes_iflags => {
            object => 'optionset:CXXFLAGS',
            depends => 'optionset:CPPFLAGS',
            verb => 'determined',
        },

        # For shared libraries to work on 64-bit Linux, we need -fPIC; we may
        # as well just use it unconditionally, because there's hardly any
        # performance penalty on that platform.
        default_linux_fpic_option => {
            output => 'optionset:linux_fpic_option',
            outdepends => [], # sometimes no option is needed
        },
        linux_fpic_option => {
            command => ['intcmd:assert_equal', 'optstring:64',
                        "optstring:$pointerbits"],
            object => 'optionset:linux_fpic_option',
            depends => 'optstring:-fPIC',
            on_failure => 'conditional',
        },
        linux_clflags_depends_on_fpic => {
            object => qr/^optionset:AM_(?:[CL]|CXX)FLAGS$/,
            command => ['intcmd:assert_equal', 'optstring:linux',
                        "optstring:$os_parsed"],
            depends => 'optionset:linux_fpic_option',
            on_failure => 'conditional',
        },

        # Finding relevant files.
        find_source_files => {
            # "optpath::path:" = root of the source directory
            command => ['sys:always_rebuild', 'intcmd:listtree',
                        'optpath::path:'],
            output => qr/(.+)/s,
            verb => 'found',
            information_only => 1,
        },

        fhs_library_directory => {
            # Are we on a UNIX/Linux-like system? If so, there's a bunch of
            # extra library directories we should add, because some linkers
            # (and maybe some compilers?) don't know about /usr/local.
            # (*glares at gold*)
            object => 'optionset:AM_LFLAGS',
            command => ['intcmd:filetest', 'optstring:-d',
                        'optpath::spath:/usr/local/lib'],
            on_failure => 'conditional',
            depends => ['optpath:-L:spath:/usr/local/lib'],
        },

        fhs_include_directory => {
            # Like the above, but for /usr/local/include. Apparently this is
            # sometimes required on Mac OS X.
            object => 'optionset:AM_CPPFLAGS',
            command => ['intcmd:filetest', 'optstring:-d',
                        'optpath::spath:/usr/local/include'],
            on_failure => 'conditional',
            depends => ['optpath:-I:spath:/usr/local/include'],
        },

        # Finding header files is difficult. The problem is that cpp knows the
        # search path, but not even GNU cpp will tell you the search path upon
        # asking. As such, our solution is to preprocess a small test file
        # that includes some headers, and see where those headers are. In
        # order to accomplish this, we need to choose one header on each of
        # the likely search paths. We use the following set of headers:
        #
        # <iso646.h>
        #   Some C compilers provide their own set of headers independent of
        #   the OS's header files. <iso646.h> is a good choice because it's
        #   trivial to write, standard C, completely system-independent, and
        #   not provided by some system libraries (and as such, a compiler
        #   will want to patch around the deficiency). For instance, gcc and
        #   clang both have a copy, glibc doesn't.
        #
        # <limits.h>
        #   Some C compilers try to fix brokenness in the system include
        #   files; this involves making their own private copies elsewhere.
        #   <limits.h> is the only file that's unconditionally fixed by gcc on
        #   every system, so we have to use it. (As a bonus, it also seems to
        #   be unconditionally fixed by clang; its fix is on the same search
        #   path as its iso646.h, but including it makes it include /gcc's/
        #   fixed <limits.h>, if both are installed, thus informing us of a
        #   path the system knows about. And it's also standard C.)
        #
        # <sys/types.h>
        #   Some compilers have a multiple-architecture system, where
        #   different header files are used depending on the target
        #   architecture. As such, we want to find the correct directory for
        #   the architecture. None of the standard C header files are involved
        #   with this system (which means that it doesn't matter for standard
        #   C), so we use a standard POSIX header, <sys/types.h>, which is
        #   obviously highly architecture-dependent. (glibc provides a
        #   multiarch version of sys/types.h, as well as a default version.)
        #
        # <setjmp.h>
        #   We need to find the default system headers themselves. This
        #   involves picking one that won't be involved in multiarch, will be
        #   provided by the libc not the compiler, and won't be fixed by the
        #   compiler's installation. The only standard C header that fulfils
        #   these conditions is <setjmp.h>, probably because it's too weird to
        #   be caught up in any of the other mechanisms.
        #
        # <zlib.h>
        #   Finally, some C installations use a separate path for headers that
        #   are not part of C or POSIX. zlib is chosen because it has an
        #   excellent chance of being installed by such installations (it's
        #   not only commonly used by itself, it's also a dependency of lots
        #   of other things).
        #
        # We use the resulting search paths to find header files that have
        # been specified in a way that omits the directory. This makes
        # programs much more portable, because the directory they expect to
        # find a header in isn't always the directory it's actually in.
        generate_search_test_file => {
            command => [
                'intcmd:writefile', 'optpath::bpath:aimake/aimake_1.c',
                'optstring:' .
                '#ifdef_AIMAKE11 #include_<iso646.h> #endif ' .
                '#ifdef_AIMAKE12 #include_<limits.h> #endif ' .
                '#ifdef_AIMAKE13 #include_<sys/types.h> #endif ' .
                '#ifdef_AIMAKE14 #include_<setjmp.h> #endif ' .
                '#ifdef_AIMAKE15 #include_<zlib.h> #endif ' .
                'int_main(void)_{return_0;}'],
            output => 'bpath:aimake/aimake_1.c',
            verb => 'generated',
            low_message_priority => 1,
        },
        # We rely on the compiler specifying the header file we included as
        # the first dependency that contains its name. This seems pretty
        # likely, really.
        standard_searchpaths => {
            output => 'searchpath:systeminclude',
            outdepends => [],
        },
        locate_compiler_provided_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE11'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\biso646\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\biso646\.h/s,
        },
        locate_compiler_patched_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE12'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\blimits\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\blimits\.h/s,
        },
        locate_multiarch_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE13'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bsys.*?types\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bsys.*?types\.h/s,
        },
        locate_libc_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE14'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bsetjmp\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bsetjmp\.h/s,
        },
        locate_non_libc_include_path => {
            object => 'searchpath:systeminclude',
            command => ['tool:c_dependencies', 'bpath:aimake/aimake_1.c',
                        'optpath::bpath:aimake/aimake_1.c',
                        'optstring:-DAIMAKE15'],
            linesep => ' ', linemax => 1, unescape => 'backslash_whitespace',
            filter => qr/\bzlib\.h\b/s,
            depends => 'optpath::',
            inner => qr/^(.+)\bzlib\.h/s,
        },

        find_headers => {
            object => qr/^searchfile:/s,
            command => ['intcmd:listtree', 'optpath::',
                        'searchpath:systeminclude', 'optstring:2'],
            output => qr/^(.+)$/s,
            verb => 'found',
            low_message_priority => 1,
            information_only => 1,
        },

        # We'd like to find libraries the same way we find headers. (Why not
        # simply ask gcc where the libraries are? It has a command-line option
        # to do that, but the output is incorrect, and only useful for finding
        # libgcc.a in particular, as far as I can tell.) However, unlike with
        # the headers, we have lists of relevant libraries in the options
        # already. So to locate them, we run ld, via the compiler, specifying
        # -Wl,-t (--verbose would produce easier-to-parse output, but isn't
        # portable). This gets the linker to tell us where it found each
        # library. It'll also tell us about the system's libcs, so we don't
        # need to specify those.
        #
        # With GNU ld's and gold's --verbose we can test any number of files
        # at once; if it errors, it keeps going. However, this doesn't work
        # using Darwin ld (which requires -t); it produces no useful output
        # on error. Thus, we run on each library independently. (This is why
        # the searchlib: object type is needed; it can't be done with an
        # optionset because that would not allow looping over the libraries.)
        generate_library_test_object_file => {
            object => 'bpath:aimake/aimake_1.c',
            command => ['tool:c_compiler', 'optpath::', '',
                        "optpath:-o :bpath:aimake/aimake_1$objext"],
            output => "bpath:aimake/aimake_1$objext",
            verb => 'built',
            low_message_priority => 1,
        },
        find_library_symbol_check => {
            # Tell the linker to link in the specified symbol.  (This won't
            # work on a library that has reverse imports, but that's a dubious
            # situation in the first place.)
            object => qr/^searchlib:/,
            command => ['intcmd:echo', 'optpath::'],
            depends => "optstring:-Wl,-u,$symbolprefix",
            dependsarg => qr/^searchlib:[^:]+:symbol:(.*)$/s,
            require_match => 1,
        },
        find_default_static_libraries => {
            # On systems with a static libc, the linker may report only on
            # archive components that are actually linked in.  As such, we
            # have to force the whole thing to be linked, which is kind-of
            # slow, but there's no other real option.  on_failure is at
            # 'parse' for this because a) it assumes the GNU linker (and other
            # linkers will error out on these options; on_failure makes this
            # harmless except if those systems also have a static libc), b)
            # some libcs don't actually link correctly under --whole-archive.
            # Incidentally, this actually crashes mingw ld, but the crash
            # comes after the information we need is already available; it
            # happens during the link proper, rather than during the trace.
            command => ['tool:c_cxx_linker', "bpath:aimake/aimake_1$objext",
                        "optpath::bpath:aimake/aimake_1$objext",
                        "optpath:-o :bpath:aimake/aimake_1$exeext",
                        'optstring:-Wl,-t,--whole-archive,--allow-multiple-definition'],
            # We're looking at the linker's trace output to locate libraries.
            # -t prints each found object file on its own line on stderr. We
            # recognise the object files via the extension, and the fact that
            # they're existing, binary files.
            output => qr/^(?:(?:-l|lib)[^ ]+ )?\(?(.*?\/.*?(?<!aimake_1)(?:\Q$libext\E|\Q$objext\E|\Q$dllext\E)(?:\.[0-9]+)?)(?:\)|\([^\/]*\)|\z)/s,
            output_as_standardlib => 1,
            filter_text_files => 1,
            filter_nonexistent_files => 1,
            force_locale => 'C',
            verb => 'found',
            on_failure => 'parse',
            also_match_stderr => 1,
            # can't require_match; if the library doesn't exist on OS X, we
            # get an error output with no matches, and require_match overrides
            # on_failure (not that it would be useful even if it didn't)
            information_only => 1,
            low_message_priority => 1,
        },
        find_default_dynamic_libraries => {
            # Like the above case, but to find standard libraries on linkers
            # which don't understand --whole-archive.
            command => ['tool:c_cxx_linker', "bpath:aimake/aimake_1$objext",
                        "optpath::bpath:aimake/aimake_1$objext",
                        "optpath:-o :bpath:aimake/aimake_1$exeext",
                        "optstring:-Wl,-t"],
            output => qr/^(?:(?:-l|lib)[^ ]+ )?\(?(.*?\/.*?(?<!aimake_1)(?:\Q$libext\E|\Q$objext\E|\Q$dllext\E)(?:\.[0-9]+)?)(?:\)|\([^\/]*\)|\z)/s,
            output_as_standardlib => 1,
            filter_text_files => 1,
            filter_nonexistent_files => 1,
            force_locale => 'C',
            verb => 'found',
            # Note: on_failure is at its default value, because we want to
            # ensure that the linker works; and require_match is set because
            # if we don't find at least one library, it's probably due to a
            # parse error, and in the pathological case of no libraries we
            # won't be able to find the symbols in libc anyway
            require_match => 1,
            also_match_stderr => 1,
            information_only => 1,
            low_message_priority => 1,
        },
        find_libraries => {
            object => qr/^searchlib:/,
            command => ['tool:c_cxx_linker', "bpath:aimake/aimake_1$objext",
                        "optpath::bpath:aimake/aimake_1$objext",
                        "optpath:-o :bpath:aimake/aimake_1$exeext",
                        'optpath:-l:',
                        'optstring:-Wl,-t'],
            output => qr/^(?:(?:-l|lib)[^ ]+ )?\(?(.*?\/.*?(?<!aimake_1)(?:\Q$libext\E|\Q$objext\E|\Q$dllext\E)(?:\.[0-9]+)?)(?:\)|\([^\/]*\)|\z)/s,
            filter_text_files => 1,
            filter_nonexistent_files => 1,
            force_locale => 'C',
            verb => 'found',
            on_failure => 'empty',
            also_match_stderr => 1,
            information_only => 1,
            low_message_priority => 1,
        },

        # An aimake-specific header file that's forced onto every C file.
        # COPYRIGHT NOTICE: I (Alex Smith) dedicate the files generated
        # by the generate_aimake_header and generate_aimake_get_option rules
        # into the public domain (to allow them to be used with non-GPL
        # programs).
        generate_aimake_header => {
            command => [
                'intcmd:writefile', 'optpath::bpath:aimake/aimake_1.h',
                'optstring:' .
                '#ifndef_AIMAKE\\_HEADER\\_INCLUDED ' .
                '#_define_AIMAKE\\_HEADER\\_INCLUDED ' .
                "#_define_AIMAKE\\_BUILDOS\\_${os_parsed}_1",
                'optionset:aimake_header_lines',
                'optstring: #endif'],
            output => 'bpath:aimake/aimake_1.h',
            verb => 'generated',
            low_message_priority => 1,
        },
        default_aimake_header_lines => {
            output => 'optionset:aimake_header_lines',
            outdepends => [
                'optstring:extern_const_char_*aimake\\_get\\_option' .
                '(const_char_*);'],
        },

        # The implementation of aimake_get_option. This is dropped into
        # the user namespace (i.e. not in aimake/), so that it gets
        # compiled and linked along with everything else.
        all_aimake_options => {
            object => qr/^config_option:/,
            command => ['intcmd:optionvalues', 'optpath::',
                        'optstring:--struct', 'optstring:--optstring-escape'],
            output => 'optionset:all_aimake_options',
            outdepends => 'optstring:__',
            dependsarg => qr/^(.*)$/s,
        },
        generate_aimake_get_option => {
            command => [
                'intcmd:writefile', 'optpath::bpath:_aimake_get_option.c',
                'optstring:#ifdef_AIMAKE\\_BUILDOS\\_MSWin32 '.
                '#_include_<shlobj.h> #endif #include_<string.h> '.
                'static_struct_o_{ __const_char_*name; __const_char_*value; '.
                '__int_csidl; #ifdef_AIMAKE\\_BUILDOS\\_MSWin32 '.
                '__char_working[MAX\\_PATH]; #endif }_options[]_=_{',
                'optionset:all_aimake_options',
                'optstring: __{0,_0,_-1} }; '.
                'const_char_* aimake\\_get\\_option(const_char_*name) { '.
                '__struct_o_*x_=_options; __while(x->name)_{ '.
                '____if_(!strcmp(x->name,_name))_{ '.
                '#ifdef_AIMAKE\\_BUILDOS\\_MSWin32 ______if_(x->csidl_!=_-1)_{ '.
                '________SHGetFolderPathA(0,_x->csidl,_0,_0,_x->working); '.
                '________strncat(x->working,_"\\\\\\\",_MAX\\_PATH_-_1); '.
                '________strncat(x->working,_x->value,_MAX\\_PATH_-_1); '.
                '________return_x->working; ______} #endif '.
                '______return_x->value; ____} ____x++; __} __return_0; }'],
            output_from_optpath => '',
            verb => 'generated',
        },

        # Compiling C and C++.
        c_toolchain => {
            output => 'tool:c_toolchain',
            outdepends => 'cmd:gcc',
            verb => 'found',
            command_line_override => 'CC',
        },
        cxx_toolchain => {
            output => 'tool:cxx_toolchain',
            outdepends => 'cmd:g++',
            verb => 'found',
            command_line_override => 'CXX',
        },
        c_compiler_tool => {
            output => 'tool:c_compiler',
            outdepends => ['tool:c_toolchain', 'optionset:CFLAGS', 'optstring:-c'],
            verb => 'found',
        },
        cxx_compiler_tool => {
            output => 'tool:cxx_compiler',
            outdepends => ['tool:cxx_toolchain', 'optionset:CXXFLAGS', 'optstring:-c'],
            verb => 'found',
        },
        c_cxx_dependencies_tool => {
            output => 'tool:c_dependencies',
            outdepends => ['tool:c_toolchain', 'optstring:-M -MG',
                           'optionset:CPPFLAGS'],
            verb => 'found',
        },
        c_cxx_preprocess_tool => {
            output => 'tool:c_preprocessor',
            outdepends => ['tool:c_toolchain', 'optstring:-E',
                           'optionset:CPPFLAGS'],
            verb => 'found',
            command_line_override => 'CPP',
        },

        # We copy all the files from the path into the bpath, in isolation
        # directories. This serves six purposes:
        #
        # - When finding dependencies of .c/.h files, it can cause
        #   unresolvable dependency issues if the compiler can look at any
        #   file other than the one we're trying to find dependencies of (and
        #   system headers, which we don't really care about). The rules for
        #   finding dependencies would have to look at their own output to
        #   know when to re-run; this is dubious in its own right, and there's
        #   no point in implementing support for it in aimake because even
        #   that method fails when generated files are involved (as automake
        #   discovered).
        #
        #   Instead, we make sure that a #include "file.h" will never find the
        #   file it's looking for. We do this via ensuring that the file is in
        #   a directory all to itself.
        #
        # - When finding dependencies of .c/.h files, it's important to avoid
        #   the use of precompiled headers; we don't know which files will be
        #   depended on until we try, and depending on an out-of-date header
        #   would be a really bad idea. Using isolation directories means that
        #   a precompiled header won't be found unless we want it to be.
        #
        # - gcc requires precompiled headers to be in a directory which
        #   appears no later in search path order than the header they're
        #   precompiled from. Placing them in the same directory is the
        #   easiest way to accomplish this, which requires headers to be in
        #   the bpath in order to be able to write to its directory.
        #
        # - When two files have the same basename (e.g. foo.c, foo.cxx), it
        #   avoids filename clashes for files derived from them (e.g. foo.o)
        #   via ensuring the resulting files are in different directories.
        #
        # - It enables aimake to restrict the compiler to look at only the
        #   headers that aimake wants it to, thus preventing accidental use of
        #   a header file other than the one aimake is expecting. Compilers
        #   can't typically be told which headers to look at, just which
        #   directory to look for headers in.
        #
        # - It lets us completely ignore files with unexpected extensions.
        #   (The project-specific config file can isolate them or process them
        #   directly, as it wishes.) Normally, this wouldn't be a problem
        #   anyway, but it could be if there are things like object files
        #   sitting around in the source directory.
        #
        # I recently discovered a secret seventh purpose: when you
        # accidentally tell your VCS to revert rather than commit your work,
        # you can recover it from the isolation directory. I don't think this
        # should count as aimake's job, but it's nonetheless a useful
        # safeguard.
        isolate_file => {
            object => qr/^path:.*\.(?:c|h|cxx|l|y)$/s,
            command => ['intcmd:writefile',
                        'optpath::extend:/:',
                        'optpath:-q#line 1 :',
                        'optpath:-c:'],
            output_from_optpath => '',
            low_message_priority => 1,
            object_dependency => 'nowhere',
        },

        # Preprocessors fall back to system includes if they can't find a local
        # include for a #include "file.h" line. This is a problem when we want
        # to find dependencies, if a system and local header have the same name.
        # The solution is to create a directory of header stubs that will be
        # found with higher priority.
        headerstub_dependencies => {
            object => qr/^bpath:(?!aimake).*\.[ch](?:xx)?$/s,
            command => ['intcmd:cat', 'optpath::'],
            actions => [
                {
                    depends => 'dependencies:headerstub_created:',
                    inner => qr/^\s*#\s*include\s*"((?:[^"]|\\.)+)"/,
                },
                {
                    output => 'dependencies:find_headerstubs:',
                    outdepends => [],
                    inner => qr/^\s*#\s*include\s*"((?:[^"]|\\.)+)"/,
                }
            ],
            unescape => 'backslash',
            low_message_priority => 1,
            object_dependency => 'nowhere',
        },
        headerstub_name => {
            object => qr/^dependencies:find_headerstubs:/,
            command => ['intcmd:echo', 'optpath:-i:'],
            depends => 'optpath::bpath:aimake/stubs/',
            dependsarg => qr/^file:(.*)/s,
            require_match => 1,
        },
        create_headerstubs => {
            object => qr/^dependencies:find_headerstubs:/,
            command => ['intcmd:writefile', 'optstring:/*_stub_*/', ''],
            output_from_optpath => '',
            low_message_priority => 1,
        },

        # A dependency on a stub creates a dependency on the file name of that
        # stub. To preserve the C-defined behaviour that #include "file" falls
        # back to #include <file>, we also create a searchfile: dependency.
        handle_headerstub_creation => {
            object => qr=^bpath:aimake/stubs/=,
            command => ['intcmd:echo', 'optpath:-w:'],
            actions => [
                {
                    depends => 'file:',
                    dependsarg => qr=^bpath:aimake/stubs/(.*)=s,
                },
                {
                    output => ['searchfile:',
                               'dependencies:headerstub_created:file:'],
                    outputarg => qr=^bpath:aimake/stubs/(.*)=s,
                    outdepends => [],
                }
            ],
            object_dependency => 'nowhere',
        },

        ch_file_dependencies => {
            object => qr/^bpath:(?!aimake).*\.[ch](?:xx)?$/s,
            # We want this dependency rule to respect the dependencies from
            # headerstub_dependencies, so we add that manually (by default,
            # dependency rules don't respect each other).
            command => ['tool:c_dependencies', 'optpath::',
                        'dependencies:headerstub_dependencies:',
                        'optpath:-iquote :bpath:aimake/stubs'],
            # A little aimake magic here: this outputs relative paths for
            # non-found files, and those become file: objects, whereas
            # absolute paths for files it did find will become the appropriate
            # sort of object (most likely path: or spath:).
            linesep => ' ',
            lineskip => 2, # output file, input file
            unescape => 'backslash_whitespace',
            actions => [
                {
                    depends => qr/^(.+)$/s,
                    filter_spath => 1,
                },
                {
                    output => qr/^(.+)$/s,
                    outdepends => [],
                    filter_absolute => 1,
                    output_as_searchfile => 1,
                },
            ],
            object_dependency => 'nowhere',
        },
        # We can't just put config options in aimake_1.h, like we do for the
        # other aimake defines, because we need dependencies on them from the
        # config options.
        header_files_are_files => {
            object => qr/^[bs]path:(?!aimake).*\.h(?:xx)?/,
            command => ['intcmd:echo', 'optpath::'],
            output => 'file:',
            outputarg => qr/^[bs]path:
              (?:(?:[^\\]|\\.)+\/)?((?:[^\\\/]|\\.)+?)$/x,
            outdepends => 'optpath:-I :extend:..:',
            object_dependency => 'outdepends',
        },
        compile_c => {
            object => qr/^bpath:(?!aimake).*\.c$/s,
            command => ['tool:c_compiler', 'optpath::',
                        "optpath:-o :extend:$objext:"],
            output => "extend:$objext:",
            verb => 'compiled',
            in_subdir => 'bpath:', # shorter error/warning messages
            # Make sure we depend on the precompiled header, rather than using
            # the dummy rule with no dependencies. (If we used the dummy rule,
            # it's possible we could compile with an out-of-date precompiled
            # header.)
            avoid_rules => qr/^no_precompiled_header_recursion$/,
        },
        compile_cxx => {
            object => qr/^bpath:(?!aimake).*\.cxx$/s,
            command => ['tool:cxx_compiler', 'optpath::',
                        "optpath:-o :extend:$objext:"],
            output => "extend:$objext:",
            verb => 'compiled',
            in_subdir => 'bpath:',
            avoid_rules => qr/^no_precompiled_header_recursion$/,
        },

        # We can precompile headers; clang and gcc fortunately both use the
        # same syntax for this. gcc will only use one precompiled header per
        # compilation, but that's OK. We need to make sure the headers depend
        # on their precompiled version, to prevent the precompiled headers
        # getting out of date.
        c_precompile_tool => {
            output => 'tool:c_precompile',
            outdepends => ['tool:c_toolchain', 'optionset:CFLAGS'],
            verb => 'found',
        },
        precompile_headers => {
            object => qr/^bpath:(?!aimake).*\.h$/s,
            command => ['tool:c_precompile', 'optpath::',
                        'optionset:os_linux',
                        'optpath:-o :extend:.h.gch:'],
            verb => 'precompiled',
            # Precompiling headers never uses precompiled headers itself,
            # so this is safe (also necessary to avoid dependency loops).
            avoid_rules => qr/^headers_depend_on_precompiled_headers$/,
            output_from_optpath => '-o ',
            low_message_priority => 1,
        },
        # We use one of the following two dependencies for each header,
        # depending on which rule cares about them.
        no_precompiled_header_recursion => {
            object => qr/^bpath:(?!aimake).*\.h$/s,
            output => 'dependencies:precompiled_header:',
            outdepends => [],
            object_dependency => 'nowhere',
        },
        headers_depend_on_precompiled_headers => {
            object => qr/^bpath:(?!aimake).*\.h$/s,
            output => 'dependencies:precompiled_header:',
            outdepends => 'extend:.h.gch:',
            object_dependency => 'nowhere',
        },
        add_precompiled_header_dependencies => {
            object => qr/^bpath:(?!aimake).*\.h$/s,
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$os_parsed"],
            depends => 'dependencies:precompiled_header:',
            on_failure => 'conditional',
        },

        # OS detection
        #
        # Necessary to link shared libraries correctly.

        os_detect_linux => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$os_parsed"],
            hide_errors => 1,
            output => ['optionset:os_linux', 'optionset:os_posix'],
            outdepends => [],
        },
        os_detect_windows => {
            command => ['intcmd:assert_equal',
                        'optstring:MSWin32', "optstring:$os_parsed"],
            hide_errors => 1,
            output => 'optionset:os_windows',
            outdepends => [],
        },
        os_detect_osx => {
            command => ['intcmd:assert_equal',
                        'optstring:darwin', "optstring:$os_parsed"],
            hide_errors => 1,
            output => ['optionset:os_osx', 'optionset:os_posix'],
            outdepends => [],
        },
        os_detect_freebsd=> {
            command => ['intcmd:assert_equal',
                        'optstring:freebsd', "optstring:$os_parsed"],
            hide_errors => 1,
            output => ['optionset:os_freebsd', 'optionset:os_posix'],
            outdepends => [],
        },

        # Shared objects.
        #
        # We detect that a library is wanted using flags in the source code:
        #
        # AIMAKE_EXPORT  This symbol is in a library and should be exported.
        # AIMAKE_IMPORT  This symbol should be imported from a library.
        # AIMAKE_REVERSE_EXPORT  This symbol should be made available to
        #                        libraries that use this code.
        # AIMAKE_REVERSE_IMPORT  This symbol should be imported from users of
        #                        this library into the library itself.
        #
        # Both _EXPORTs become __attribute__((visibility("default"))) on
        # Linux, and __declspec(dllexport) on Windows. The _IMPORTs are no-ops
        # on Linux, and become __declspec(dllimport) on Windows. Mac OS X
        # apparently works the same way as Linux in this respect (it supports
        # "hidden" and "default" visibility the same way Linux does).
        #
        # The syntax in the source file is AIMAKE_EXPORT(symbol), etc.. The
        # reason for this is so that we can identify symbol names that need
        # exporting using the preprocessor (using token pasting and
        # $longrandomstring). Once we find these, we create a symbolset for
        # each based on the stem of the namehints of the symbol. (That way, we
        # don't end up creating duplicate libraries.)

        c_embedded_aimake_export => {
            object => qr/^bpath:(?!aimake).*\.c(?:xx)?$/s,
            command => ['tool:c_preprocessor', 'optpath::', 'optstring:-P',
                        "optstring:-DAIMAKE_OVERRIDE_DEFINES",
                        "optstring:-DAIMAKE_EXPORT(x)=${longrandomstring}##x[]",
                        "optstring:-DAIMAKE_ABI_VERSION(x)=${longrandomstring}[x]",],
            output => 'shared_symbol:',
            outputarg => qr/${longrandomstring}(\w+)/,
            # We want the name of the library to be based on the name of the
            # source files and headers that exported the symbol. (A previous
            # version of this code based it on the object files that were
            # dependencies of the symbol, but that caused problems with
            # transitive dependencies.) An AIMAKE_ABI_VERSION argument gives
            # us hints about what version number to use, if present. If not,
            # we produce unversioned namehints, because this regexp matches
            # AIMAKE_EXPORTs as well.
            outdepends => 'namehint:',
            dependsarg => qr/${longrandomstring}\w*\s*\[([^][]*)\]/,
            verb => 'found',
            # Precompiled headers for this won't be used because we're
            # defining extra macros; therefore, depending on them is
            # pointless.
            avoid_rules => qr/^headers_depend_on_precompiled_headers$/,
        },
        c_embedded_aimake_reverse_import => {
            # Reverse imports shouldn't count as dependencies for the purpose
            # of creating an import library, or for linking shared libraries
            # on Linux. They should count for the purpose of linking DLLs on
            # Windows, and for creating executables on any platform. Thus, we
            # null-provide them here, and avoid this rule in any rule that
            # should link them "properly".
            object => qr/^bpath:(?!aimake).*\.c(?:xx)?$/s,
            command => ['tool:c_preprocessor', 'optpath::', 'optstring:-P',
                        "optstring:-DAIMAKE_OVERRIDE_DEFINES",
                        "optstring:-DAIMAKE_REVERSE_IMPORT(x)=${longrandomstring}##x"],
            output => ['symbol:', 'symbol:__imp_'],
            outputarg => qr/${longrandomstring}(\w+)/,
            outdepends => [],
            preference => 100,
            avoid_rules => qr/^headers_depend_on_precompiled_headers$/,
        },
        create_symbolset => {
            object => qr/^shared_symbol:/,
            command => ['intcmd:xuse_statistics', "optstring:-s$objext\$"],
            output => 'symbolset:',
            outputarg => qr/^version=(.*)$/,
            inner => qr/^stem=(.+)$/,
            outdepends => 'direct_symbol:',
            dependsarg => qr/^dependency=shared_symbol:(.*)$/,
            verb => 'named',
        },

        link_shared_library_linux => {
            object => qr/^symbolset:/,
            command => ['tool:c_cxx_linker', 'optstring:-shared',
                        'dependencies:symbolset_soname_linux:',
                        'dependencies:symbolset_output_linux:'],
            output_from_optpath => '-o ',
            in_subdir => 'bpath:',
            verb => 'linked',
            avoid_rules => qr/^(?:linux_library_finding_link |
                                  library_option_for_import_libs)$/x,
        },
        link_shared_library_windows => {
            object => qr/^symbolset:/,
            command => ['tool:c_cxx_linker', 'optstring:-shared',
                        "optpath:-o :extend:$dllext:",
                        'optionset:os_windows'],
            output_from_optpath => '-o ',
            in_subdir => 'bpath:',
            verb => 'linked',
            avoid_rules => qr/^(?:library_option_for_import_libs |
                                  c_embedded_aimake_reverse_import)$/x,
            avoid_built_from => "extend:$impext:",
        },

        posix_cflags => {
            command => ['intcmd:nop', 'optionset:os_posix'],
            output => ['optionset:AM_CFLAGS', 'optionset:AM_CXXFLAGS'],
            outdepends => 'optstring:-fvisibility=hidden',
        },
        posix_lflags => {
            command => ['intcmd:nop', 'optionset:os_posix'],
            output => 'optionset:AM_LFLAGS',
            outdepends => 'optstring:-rdynamic',
        },
        posix_headerlines => {
            command => ['intcmd:nop', 'optionset:os_posix'],
            output => 'optionset:aimake_header_lines',
            outdepends => 'optstring:' .
                '#_ifndef_AIMAKE\\_OVERRIDE\\_DEFINES ' .
                '#__define_AIMAKE\\_ABI\\_VERSION(x) ' .
                '#__define_AIMAKE\\_IMPORT(x)_x ' .
                '#__define_AIMAKE\\_REVERSE\\_IMPORT(x)_x ' .
                '#__define_AIMAKE\\_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x '.
                '#__define_AIMAKE\\_REVERSE\\_EXPORT(x)_\\_\\_attribute\\_\\_(('.
                'visibility("default")))_x ' .
                '#_endif'
        },
        symbolset_soname_and_output_linux => {
            object => qr/^symbolset:/,
            command => ['intcmd:echo', 'optionset:os_linux', 'optpath::'],
            object_dependency => 'nowhere',
            actions => [
                {
                    output => 'dependencies:symbolset_soname_linux:',
                    outdepends => "optpath:-Wl,-soname,:extend:...:extend:$dllext",
                    dependsarg => qr/^symbolset:(\.?[^.:]*)/s,
                },
                {
                    output =>  'dependencies:symbolset_output_linux:',
                    outdepends => "optpath:-o :extend:$dllext",
                    dependsarg => qr/^symbolset:([^:]*)/s,
                }
            ],
        },

        windows_headerlines => {
            command => ['intcmd:nop', 'optionset:os_windows'],
            output => 'optionset:aimake_header_lines',
            outdepends => 'optstring:' .
                '#_ifndef_AIMAKE\\_OVERRIDE\\_DEFINES ' .
                '#__define_AIMAKE\\_ABI\\_VERSION(x) ' .
                '#__define_AIMAKE\\_IMPORT(x)_\\_\\_declspec(dllimport)_x ' .
                '#__define_AIMAKE\\_REVERSE\\_IMPORT(x)_' .
                '\\_\\_declspec(dllimport)_x ' .
                '#__define_AIMAKE\\_EXPORT(x)_\\_\\_declspec(dllexport)_x ' .
                '#__define_AIMAKE\\_REVERSE\\_EXPORT(x)_' .
                '\\_\\_declspec(dllexport)_x ' .
                '#_endif'
        },
        windows_generate_import_library => {
            # Windows won't create a shared library if it has missing
            # dependencies, which causes problems in the case of reverse
            # imports. However, this is fixable via creating an import library
            # manually, rather than telling the linker to do it, and from the
            # object files rather than the resulting DLL; the missing
            # reverse-exported symbols won't matter when creating the import
            # library, and there are no longer any circular dependencies.
            object => qr/^symbolset:/,
            command => ['cmd:dlltool', 'optionset:os_windows',
                        "optpath:-l :extend:$impext:",
                        "optpath:-D :extend:...:extend:$dllext:"],
            output_from_optpath => ['-l '],
            in_subdir => 'bpath:',
            verb => 'generated',
            avoid_rules => qr/^library_option_for_linking$/,
        },

        # The setup for versioned shared libraries on Debian/Ubuntu, also used
        # by aimake for Linux, places the library at libXXX.so.1.2.3, then
        # places a symlink from its soname (libXXX.so.1) so that ld.so can
        # find it, and a symlink from its unadorned name (libXXX.so) so that
        # ld can find it.
        linux_ld_so_finding_link => {
            object => qr/^bpath:(?!aimake).*\Q$dllext\E\.[\d]*\.[\d.]*\z/s,
            command => ['intcmd:echo', 'optionset:os_linux', 'optpath::'],
            output => 'dependencies:linux_library_finding_link:',
            outdepends => "optpath:-o:",
            object_dependency => 'nowhere',
            dependsarg => qr/^(.*\Q$dllext\E\.?[^.]*)[\d.]*$/s,
            avoid_rules => qr/^linux_library_finding_link$/,
        },
        linux_ld_finding_link => {
            object => qr/^bpath:(?!aimake).*\Q$dllext\E\.[\d.]*\z/s,
            command => ['intcmd:echo', 'optionset:os_linux', 'optpath::'],
            output => 'dependencies:linux_library_finding_link:',
            outdepends => "optpath:-o:",
            object_dependency => 'nowhere',
            dependsarg => qr/^(.*\Q$dllext\E)[\d.]*$/s,
            avoid_rules => qr/^linux_library_finding_link$/,
        },
        linux_library_finding_link => {
            object => qr/^bpath:(?!aimake).*\Q$dllext\E\.[\d.]*\z/s,
            command => ['dependencies:linux_library_finding_link:',
                        'optpath::', 'intcmd:symlink'],
            output_from_optpath => '-o',
            object_dependency => 'nowhere',
            verb => 'symlinked',
            avoid_rules => qr/^linux_library_finding_link$/,
        },

        # Selecting sensible names.
        #
        # This is used for executables (the names of shared objects are based
        # on the names of the filenames which declare the objects they
        # export). When selecting a sensible name for an executable, we base
        # it on the bpath objects that contain initialized read/write data, as
        # a crude heuristic to distinguish programs from library functions.
        # (Library functions rarely work on a single, centralized copy of data
        # because that causes a lack of re-entrancy. Read-only data doesn't
        # count for this purpose; and uninitialized data is possibly a static
        # buffer, which is a much more common way to lack re-entrancy than
        # initialized data.) Additionally, a symbol "main" or "_main"
        # automatically gets your name hinted, and exported symbols get their
        # names hinted when creating shared libraries.
        # choose_namehint => {
        #     object => qr/^bpath:(?!aimake).*\Q$objext\E$/,
        #     depends => 'namehint:',
        #     command => ['cmd:nm', 'optpath::'],
        #     # In order to conditionally include the namehint, we use a regex
        #     # match that captures nothing. If it doesn't match, there'll be no
        #     # capture and thus no hint. (The hint itself is provided by the
        #     # implicit inner => ''.)
        #     dependsarg => qr'^()[[:xdigit:]]*\s+(?:[tT] _?main|[dDgG])',
        #     verb => 'chose',
        # },

        # Linking. aimake can only support one linker at a time, so by default,
        # we use a C++ linker, as that works for C too. If no C++ linker is
        # supported, it's perfectly fine to use a C linker instead.
        c_cxx_link_tool => {
            output => 'tool:c_cxx_linker',
            outdepends => ['tool:cxx_toolchain', 'optionset:LFLAGS'],
            verb => 'found',
        },
        object_dependencies => {
            # Note that this only matches the path/bpath, not the spath.
            object => qr/^bpath:(?!aimake).*(?:\Q$objext\E|\Q$libext\E|\Q$dllext\E)$/,
            command => ['cmd:nm', 'optpath::'],
            depends => 'symbol:',
            # To make things work on Windows, omit symbols that start with a
            # double underscore, apart from DLL import hooks (__imp_.*).
            # To make C++ work, omit anything ending "_type_infoE".
            # To make things work on 64-bit Linux, omit _GLOBAL_OFFSET_TABLE_.
            dependsarg => qr'^[[:xdigit:]]*\s+U ((?>_?(?!GLOBAL_OFFSET_TABLE)(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*+(?<!_type_infoE)))',
        },
        o_file_provisions => {
            object => qr/^bpath:(?!aimake).*\Q$objext\E\z/,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'direct_symbol:', 'symbol_in_object:'],
            # [ABCDGRSTVWiI] are all the externally visible symbols.
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            # inner => '' is implied, as with the next few rules
            # outdepends => '' is implied by object_dependency
            outdepends => 'optpath::',
            verb => 'found',
            object_dependency => 'outdepends',
            preference => 80,
        },
        a_file_provisions => {
            object => qr/^(?:spath|standardlib):.*\Q$libext\E\z/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            ignore_warnings => 1,
            outdepends => [],
            verb => 'found',
            object_dependency => 'outdepends',
            low_message_priority => 1,
            preference => 30,
        },
        shared_object_provisions_nondynamic => {
            object => qr/^(spath|standardlib):.*\Q$dllext\E(?:\z|\.)[\d.]*\z/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            ignore_warnings => 1,
            object_dependency => 'outdepends',
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 50,
        },
        shared_object_provisions_dynamic => {
            object => qr/^(spath|standardlib):.*\Q$dllext\E(?:\z|\.)[\d.]*\z/s,
            command => ['cmd:nm','optstring:-D','optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            hide_errors => 1, # not everything is dynamic
            ignore_warnings => 1,
            object_dependency => 'outdepends',
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 50,
        },
        bpath_shared_object_provisions_nondynamic => {
            # For Windows, we need to find the provisions of the import library
            # (.dll.a).  On other platforms, $impext is $dllext, so this matches
            # the shared object as required.
            object => qr/^bpath:(?!aimake).*\Q$impext\E(?:\z|\.)[\d.]*\z/s,
            command => ['cmd:nm', 'optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            ignore_warnings => 1,
            object_dependency => 'outdepends',
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 90,
            avoid_rules => qr/^linux_library_finding_link$/,
        },
        bpath_shared_object_provisions_dynamic => {
            object => qr/^bpath:(?!aimake).*\Q$impext\E(?:\z|\.)[\d.]*\z/s,
            command => ['cmd:nm','optstring:-D','optpath::'],
            output => ['symbol:', 'symbol_in_object:'],
            outputarg => qr'^[[:xdigit:]]*\s+[ABCDGRSTVWiI] ((?>_?(?:_imp_+)?[a-zA-Z0-9\$][a-zA-Z0-9_\$]*))',
            hide_errors => 1, # not everything is dynamic
            ignore_warnings => 1,
            object_dependency => 'outdepends',
            outdepends => [],
            verb => 'found',
            low_message_priority => 1,
            preference => 90,
            avoid_rules => qr/^linux_library_finding_link$/,
        },

        # Note: no standardlib_library_option, that's the whole reason that
        # standardlib: exists
        spath_library_option => {
            object => qr/^spath:.*(?:\Q$dllext\E|\Q$libext\E)(?:\z|\.)[\d.]*\z/s,
            depends => 'dependencies:library_option:',
        },
        bpath_library_option => {
            # If we generated the library ourself, we need to link against the
            # import library, not the library proper (unless the library is its
            # own import library, as on Linux).  Also set an appropriate runtime
            # path for the platform.
            object => qr/^bpath:(?!aimake).*\Q$impext\E(?:\z|\.)[\d.]*\z/s,
            depends => ['dependencies:library_option:',
                        'optionset:rpath'],
        },
        library_option_for_linking => {
            object => qr/^(?:spath:.*(?:\Q$dllext\E|\Q$libext\E)(?:\z|\.)[\d.]*\z |
                             bpath:(?!aimake).*\Q$impext\E(?:\z|\.)[\d.]*\z)/sx,
            object_dependency => 'nowhere',
            output => 'dependencies:library_option:',
            # The obvious thing to do here is to try to construct an -l option
            # from the name on the spath, but this can fail on Linux because a
            # library's soname doesn't necessarily have to correlate with the
            # unadorned version of the filename that's used for linking
            # it. What we'd ideally have to do would be to realpath the
            # spath library, then look for symlinks to it and pick the most
            # unadorned one. Rather than that complexity, we just specify the
            # path directly, the same way as is done for bpath libraries; it
            # comes to the same thing anyway, except that it doesn't give the
            # linker the chance to override the .a/.so choice that aimake made
            # (and thus confuse it by linking to a library with different
            # symbols, in the case where the two aren't identical).
            outdepends => 'optpath: :',
        },
        library_option_for_import_libs => {
            object => qr/^(?:spath:.*(?:\Q$dllext\E|\Q$libext\E)(?:\z|\.)[\d.]*\z |
                             bpath:(?!aimake).*\Q$impext\E(?:\z|\.)[\d.]*\z)/sx,
            object_dependency => 'nowhere',
            output => 'dependencies:library_option:',
            outdepends => [],
        },

        linux_rpath => {
            # We set the rpath to the installed location for the shared
            # objects. We can't know if it'll be libdir or specificlibdir,
            # so we do both.
            #
            # Exception: we ignore /lib and /usr/lib, because ld.so(8)
            # checks those unconditionally, and according to lintian,
            # it can screw things up sometimes.
            output => 'optionset:linux_rpath',
            command => ['intcmd:optionvalues',
                        'config_option:libdir',
                        'config_option:specificlibdir',
                        'optpath::config_option:libdir',
                        'optpath::config_option:specificlibdir'],
            outdepends => 'optpath:-Wl,-rpath=:',
            inner => qr{^(?:specific)?libdir=((?!/lib$)(?!/usr/lib$).*)$},
        },
        linux_bpath_library_option => {
            command => ['intcmd:assert_equal',
                        'optstring:linux', "optstring:$os_parsed"],
            hide_errors => 1,
            output => 'optionset:rpath',
            outdepends => 'optionset:linux_rpath',
        },

        windows_rpath => {
            # TODO: Figure out how runtime paths work on Windows.
            command => ['intcmd:assert_equal',
                        'optstring:MSWin32', "optstring:$os_parsed"],
            hide_errors => 1,
            output => 'optionset:rpath',
            outdepends => [],
        },

        link_c => {
            object => qr/^bpath:(?!aimake).*\Q$objext\E/,
            command => ['symbol_in_object:main:', 'tool:c_cxx_linker',
                        'optpath::', "optpath:-o :extend:$exeext:"],
            output => "extend:$exeext:",
            verb => 'linked',
            in_subdir => 'bpath:',
            avoid_rules => qr/^(?:library_option_for_import_libs |
                                  c_embedded_aimake_reverse_import)$/x,
        },
        # Some compilers add an extra underscore to everything. No problem,
        # we'll just link files with a _main too. (This causes issues if a
        # file has both a _main and a main, but in such a case, we're in
        # trouble anyway.)
        link_mangled_c => {
            object => qr/^bpath:(?!aimake).*\Q$objext\E/,
            command => ['symbol_in_object:_main:', 'tool:c_cxx_linker',
                        'optpath::', "optpath:-o :extend:$exeext:"],
            output => "extend:$exeext:",
            verb => 'linked',
            in_subdir => 'bpath:',
            avoid_rules => qr/^(?:library_option_for_import_libs |
                                  c_embedded_aimake_reverse_import)$/x,
        },

        # lex, yacc
        # For the time being we only support the GNU flex/bison, due to
        # traditional lex's nasty habit of using hardcoded filenames.
        lex_tool => {
            output => 'tool:lex',
            outdepends => ['cmd:flex', 'optionset:LEXFLAGS'],
            verb => 'found',
        },
        compile_lex => {
            object => qr/^bpath:(?!aimake).*\.l$/,
            # Note the use of -o (with no space) here; GnuWin32 flex does not
            # support the --outfile= syntax, so that's the most portable
            # option.
            command => ['tool:lex', 'optpath::', 'optpath:-o:extend:.c:'],
            output => 'extend:.c:',
            verb => 'generated',
        },

        yacc_tool => {
            output => 'tool:yacc',
            outdepends => ['cmd:bison', 'optionset:YFLAGS'],
            verb => 'found',
        },
        compile_yacc => {
            object => qr/^bpath:(?!aimake).*\.y$/s,
            command => ['tool:yacc', 'optpath::', 'optpath:-o :extend:.c:',
                        'optpath:--defines=:extend:.h:'],
            output => ['extend:.c:', 'extend:.h:'],
            verb => 'generated',
        },

        # Manuals. In order to get portable documentation in aimake, you write
        # the documentation as a POD file formatted like a UNIX manual (so
        # that we can output this in the manual on UNIX). On UNIXy systems, we
        # convert to a man page ourself. Otherwise, we convert to HTML.
        format_manual => {
            object => qr/^b?path:(?!aimake).*\.pod$/,
            command => ['intcmd:podformat', 'optpath::'],
            output => qr/(.*)/s,
            verb => 'formatted',
        },

        # Installing. Some projects may wish to modify or undef out these rules.
        install_libraries => {
            object => qr/^bpath:(?!aimake).*\Q$dllext\E(?:\z|\.)[\d.]*\z$/s,
            install_dir => "libdir",
        },
        install_executables => {
            object => qr/^bpath:(?!aimake).*\Q$exeext\E$/s,
            install_dir => "bindir",
        },
        install_manuals => {
            object => qr/^bpath:(?!aimake).*\.[1-9][a-z]*(?:\.html)?/s,
            install_dir => "mandir",
        },
        install_eula => {
            object => 'bpath:aimake/license.rtf',
            install_dir => "docdir",
        },
        install_docs_link => {
            command => ['intcmd:nop', 'optionset:os_windows'],
            object => 'sys:touch_only',
            install_dir => "docdir",
            link_to_directory => 'documentation',
        },
        install_source => {
            object => qr/^path:/,
            install_dir => "sourcecodedir",
            install_feature => "sourcecode",
            copy_structure => 1,
            low_message_priority => 1,
        },
        install_source_link => {
            object => 'sys:touch_only',
            install_dir => "sourcecodedir",
            install_feature => "sourcecode",
            link_to_directory => 'source',
        },
    },

}
