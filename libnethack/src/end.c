/* vim:set cin ft=c sw=4 sts=4 ts=8 et ai cino=Ls\:0t0(0 : -*- mode:c;fill-column:80;tab-width:8;c-basic-offset:4;indent-tabs-mode:nil;c-file-style:"k&r" -*-*/
/* Last modified by Fredrik Ljungdahl, 2018-04-01 */
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* NetHack may be freely redistributed.  See license for details. */

#include "hack.h"
#include "dlb.h"

#include <math.h>

#ifndef AIMAKE_BUILDOS_MSWin32
/* For nonfatal_dump_core() */
# include <unistd.h>
#endif

        /* these probably ought to be generated by makedefs, like LAST_GEM */
#define FIRST_GEM    DILITHIUM_CRYSTAL
#define FIRST_AMULET AMULET_OF_ESP
#define LAST_AMULET  AMULET_OF_YENDOR

struct valuable_data {
    long count;
    int typ;
};

static struct valuable_data
              gems[LAST_GEM + 1 - FIRST_GEM + 1],       /* 1 extra for glass */
              amulets[LAST_AMULET + 1 - FIRST_AMULET];

static const struct val_list {
    struct valuable_data *list;
    int size;
} valuables[] = {
    {gems, sizeof gems / sizeof *gems},
    {amulets, sizeof amulets / sizeof *amulets},
    {0, 0}
};

static const char *add_killer_notes(int how, boolean carried,
                                    const char *killer);
static char **delayed_killer_var(int how);
static void disclose(int, boolean, long);
static void dump_disclose(int);
static void get_valuables(struct obj *);
static void sort_valuables(struct valuable_data *, int);
static int artifact_score(struct obj *, boolean, struct nh_menulist *);
static void savelife(int);
static boolean check_survival(int how);
static boolean should_query_disclose_options(char *defquery);

#define done_stopprint program_state.stopprint

/*
 * The order of these needs to match the macros in hack.h.
 */

static const char *const ends[] = {     /* "when you..." */
    "died", "choked", "were poisoned", "starved", "drowned", "suffocated",
    "burned", "dissolved", "were crushed", "turned to stone",
    "turned into slime", "exploded", "were wiped out", "turned into a zombie",
    "were tricked", "quit", "escaped", "ascended"
};

static const char *const killer_verb[] = {
    "killed", "choked", "poisoned", "died", "drowned", "died", "burned",
    "dissolved", "crushed to death", "petrified", "turned to slime",
    "exploded", "wiped out", "zombified", "committed trickery",
    "quit", "escaped", "ascended"
};

static const char *const killer_preposition[] = {
    "by", "on", "by", "of", "in", "of", "by", "in", "by", "by", "by", "by",
    "by", "by", "", "", "", ""
};


static const char *
add_killer_notes(int how, boolean carried, const char *killer)
{
    if (how == QUIT && u.uhp < 1)
        killer = msgcat(killer, " while already on Charon's boat");

    boolean already_helpless = FALSE;
    int i;
    for (i = hr_first; i <= hr_last; ++i)
        if (turnstate.helpless_timers[i]) {
            killer = msgcat_many(killer,
                                 already_helpless ? " and " : ", while ",
                                 turnstate.helpless_causes[i], NULL);
            already_helpless = TRUE;
        }

    if (Unchanging && (u.mh < 1) && Upolyd)
        killer = msgcat(killer, ", while stuck in monster form");

    if (carried & 0x0001UL) /* real Amulet of Yendor */
        killer = msgcat(killer, " (with the Amulet)");
    else if (how == ESCAPED) {
        /* Note: the fake Amulet check relies on bones not having been
           created; this is safe for escapes, but not safe in general */
        if (carrying(FAKE_AMULET_OF_YENDOR))
            killer = msgcat(killer, " (with a fake Amulet)");
        /* don't bother counting to see whether it should be plural */
    }

    return killer;
}


const char *
killer_msg(int how, const char *killer)
{
    return msgcat(killer_verb[how],
                  killer ? msgcat_many(" ", killer_preposition[how], " ",
                                       killer, NULL) : "");
}


const char *
killer_msg_mon(int how, struct monst *mtmp)
{
    return killer_msg(how, k_monnam(mtmp));
}


const char *
killer_msg_obj(int how, struct obj *obj)
{
    return killer_msg(how, killer_xname(obj));
}


static char**
delayed_killer_var(int how)
{
    switch (how) {
    case POISONING:
        return &u.delayed_killers.illness;

    case STONING:
        return &u.delayed_killers.stoning;

    case TURNED_SLIME:
        return &u.delayed_killers.sliming;

    case GENOCIDED:
        return &u.delayed_killers.genocide;

    case TURNED_ZOMBIE:
        return &u.delayed_killers.zombie;

    default:
        impossible("Illegal delayed killer type: %d", how);
        return 0;
    }
}


void
set_delayed_killer(int how, const char *killer)
{
    char **var = delayed_killer_var(how);

    if (!var)
        return;

    if (*var) {
        free(*var);
        *var = NULL;
    }

    if (killer) {
        int len = strlen(killer) + 1;
        char *buf = malloc(len);
        memcpy(buf, killer, len);
        *var = buf;
    }
}


const char *
delayed_killer(int how)
{
    char **var = delayed_killer_var(how);

    return var ? *var : NULL;
}


void
clear_delayed_killers(void)
{
    set_delayed_killer(POISONING, NULL);
    set_delayed_killer(STONING, NULL);
    set_delayed_killer(TURNED_SLIME, NULL);
    set_delayed_killer(GENOCIDED, NULL);
    set_delayed_killer(TURNED_ZOMBIE, NULL);
}

void
done_in_by(struct monst *mtmp, const char *override_msg)
{
    pline(msgc_fatal_predone, "You die...");

    if (mtmp->data->mlet == S_WRAITH && !noncorporeal(mtmp->data))
        u.ugrave_arise = PM_WRAITH;
    else if (mtmp->data->mlet == S_MUMMY && urace.mummynum != NON_PM)
        u.ugrave_arise = urace.mummynum;
    else if (mtmp->data->mlet == S_ZOMBIE && urace.zombienum != NON_PM &&
             mtmp->data != &mons[PM_GHOUL] &&
             mtmp->data != &mons[PM_SKELETON])
        u.ugrave_arise = urace.zombienum;
    else if (mtmp->data->mlet == S_VAMPIRE && Race_if(PM_HUMAN))
        u.ugrave_arise = PM_VAMPIRE;
    else if (mtmp->data == &mons[PM_GHOUL])
        u.ugrave_arise = PM_GHOUL;
    if (u.ugrave_arise >= LOW_PM && (mvitals[u.ugrave_arise].mvflags & G_GENOD))
        u.ugrave_arise = NON_PM;

    if (touch_petrifies(mtmp->data)) {
        done(STONING, override_msg ? override_msg :
             killer_msg_mon(STONING, mtmp));
    } else {
        done(DIED, override_msg ? override_msg : killer_msg_mon(DIED, mtmp));
    }

    return;
}


/*VARARGS1*/
noreturn void
panic_core(const char *file, int line, const char *str, ...)
{
    va_list the_args;
    const char *buf;

    nonfatal_dump_core();

    va_start(the_args, str);

    if (program_state.panicking++)
        terminate(GAME_DETACHED); /* avoid loops - this should never happen */

    buf = msgvprintf(str, the_args, TRUE);
    paniclog("panic", buf);
    DEBUG_LOG_BACKTRACE("panic() called: %s\n", buf);

    log_recover_noreturn(get_log_start_of_turn_offset(), buf, file, line);
}

static boolean
should_query_disclose_options(char *defquery)
{
    if (!defquery) {
        impossible("should_query_disclose_option: null defquery");
        return TRUE;
    }

    if (program_state.followmode == FM_RECOVERQUIT) {
        *defquery = 'n';
        return FALSE;
    }

    switch (flags.end_disclose) {
    default:   /* fall through */
    case DISCLOSE_PROMPT_DEFAULT_YES:
        *defquery = 'y';
        return TRUE;
    case DISCLOSE_YES_WITHOUT_PROMPT:
        *defquery = 'y';
        return FALSE;
    case DISCLOSE_PROMPT_DEFAULT_NO:
        *defquery = 'n';
        return TRUE;
    case DISCLOSE_NO_WITHOUT_PROMPT:
        *defquery = 'n';
        return FALSE;
    }
}


static void
disclose(int how, boolean taken, long umoney)
{
    char c = 0, defquery;
    const char *qbuf;
    boolean ask = should_query_disclose_options(&defquery);

    if (youmonst.minvent) {
        if (taken)
            qbuf = msgprintf("Do you want to see what you had when you %s?",
                             (how == QUIT) ? "quit" : "died");
        else
            /* This phrase is so fundamentally NetHack, I felt a huge sense of
               pride when I got to edit it, even though I was just changing it
               from a stack allocation to a string literal. Then I felt I should
               add a comment to it because it feels important enough to be
               dignified with one. So here it is. --AIS */
            qbuf = "Do you want your possessions identified?";

        struct obj *obj;

        for (obj = youmonst.minvent; obj;
             obj = obj->nobj) {
            /* In case we're to leave bones, set monster knowledge bits.
               Those will be reset in bones creation in case player leaves no
               "living" trace of themselves. */
            obj->mknown = obj->known;
            obj->mbknown = obj->bknown;

            discover_object(obj->otyp, TRUE, FALSE, TRUE);
            obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
            if (obj->oprops)
                learn_oprop(obj, obj_properties(obj));
        }

        if (!done_stopprint) {
            c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
            if (c == 'y') {
                display_inventory(NULL, FALSE);
                container_contents(youmonst.minvent, TRUE, TRUE, FALSE);
            }
            if (c == 'q')
                done_stopprint++;
        }
    }

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see your attributes?", ynqchars,
                              defquery) : defquery;
        if (c == 'y')
            enlightenment(how > LAST_KILLER  ? 1 : 2);     /* final */
        if (c == 'q')
            done_stopprint++;
    }

    if (!done_stopprint)
        list_vanquished(defquery, ask);

    if (!done_stopprint)
        list_genocided(defquery, ask);

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see your conduct?", ynqchars,
                              defquery) : defquery;
        if (c == 'y')
            show_conduct(how > LAST_KILLER ? 1 : 2);
        if (c == 'q')
            done_stopprint++;
    }

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see a breakdown of your score?",
                              ynqchars, defquery) : defquery;
        if (c == 'y')
            calc_score(how, TRUE, umoney);
        if (c == 'q')
            done_stopprint++;
    }
}

/* like disclose, but don't ask any questions */
static void
dump_disclose(int how)
{
    struct obj *obj;

    /* temporarily redirect menu window output into the dumpfile */
    dump_catch_menus(TRUE);

    /* re-"display" all the disclosure menus */
    /* make sure the inventory is fully identified, even if DYWYPI = n */
    for (obj = youmonst.minvent; obj; obj = obj->nobj) {
        discover_object(obj->otyp, TRUE, FALSE, TRUE);
        obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
    }
    display_inventory(NULL, TRUE);
    container_contents(youmonst.minvent, TRUE, TRUE, FALSE);
    dump_spells();
    dump_skills();
    enlightenment(how > LAST_KILLER ? 1 : 2);     /* final */
    list_vanquished('y', FALSE);
    list_genocided('y', FALSE);
    show_conduct(how > LAST_KILLER ? 1 : 2);
    dooverview(&(struct nh_cmd_arg){.argtype = 0});
    dohistory(&(struct nh_cmd_arg){.argtype = 0});
    calc_score(how, TRUE, money_cnt(youmonst.minvent) + hidden_gold());

    /* make menus work normally again */
    dump_catch_menus(FALSE);
}


/* try to get the player back in a viable state after being killed */
static void
savelife(int how)
{
    /* just swallow any --More--s that were waiting until we died; if the player
       has a force-more on msgc_fatalavoid, they'll get a --More-- anyway, and
       if they don't, they probably don't want one */
    turnstate.force_more_pending_until_done = FALSE;
    u.uswldtim = 0;
    u.uhp = u.uhpmax;
    u.mh = u.mhmax;
    if (u.uhunger < 500) {
        u.uhunger = 500;
        newuhs(FALSE);
    }
    /* cure impending doom of sickness hero won't have time to fix */
    if (property_timeout(&youmonst, SICK) == 1)
        set_property(&youmonst, SICK, -2, FALSE);
    if (property_timeout(&youmonst, ZOMBIE) == 1)
        set_property(&youmonst, ZOMBIE, -2, FALSE);
    if (how == CHOKING)
        init_uhunger();

    /* Note: this is different timing properties from 3.4.3. Mostly because the
       timing properties in 3.4.3 don't make sense at all. */
    pline(msgc_fatalavoid, "You survived that attempt on your life.");
    cancel_helplessness(hm_all, "");

    if (u.utrap && u.utraptype == TT_LAVA)
        u.utrap = 0;
    u.ugrave_arise = NON_PM;
    flush_screen();
}

/*
 * Get valuables from the given list.  Revised code: the list always remains
 * intact.
 */
static void
get_valuables(struct obj *list)
{
    struct obj *obj;
    int i;

    /* find amulets and gems, ignoring all artifacts */
    for (obj = list; obj; obj = obj->nobj)
        if (Has_contents(obj)) {
            get_valuables(obj->cobj);
        } else if (obj->oartifact) {
            continue;
        } else if (obj->oclass == AMULET_CLASS) {
            i = obj->otyp - FIRST_AMULET;
            if (!amulets[i].count) {
                amulets[i].count = obj->quan;
                amulets[i].typ = obj->otyp;
            } else
                amulets[i].count += obj->quan;  /* always adds one */
        } else if (obj->oclass == GEM_CLASS && obj->otyp < LUCKSTONE) {
            i = min(obj->otyp, LAST_GEM + 1) - FIRST_GEM;
            if (!gems[i].count) {
                gems[i].count = obj->quan;
                gems[i].typ = obj->otyp;
            } else
                gems[i].count += obj->quan;
        }
    return;
}

/*
 *  Sort collected valuables, most frequent to least.  We could just
 *  as easily use qsort, but we don't care about efficiency here.
 */
static void
sort_valuables(struct valuable_data list[],
               int size    /* max value is less than 20 */ )
{
    int i, j;
    struct valuable_data ltmp;

    /* move greater quantities to the front of the list */
    for (i = 1; i < size; i++) {
        if (list[i].count == 0)
            continue;   /* empty slot */
        ltmp = list[i]; /* structure copy */
        for (j = i; j > 0; --j)
            if (list[j - 1].count >= ltmp.count)
                break;
            else {
                list[j] = list[j - 1];
            }
        list[j] = ltmp;
    }
    return;
}

/* called twice; first to calculate total, then to list relevant items */
static int artifact_score(struct obj *list,
                          boolean counting,  /* true => add up points;
                                                false => display them */
                          struct nh_menulist *menu) {
    const char *pbuf;
    struct obj *otmp;
    long value, total;
    short dummy;        /* object type returned by artifact_name() */

    total = 0;

    for (otmp = list; otmp; otmp = otmp->nobj) {
        if (otmp->oartifact || otmp->otyp == BELL_OF_OPENING ||
            otmp->otyp == SPE_BOOK_OF_THE_DEAD ||
            otmp->otyp == CANDELABRUM_OF_INVOCATION) {
            value = arti_cost(otmp);    /* zorkmid value */
            if (counting) {
                total += value;
            } else {
                makeknown(otmp->otyp);
                otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = 1;
                /* assumes artifacts don't have quan > 1 */
                pbuf = msgprintf("%s%s (worth %ld %s)",
                                 the_unique_obj(otmp) ? "The " : "",
                                 otmp->oartifact ?
                                 artifact_name(xname(otmp), &dummy) :
                                 OBJ_NAME(objects[otmp->otyp]),
                                 value, currency(value));
                add_menutext(menu, pbuf);
            }
        }
        if (Has_contents(otmp))
            artifact_score(otmp->cobj, counting, menu);
    }
    return total;
}

/* Calculate the player's score, and return it (show = FALSE), or
   show it to the user (show = TRUE). */
long
calc_score(int how, boolean show, long umoney)
{
    /* The principle here is that each category is worth up to 30000 points;
       most categories are calculated via base-2 logarithm, to give massive
       diminishing returns to farming in any particular category; categories
       which have an intrinsic maximum anyway (such as the percentages) instead 
       are based on the square root of the percentage progress made. */
    long total = 0;
    long category_raw;
    double category_ratio;
    long category_points;

    const long long max_squared = 30000LL * 30000LL;

    struct nh_menulist menu;
    const char *buf;

    /* Initialise the explanation window, if show is true. */
    if (show)
        init_menulist(&menu);

    /* Gold. x gold scores log2(x+1)*1000 points (maxing at 30000 for MAXINT
       gold; just in case gold can be 64-bit, we cap it at the 32-bit MAXINT
       first). This counts profit from starting inventory, rather than the
       amount, to avoid giving bonuses to early-game Healers. */
    category_raw = umoney;
    category_raw -= u.umoney0;
    if (category_raw < 0)
        category_raw = 0;
    category_points = ilog2(category_raw + 1);
    if (category_points > 30000)
        category_points = 30000;
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Gold:            %10ld                    (%5ld points)",
            category_raw, category_points);
        add_menutext(&menu, buf);
    }

    /* Experience. Although this maxes at 30, the ratio isn't displayed. */
    category_raw = u.ulevel;
    category_points = isqrt(((u.ulevel - 1) * max_squared) / 29);
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Experience:      %10ld level%s             (%5ld points)",
            category_raw, category_raw == 1 ? " " : "s", category_points);
        add_menutext(&menu, buf);
    }

    /* Exploration. This is based on the ratio of the Sanctum depth to the
       deepest level reached, and is based on the square root of the ratio. */
    category_raw = deepest_lev_reached(FALSE);
    category_ratio = category_raw * 100.0 / depth(&sanctum_level);
    category_points = isqrt(((category_raw - 1) * max_squared) /
                            (depth(&sanctum_level) - 1));
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Exploration:     %10ld level%s   (%6.2f%%) (%5ld points)",
            category_raw, category_raw == 1 ? " " : "s", category_ratio,
            category_points);
        add_menutext(&menu, buf);
    }

    /* Discoveries. Based on the ratio of the number of items discovered, to
       the maximum possible number of items discovered. */
    {
        int curd, maxd;

        count_discovered_objects(&curd, &maxd);
        category_raw = curd;
        if (!maxd) { /* hotfix: should never happen */
            category_ratio = 0;
            category_points = 0;
        } else {
            category_ratio = curd * 100.0 / maxd;
            category_points = isqrt((curd * max_squared) / maxd);
        }
    }
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Discoveries:     %10ld item%s    (%6.2f%%) (%5ld points)",
            category_raw, category_raw == 1 ? " " : "s", category_ratio,
            category_points);
        add_menutext(&menu, buf);
    }

    /* Valuables. Scored the same way as gold, based on their gp values. Scores 
       only on ascension or escape. */
    category_raw = 0;
    if (how == ESCAPED || how == ASCENDED) {
        const struct val_list *val;
        int i;

        for (val = valuables; val->list; val++)
            for (i = 0; i < val->size; i++) {
                val->list[i].count = 0L;
            }
        get_valuables(youmonst.minvent);
        for (val = valuables; val->list; val++)
            for (i = 0; i < val->size; i++)
                if (val->list[i].count != 0L)
                    category_raw +=
                        val->list[i].count *
                        (long)objects[val->list[i].typ].oc_cost;
        category_points = ilog2(category_raw + 1);
        if (category_points > 30000)
            category_points = 30000;
        total += category_points;

        if (show) {
            buf = msgprintf(
                "Valuables value: %10ld                    (%5ld points)",
                category_raw, category_points);
            add_menutext(&menu, buf);
        }
    } else if (show) {
        add_menutext(&menu,
                     "Valuables value: (no points given unless you survive)");
    }

    /* Artifacts. */
    category_raw = artifact_score(youmonst.minvent, TRUE, 0);
    category_points = ilog2(category_raw + 1);
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Artifact value:  %10ld                    (%5ld points)",
            category_raw, category_points);
        add_menutext(&menu, buf);
    }

    /* Variety of monsters vanquished. (All that matters is whether or not a
       monster was killed, so people can't farm this score up indefinitely; and
       this counts vanquished not killed so that pacifists aren't penalised for
       their conduct.) */
    {
        int i;

        category_raw = 0;
        for (i = LOW_PM; i < NUMMONS; i++) {
            if (mvitals[i].died)
                category_raw++;
        }
    }
    category_ratio = category_raw * 100.0 / (NUMMONS - LOW_PM);
    category_points = isqrt((category_raw * max_squared) / (NUMMONS - LOW_PM));
    total += category_points;

    if (show) {
        buf = msgprintf(
            "Variety of kills:%10ld monster%s (%6.2f%%) (%5ld points)",
            category_raw, category_raw == 1 ? " " : "s", category_ratio,
            category_points);
        add_menutext(&menu, buf);
    }

    /* Time penalty. */
    category_raw = moves;
    category_points = ilog2(max(moves, 2000)) - ilog2(2000);
    total -= category_points;

    if (show) {
        buf = msgprintf(
            "Turncount:       %10ld turn%s              (%5ld points)",
            category_raw, category_raw == 1 ? " " : "s", -category_points);
        add_menutext(&menu, buf);
    }

    /* Survival. A multiplier. */
    if (how == ASCENDED)
        category_raw = 200;
    else if (how == ESCAPED)
        category_raw = 100;
    else if (how == QUIT)
        category_raw = 90;
    else
        category_raw = 80;
    total *= category_raw;
    total /= 100;

    if (show) {
        buf = msgprintf(
            "Survival:        %10s  (score multiplied by %3ld%%)",
            category_raw == 80 ? (how ==
                                  -1 ? "unknown" : "died") : category_raw ==
            90 ? "quit" : category_raw == 200 ? "ascended" : "survived",
            category_raw);
        add_menutext(&menu, buf);
        add_menutext(&menu, "");
        buf = msgprintf("Total score:                               %10ld",
                        total);
        add_menutext(&menu, buf);
    }

    /* Finishing off. */
    if (show)
        display_menu(&menu, "Score breakdown:", PICK_NONE,
                     PLHINT_ANYWHERE, NULL);

    return total;
}

static boolean
check_survival(int how)
{
    if (how == TRICKED) {
        if (wizard) {
            pline(msgc_debug, "You are a very tricky wizard, it seems.");
            return TRUE;
        }
    }

    if (how <= LAST_KILLER) {
        u.umortality++;
        if (Lifesaved) {
            pline(msgc_statusheal, "But wait...");
            pline_implied(msgc_statusheal, "Your medallion %s!",
                          !Blind ? "begins to glow" : "feels warm");
            if (how == CHOKING)
                pline_implied(msgc_statusheal, "You vomit ...");
            pline_implied(msgc_statusheal, "You feel much better!");
            pline_implied(msgc_itemloss, "The medallion crumbles to dust!");
            if (uamul) {
                tell_discovery(uamul);
                useup(uamul);
            }

            adjattrib(A_CON, -1, TRUE);
            if (u.uhpmax <= 0)
                u.uhpmax = 10;      /* arbitrary */
            savelife(how);
            if (how == GENOCIDED)
                pline(msgc_fatal_predone,
                      "Unfortunately you are still genocided...");
            else {
                historic_event(FALSE, TRUE, "averted death");
                return TRUE;
            }
        }
    }
    if ((wizard || discover) && (how <= LAST_KILLER)) {
        if (yn("Die?") == 'y')
            return FALSE;
        /* we can't use msgc_debug here because explore-mode players won't be
           able to see it; msgc_saveload is most appropriate (and documented as
           allowing this sort of thing), because although it isn't technically
           a savescum, it has a similar effect */
        pline(msgc_saveload, "OK, so you don't %s.",
              (how == CHOKING) ? "choke" : "die");
        if (u.uhpmax <= 0)
            u.uhpmax = u.ulevel * 8;    /* arbitrary */
        savelife(how);
        historic_event(FALSE, FALSE, "decided not to die");
        return TRUE;
    }

    return FALSE;
}

/* No longer cares about done_stopprint, mostly because it's pretty common
   to want to 'q' through the disclose but see the tombstone */
void
display_rip(int how, long umoney, const char *killer)
{
    const char *pbuf;
    struct nh_menulist menu;

    if (!program_state.game_running)
        return;

    init_menulist(&menu);

    pbuf = msgprintf("%s %s the %s, %s...", Goodbye(), u.uplname,
                     how != ASCENDED ?
                     (const char *)((u.ufemale && urole.name.f) ?
                                    urole.name.f : urole.name.m) :
                     (const char *)(u.ufemale ?
                                    "Demigoddess" : "Demigod"),
                     killer);
    add_menutext(&menu, pbuf);
    add_menutext(&menu, "");

    if (how == ESCAPED || how == ASCENDED) {
        struct monst *mtmp;
        struct obj *otmp;
        const struct val_list *val;
        int i;

        keepdogs(TRUE);
        mtmp = turnstate.migrating_pets;
        pbuf = "You";
        if (mtmp) {
            while (mtmp) {
                pbuf = msgcat_many(pbuf, " and ", mon_nam(mtmp), NULL);
                mtmp = mtmp->nmon;
            }
            if (!done_stopprint)
                add_menutext(&menu, pbuf);
            pbuf = "";
        } else {
            pbuf = "You ";
        }

        pbuf = msgprintf("%s%s with %d point%s,", pbuf,
                         how == ASCENDED ? "went to your reward" :
                         "escaped from the dungeon",
                         u.urexp, plur(u.urexp));
        add_menutext(&menu, pbuf);

        artifact_score(youmonst.minvent, FALSE, &menu); /* list artifacts */

        /* list valuables here */
        for (val = valuables; val->list; val++) {
            sort_valuables(val->list, val->size);
            for (i = 0; i < val->size && !done_stopprint; i++) {
                int typ = val->list[i].typ;
                long count = val->list[i].count;

                if (count == 0L)
                    continue;
                if (objects[typ].oc_class != GEM_CLASS || typ <= LAST_GEM) {
                    otmp = mksobj(level, typ, FALSE, FALSE, rng_display);
                    makeknown(otmp->otyp);
                    otmp->known = 1;    /* for fake amulets */
                    otmp->dknown = 1;   /* seen it (blindness fix) */
                    christen_obj(otmp, NULL);
                    otmp->quan = count;
                    pbuf = msgprintf("%8ld %s (worth %ld %s),", count,
                                     xname(otmp), count *
                                     (long)objects[typ].oc_cost, currency(2L));
                    obfree(otmp, NULL);
                } else {
                    pbuf = msgprintf("%8ld worthless piece%s of colored glass,",
                                     count, plur(count));
                }
                add_menutext(&menu, pbuf);
            }
        }

    } else {
        /* did not escape or ascend */
        if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
            /* level teleported out of the dungeon; `how' is DIED, due to
               falling or to "arriving at heaven prematurely" */
            pbuf = msgprintf("You %s beyond the confines of the dungeon",
                             (u.uz.dlevel < 0) ? "passed away" : ends[how]);
        } else {
            /* more conventional demise */
            const char *where = find_dungeon(&u.uz).dname;

            if (Is_astralevel(&u.uz))
                where = "The Astral Plane";
            pbuf = msgprintf("You %s in %s", ends[how], where);
            if (!In_endgame(&u.uz) && !Is_knox(&u.uz))
                pbuf = msgprintf("%s on dungeon level %d", pbuf,
                                 In_quest(&u.uz) ?
                                 dunlev(&u.uz) : depth(&u.uz));
        }

        pbuf = msgprintf("%s with %d point%s,", pbuf, u.urexp, plur(u.urexp));
        add_menutext(&menu, pbuf);
    }

    pbuf = msgprintf("and %ld piece%s of gold, after %u move%s.", umoney,
                     plur(umoney), moves, plur(moves));
    add_menutext(&menu, pbuf);
    pbuf = msgprintf("You were level %d with a maximum of %d "
                     "hit point%s when you %s.",
                     u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
    add_menutext(&menu, pbuf);
    add_menutext(&menu, "");

    outrip(&menu, how <= LAST_KILLER && flags.tombstone,
           u.uplname, umoney, killer, how, getyear());
}

void
done(int how, const char *killer)
{
    if (check_survival(how))
        return;

    if (program_state.followmode == FM_REPLAY)
        replay_done_noreturn();

    done_noreturn(how, killer);
}

noreturn void
done_noreturn(int how, const char *killer)
{
    boolean taken;
    boolean bones_ok;
    struct obj *corpse = NULL;
    long umoney;

    /* If watching or replaying, we're going to get a GAME_OVER on the main
       process, = we should produce GAME_ALREADY_OVER on watching processes. */
    if (program_state.followmode != FM_PLAY &&
        program_state.followmode != FM_RECOVERQUIT) {
        win_pause_output(P_MESSAGE);
        terminate(GAME_ALREADY_OVER);
    }

    /* 
     *      The game is now over...
     */
    program_state.gameover = 1;
    log_record_input("Q");

    /* might have been killed while using a disposable item, so make sure it's
       gone prior to inventory disclosure and creation of bones data */
    inven_inuse(TRUE);

    if (turnstate.force_more_pending_until_done)
        win_pause_output(P_MESSAGE);

    /* Sometimes you die on the first move.  Life's not fair. On those rare
       occasions you get hosed immediately, go out smiling... :-) -3. */
    if (moves <= 1 && how <= LAST_KILLER)   /* You die... --More-- */
        pline(msgc_outrobad, "Do not pass go.  Do not collect 200 %s.",
              currency(200L));

    bones_ok = how <= LAST_KILLER && how != GENOCIDED && can_make_bones(&u.uz);

    if (!killer)
        killer = killer_msg(how, NULL);

    if (how == TURNED_SLIME)
        u.ugrave_arise = PM_GREEN_SLIME;

    if (how == TURNED_ZOMBIE && urace.zombienum != NON_PM)
        u.ugrave_arise = urace.zombienum;

    if (bones_ok && u.ugrave_arise < LOW_PM) {
        /* corpse gets burnt up too */
        if (how == BURNING)
            u.ugrave_arise = (NON_PM - 2);      /* leave no corpse */
        else if (how == STONING)
            u.ugrave_arise = (NON_PM - 1);      /* statue instead of corpse */
        else if (u.ugrave_arise == NON_PM &&
                 !(mvitals[u.umonnum].mvflags & G_NOCORPSE)) {
            int mnum = u.umonnum;
            const char *pbuf;

            if (!Upolyd && !is_human(youmonst.data)) {
                /* Base corpse on race when not poly'd since original u.umonnum 
                   is based on role, and all role monsters are human. */
                mnum = urace.num;
            }
            corpse = mk_named_object(CORPSE, &mons[mnum], u.ux, u.uy,
                                     u.uplname);
            /* how <= LAST_KILLER is required for bones_ok */
            pbuf = msgcat_many(u.uplname, ", ", killer, NULL);
            make_grave(level, u.ux, u.uy, pbuf);
        }
    }

    /* The "carried at death" field of the xlog needs to have remembered
       values from before leaving bones; if the Candelabrum, etc., is dropped
       on the ground and transformed into a candle, Uhave_menorah will be 0,
       whereas we want 1 in the disclose */
    unsigned long carried = encode_carried();

    const char *noted_killer = add_killer_notes(how, carried, killer);
    log_game_over(noted_killer);
    /* Don't log anything from now on (in particular, don't log the DYWYPI). If
       you do, then the above log_game_over call assumes that the DYWYPI should
       have been replayed already, and gets into an infinite loop restarting the
       turn. */
    program_state.in_zero_time_command = TRUE;

    /* these affect score and/or bones, but avoid them during panic */
    taken = paybill((how == ESCAPED) ? -1 : (how != QUIT));
    paygd();
    clearpriests();

    if (flags.end_disclose != DISCLOSE_NO_WITHOUT_PROMPT)
        disclose(how, taken,
                 money_cnt(youmonst.minvent) + hidden_gold());

    /* calculate score, before creating bones [container gold] */
    umoney = money_cnt(youmonst.minvent) + hidden_gold();
    u.urexp = calc_score(how, FALSE, umoney);

    const char *dumpname = begin_dump(how);
    dump_disclose(how);

    if (bones_ok && !discover) {
        if (!wizard || yn("Save bones?") == 'y')
            savebones(corpse, taken);
        /* corpse may be invalid pointer now, so ensure that it isn't used
           again */
        corpse = NULL;
    }

    end_dump(how, umoney, noted_killer);
    display_rip(how, umoney, noted_killer);

    /* generate a topten entry for this game. update_topten does not display
       anything. */
    update_topten(how, noted_killer, carried, dumpname ? dumpname : "");

    terminate(GAME_OVER);
}


void
container_contents(struct obj *list, boolean identified,
                   boolean all_containers, boolean ingame)
{
    struct obj *box, *obj;
    int i, icount;
    struct nh_objlist objmenu;

    for (box = list; box; box = box->nobj) {
        if (Is_container(box) || box->otyp == STATUE) {
            if (box->otyp == BAG_OF_TRICKS)
                continue;       /* wrong type of container */

            boolean quantum_cat = FALSE;

            if ((box->spe == 1) && (box->otyp != STATUE) &&
                ingame) {
                observe_quantum_cat(box);
                quantum_cat = TRUE;
            }

            if (box->cobj) {
                /* count contained objects */
                icount = 0;
                for (obj = box->cobj; obj; obj = obj->nobj)
                    icount++;

                struct obj *contents[icount];

                /* add the objects to a list */
                icount = 0;
                for (obj = box->cobj; obj; obj = obj->nobj) {
                    if (identified) {
                        discover_object(obj->otyp, TRUE, FALSE, TRUE);
                        obj->known = obj->bknown = obj->dknown =
                            obj->rknown = 1;
                        learn_oprop(obj, obj->oprops);
                    }
                    contents[icount++] = obj;
                }

                /* sort the list */
                qsort(contents, icount, sizeof (struct obj *), obj_compare);

                /* add the sorted objects to the menu */
                init_objmenulist(&objmenu);

                for (i = 0; i < icount; i++)
                    add_objitem(&objmenu, MI_NORMAL, i + 1,
                                doname(contents[i]), contents[i], FALSE);

                display_objects(&objmenu,
                                msgprintf("Contents of %s:", the(xname(box))),
                                PICK_NONE, PLHINT_CONTAINER, NULL);

                if (all_containers)
                    container_contents(box->cobj, identified, TRUE, FALSE);

            } else if (ingame || !done_stopprint) {
                pline(msgc_info, "%s %sempty.", Tobjnam(box, "are"),
                      quantum_cat ? "now " : "");
                win_pause_output(P_MESSAGE);
            }
        }
        if (!all_containers)
            break;
    }
}


/* Exits or aborts a running game, or an API call that happens outside a game.
   This is used for both normal and abnormal termination. The semantics are
   roughly "unwind the stack until you find nh_play_game, or if it isn't there,
   some other API call; then return playstatus from it if it's nh_play_game, or
   a suitable error code if it isn't there". */
noreturn void
terminate(enum nh_play_status playstatus)
{
    /* don't bother to try to release memory if we're in panic mode, to avoid
       trouble in case that happens to be due to memory problems */
    if (!program_state.panicking) {
        freedynamicdata();
        dlb_cleanup();
    }

    /* try to leave gracefully - this should return control to the ui code */
    if (exit_jmp_buf_valid) {
        exit_jmp_buf_valid = 0;
        nh_longjmp(exit_jmp_buf, API_ENTRY_OFFSET + playstatus);
    }

    /* We should always have a jmp_buf. If not, something's gone badly wrong.
       We can't rely on any particular internal function working (in particular,
       panic() is no good because it tries to call terminate()), so... */
    abort();
}

void
nonfatal_dump_core(void)
{
#ifndef AIMAKE_BUILDOS_MSWin32
    if (!fork()) {
        /* We want to make no assumptions about program state, so don't do
           anything on an error. */
        abort();
    }
#endif
}

void
list_vanquished(char defquery, boolean ask)
{
    int i, lev;
    int ntypes = 0, max_lev = 0, nkilled;
    long total_killed = 0L;
    char c;
    const char *buf;
    struct nh_menulist menu;

    /* get totals first */
    for (i = LOW_PM; i < NUMMONS; i++) {
        if (mvitals[i].died)
            ntypes++;
        total_killed += (long)mvitals[i].died;
        if (mons[i].mlevel > max_lev)
            max_lev = mons[i].mlevel;
    }

    /* vanquished creatures list; includes all dead monsters, not just those
       killed by the player */
    if (ntypes != 0) {
        c = ask ? yn_function("Do you want an account of creatures vanquished?",
                              ynqchars, defquery) : defquery;
        if (c == 'q')
            done_stopprint++;
        if (c == 'y') {
            init_menulist(&menu);

            /* countdown by monster "toughness" */
            for (lev = max_lev; lev >= 0; lev--)
                for (i = LOW_PM; i < NUMMONS; i++)
                    if (mons[i].mlevel == lev &&
                        (nkilled = mvitals[i].died) > 0) {
                        if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST) {
                            buf = msgcat(!type_is_pname(&mons[i]) ? "The " : "",
                                         mons[i].mname);
                            if (nkilled > 1) {
                                switch (nkilled) {
                                case 2:
                                    buf = msgcat(buf, " (twice)");
                                    break;
                                case 3:
                                    buf = msgcat(buf, " (thrice)");
                                    break;
                                default:
                                    buf = msgprintf("%s (%d time%s)",
                                                    buf, nkilled,
                                                    plur(nkilled));
                                    break;
                                }
                            }
                        } else {
                            /* trolls or undead might have come back, but we
                               don't keep track of that */
                            if (nkilled == 1)
                                buf = an(mons[i].mname);
                            else
                                buf = msgprintf("%d %s", nkilled,
                                                makeplural(mons[i].mname));
                        }
                        add_menutext(&menu, buf);
                    }
            if (Hallucination)
                add_menutext(&menu, "and a partridge in a pear tree");
            if (ntypes > 1) {
                add_menutext(&menu, "");
                add_menutext(&menu, msgprintf("%ld creatures vanquished.",
                                              total_killed));
            }
            display_menu(&menu, "Vanquished creatures:",
                         PICK_NONE, PLHINT_ANYWHERE, NULL);
        }
    }
}

/* number of monster species which have been genocided */
int
num_genocides(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if (mvitals[i].mvflags & G_GENOD)
            ++n;

    return n;
}

/* number of monster species which have been extincted */
int
num_extinctions(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if ((mvitals[i].mvflags & G_EXTINCT) && !(mons[i].geno & G_UNIQ))
            ++n;

    return n;
}

/* number of monster species which have been vanquished */
int
num_vanquished(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if (mvitals[i].died)
            ++n;

    return n;
}

void
list_genocided(char defquery, boolean ask)
{
    int i;
    int ngenocided, ungenocided, mngenocided, nextincted;
    char c;
    const char *query, *title, *buf;
    struct nh_menulist menu;

    ngenocided = num_genocides();
    ungenocided = u.uconduct[conduct_genocide];
    mngenocided = ngenocided - ungenocided;
    nextincted = num_extinctions();

    /* genocided species list */
    if (ngenocided != 0 || nextincted != 0) {
        query =
            nextincted ? "Do you want a list of species genocided or extinct?" :
            "Do you want a list of species genocided?";
        c = ask ? yn_function(query, ynqchars, defquery) : defquery;
        if (c == 'q')
            done_stopprint++;
        if (c == 'y') {
            init_menulist(&menu);
            for (i = LOW_PM; i < NUMMONS; i++)
                if ((mvitals[i].mvflags & G_GENOD) ||
                    ((mvitals[i].mvflags & G_EXTINCT) &&
                     !(mons[i].geno & G_UNIQ))) {
                    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
                        buf = msgcat( !type_is_pname(&mons[i]) ? "" : "the ",
                                      mons[i].mname);
                    else
                        buf = makeplural(mons[i].mname);

                    if (!(mvitals[i].mvflags & G_GENOD))
                        buf = msgcat(buf, " (extinct)");
                    add_menutext(&menu, buf);
                }

            add_menutext(&menu, "");
            buf = msgprintf("%d species genocided.", ngenocided);
            if (mngenocided)
                buf = msgprintf("%d species genocided by you, %d by monsters",
                                ungenocided, mngenocided);
            if (ngenocided)
                add_menutext(&menu, buf);
            buf = msgprintf("%d species extinct.", nextincted);
            if (nextincted)
                add_menutext(&menu, buf);

            title =
                nextincted ? "Genocided or extinct species:" :
                "Genocided species:";
            display_menu(&menu, title, PICK_NONE,
                         PLHINT_ANYWHERE, NULL);
        }
    }
}

/*end.c*/
